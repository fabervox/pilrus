<!DOCTYPE html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Программирование на языке Lua. Третье издание.</title>
  <link type="text/css" rel="stylesheet" href="PiL3_files/PiL3.css">
</head>
<body>

<div class="section">© 2013, 2003 by Roberto Ierusalimschy ©</div>

<table>
  <tr> 
    <td><img width="64px" src="PiL3_files/logo.gif" alt="Lua_logo" border="0"></td>
    <td width="20px"></td>
    <td><h1>Программирование на языке Lua. Третье издание.</h1></td>
  </tr>
</table>

<div class="section">Пролог</div>

<p>Книга посвящена одному из самых популярных встраиваемых языков - <i>Lua</i>. Этот язык использовался во многих играх и большом количестве различных приложений. Язык сочетает небольшой обьем занимаемый памяти, высокое быстродействие, простоту использования и большую гибкость. Книга рассматривает практически все аспекты использования Lua, начиная с основ языка и заканчивая тонкостями расширения языка и взаимодействия с С.</p>

<p>Важной особенностью книги является огромный спектр охватываемых тем - практически все, что может понадобиться при использовании Lua. Также к каждой главе дается несколько упражнений, позволяющих проверить свои знания.</p>

<p>Книги будет полезна широкому кругу программистов и разработчиков игр. Для понимания последних глав книги необходимо знание языка С, но для большинства остальных глав достаточно базовых знании о программировании.</p>

<p>Все права защищены. Любая часть этой книги не может быть воспроизведена в какой бы то ни было форме и какими бы то ни было средствами без письменного разрешения владельцев авторских прав.</p>

<p>Материал, изложенный в данной книге, многократно проверен. Но, поскольку вероятность технических ошибок все равно существует, издательство не может гарантировать абсолютную точность и правильность приводимых сведений. В связи с этим издательство не несет ответственности за возможные ошибки, связанные с использованием книги.</p>

<div class="section">ОГЛАВЛЕНИЕ</div>

<ul class="content">
  <li class="head"><a href="#Введение">Введение</a></li>
    <ul>
    <li><a href="#Аудитория">Аудитория</a></li>
    <li><a href="#О третьем издании">О третьем издании</a></li>
    <li><a href="#Другие ресурсы">Другие ресурсы</a></li>
    <li><a href="#Некоторые типографские соглашения">Некоторые типографские соглашения</a></li>
    <li><a href="#Запуск примеров">Запуск примеров</a></li>
    <li><a href="#Благодарности">Благодарности</a></li>
    </ul>
  <hr>
  <li class="head">ЧАСТЬ I. Язык</li>
  <hr>
  <li class="head"><a href="#Глава 1. Начинаем">Глава 1. Начинаем</a></li>
    <ul>
    <li><a href="#1.1. Блоки">1.1. Блоки</a></li>
    <li><a href="#1.2. Некоторые лексические соглашения">1.2. Некоторые лексические соглашения</a></li>
    <li><a href="#1.3. Глобальные переменные">1.3. Глобальные переменные</a></li>
    <li><a href="#1.4. Отдельный интерпретатор">1.4. Отдельный интерпретатор</a></li>
    <li><a href="#1. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 2. Типы и значения">Глава 2. Типы и значения</a></li>
    <ul>
    <li><a href="#2.1. Nil">2.1. <i>Nil</i></a></li>
    <li><a href="#2.2. Boolean (логические значения)">2.2. <i>Boolean</i> (логические значения)</a></li>
    <li><a href="#2.3. Числа">2.3. Числа</a></li>
    <li><a href="#2.4. Строки">2.4. Строки</a></li>
      <ul>
      <li><a href="#2.4. Литералы">Литералы</a></li>
      <li><a href="#2.4. Длинные строки">Длинные строки</a></li>
      <li><a href="#2.4. Приведения типов">Приведения типов</a></li>
      </ul>
    <li><a href="#2.5. Таблицы">2.5. Таблицы</a></li>
    <li><a href="#2.6. Функции">2.6. Функции</a></li>
    <li><a href="#2.7. userdata и нити">2.7. <i>userdata</i> и нити</a></li>
    <li><a href="#2. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 3. Выражения">Глава 3. Выражения</a></li>
    <ul>
    <li><a href="#3.1. Арифметические операторы">3.1. Арифметические операторы</a></li>
    <li><a href="#3.2. Операторы сравнения">3.2. Операторы сравнения</a></li>
    <li><a href="#3.3. Логические операторы">3.3. Логические операторы</a></li>
    <li><a href="#3.4. Конкатенация">3.4. Конкатенация</a></li>
    <li><a href="#3.5. Оператор длины">3.5. Оператор длины</a></li>
    <li><a href="#3.6. Приоритеты операторов">3.6. Приоритеты операторов</a></li>
    <li><a href="#3.7. Конструкторы таблиц">3.7. Конструкторы таблиц</a></li>
    <li><a href="#3. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 4. Операторы">Глава 4. Операторы</a></li>
    <ul>
    <li><a href="#4.1. Операторы присваивания">4.1. Операторы присваивания</a></li>
    <li><a href="#4.2. Локальные переменные и блоки">4.2. Локальные переменные и блоки</a></li>
    <li><a href="#4.3. Управляющие конструкции">4.3. Управляющие конструкции</a></li>
      <ul>
      <li><a href="#4.3. if then else"><i>if then else</i></a></li>
      <li><a href="#4.3. while"><i>while</i></a></li>
      <li><a href="#4.3. repeat"><i>repeat</i></a></li>
      <li><a href="#4.3. Числовой оператор for">Числовой оператор <i>for</i></a></li>
      <li><a href="#4.3. Оператор for общего вида">Оператор <i>for</i> общего вида</a></li>
      </ul>
    <li><a href="#4.4. break, return и goto">4.4. <i>break</i>, <i>return</i> и <i>goto</i></a></li>
    <li><a href="#4. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 5. Функции">Глава 5. Функции</a></li>
    <ul>
    <li><a href="#5.1. Множественные результаты">5.1. Множественные результаты</a></li>
    <li><a href="#5.2. Функции с переменным числом аргументов">5.2. Функции с переменным числом аргументов</a></li>
    <li><a href="#5.3. Именованные аргументы">5.3. Именованные аргументы</a></li>
    <li><a href="#5. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 6. Ещё о функциях">Глава 6. Ещё о функциях</a></li>
    <ul>
    <li><a href="#6.1. Замыкания">6.1. Замыкания</a></li>
    <li><a href="#6.2. Неглобальные функции">6.2. Неглобальные функции</a></li>
    <li><a href="#6.3. Оптимизация хвостовых вызовов">6.3. Оптимизация хвостовых вызовов</a></li>
    <li><a href="#6. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 7. Итераторы и обобщенный for">Глава 7. Итераторы и обобщенный for</a></li>
    <ul>
    <li><a href="#7.1. Итераторы и замыкания">7.1. Итераторы и замыкания</a></li>
    <li><a href="#7.2. Семантика обобщенного for">7.2. Семантика обобщенного <i>for</i></a></li>
    <li><a href="#7.3. Итераторы без состояния">7.3. Итераторы без состояния</a></li>
    <li><a href="#7.4. Итераторы со сложным состоянием">7.4. Итераторы со сложным состоянием</a></li>
    <li><a href="#7.5. Подлинные итераторы (true iterarators)">7.5. Подлинные итераторы (<i>true iterarators</i>)</a></li>
    <li><a href="#7. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 8. Компиляция, выполнение и ошибки">Глава 8. Компиляция, выполнение и ошибки</a></li>
    <ul>
    <li><a href="#8.1. Компиляция">8.1. Компиляция</a></li>
    <li><a href="#8.2. Предкомпилированный код">8.2. Предкомпилированный код</a></li>
    <li><a href="#8.3. Код на С">8.3. Код на С</a></li>
    <li><a href="#8.4. Ошибки">8.4. Ошибки</a></li>
    <li><a href="#8.5. Обработка ошибок и исключений">8.5. Обработка ошибок и исключений</a></li>
    <li><a href="#8.6. Сообщения об ошибках и стек вызовов">8.6. Сообщения об ошибках и стек вызовов</a></li>
    <li><a href="#8. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 9. Сопрограммы">Глава 9. Сопрограммы</a></li>
    <ul>
    <li><a href="#9.1. Основы сопрограмм">9.1. Основы сопрограмм</a></li>
    <li><a href="#9.2. Каналы и фильтры">9.2. Каналы и фильтры</a></li>
    <li><a href="#9.3. Сопрограммы как итераторы">9.3. Сопрограммы как итераторы</a></li>
    <li><a href="#9.4. Невытесняющая многонитевость">9.4. Невытесняющая многонитевость</a></li>
    <li><a href="#9. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 10. Законченные примеры">Глава 10. Законченные примеры</a></li>
    <ul>
    <li><a href="#10.1. Задача о восьми королевах">10.1. Задача о восьми королевах</a></li>
    <li><a href="#10.2. Самые часто встречающиеся слова">10.2. Самые часто встречающиеся слова</a></li>
    <li><a href="#10.3. Цепь Маркова">10.3. Цепь Маркова</a></li>
    <li><a href="#10. Упражнения">Упражнения</a></li>
    </ul>
  <hr>
  <li class="head">ЧАСТЬ II. Таблицы и обьекты</li>
  <hr>
  <li class="head"><a href="#Глава 11. Структуры данных">Глава 11. Структуры данных</a></li>
    <ul>
    <li><a href="#11.1. Массивы">11.1. Массивы</a></li>
    <li><a href="#11.2. Матрицы и многомерные массивы">11.2. Матрицы и многомерные массивы</a></li>
    <li><a href="#11.3. Связанные списки">11.3. Связанные списки</a></li>
    <li><a href="#11.4. Очереди и двойные очереди">11.4. Очереди и двойные очереди</a></li>
    <li><a href="#11.5. Множества и наборы">11.5. Множества и наборы</a></li>
    <li><a href="#11.6. Строчные буферы">11.6. Строчные буферы</a></li>
    <li><a href="#11.7. Графы">11.7. Графы</a></li>
    <li><a href="#11. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 12. Файлы данных и персистентность">Глава 12. Файлы данных и персистентность</a></li>
    <ul>
    <li><a href="#12.1. Файлы с данными">12.1. Файлы с данными</a></li>
    <li><a href="#12.2. Сериализация">12.2. Сериализация</a></li>
      <ul>
      <li><a href="#12.2. Сохранение таблиц без циклов">Сохранение таблиц без циклов</a></li>
      <li><a href="#12.2. Сохранение таблиц с циклами">Сохранение таблиц с циклами</a></li>
      </ul>
    <li><a href="#12. Упражнения"></a></li>
    </ul>
  <li class="head"><a href="#Глава 13. Метатаблицы и метаметоды">Глава 13. Метатаблицы и метаметоды</a></li>
    <ul>
    <li><a href="#13.1. Арифметические метаметоды">13.1. Арифметические метаметоды</a></li>
    <li><a href="#13.2. Метаметоды сравнения">13.2. Метаметоды сравнения</a></li>
    <li><a href="#13.3. Библиотечные метаметоды">13.3. Библиотечные метаметоды</a></li>
    <li><a href="#13.4. Метаметоды для доступа к таблице">13.4. Метаметоды для доступа к таблице</a></li>
      <ul>
      <li><a href="#13.4. Метаметод __index">Метаметод <i>__index</i></a></li>
      <li><a href="#13.4. Метаметод __newindex">Метаметод <i>__newindex</i></a></li>
      <li><a href="#13.4. Таблицы со значениями по умолчанию">Таблицы со значениями по умолчанию</a></li>
      <li><a href="#13.4. Отслеживание доступа к таблице">Отслеживание доступа к таблице</a></li>
      <li><a href="#13.4. Таблицы, доступные только для чтения">Таблицы, доступные только для чтения</a></li>
      </ul>
    <li><a href="#13. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 14. Окружение">Глава 14. Окружение</a></li>
    <ul>
    <li><a href="#14.1. Глобальные переменные с динамическими именами">14.1. Глобальные переменные с динамическими именами</a></li>
    <li><a href="#14.2. Описания глобальных переменных">14.2. Описания глобальных переменных</a></li>
    <li><a href="#14.3. Неглобальные окружения">14.3. Неглобальные окружения</a></li>
    <li><a href="#14.4. Использование _ENV">14.4. Использование <i>_ENV</i></a></li>
    <li><a href="#14.5. _ENV и load">14.5. <i>_ENV</i> и <i>load</i></a></li>
    <li><a href="#14. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 15. Модули и пакеты">Глава 15. Модули и пакеты</a></li>
    <ul>
    <li><a href="#15.1. Функция require">15.1. Функция require</a></li>
      <ul>
      <li><a href="#15.1. Переименовывание модуля">Переименовывание модуля</a></li>
      <li><a href="#15.1. Поиск по пути">Поиск по пути</a></li>
      <li><a href="#15.1. Искатели файлов">Искатели файлов</a></li>
      </ul>
    <li><a href="#15.2. Стандартный подход для написания модулей на Lua">15.2. Стандартный подход для написания модулей на Lua</a></li>
    <li><a href="#15.3. Использование окружений">15.3. Использование окружений</a></li>
    <li><a href="#15.4. Подмодули и пакеты">15.4. Подмодули и пакеты</a></li>
    <li><a href="#15. Упражнения">Упражнения</li></a>
    </ul>
  <li class="head"><a href="#Глава 16. Обьектно-ориентированное программирование">Глава 16. Обьектно-ориентированное программирование</a></li>
    <ul>
    <li><a href="#16.1. Классы">16.1. Классы</a></li>
    <li><a href="#16.2. Наследование">16.2. Наследование</a></li>
    <li><a href="#16.3. Множественное наследование">16.3. Множественное наследование</a></li>
    <li><a href="#16.4. Скрытие">16.4. Скрытие</a></li>
    <li><a href="#16.5. Подход с единственным методом">16.5. Подход с единственным методом</a></li>
    <li><a href="#16. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 17. Слабые таблицы и финализаторы">Глава 17. Слабые таблицы и финализаторы</li></a>
    <ul>
    <li><a href="#17.1. Слабые таблицы">17.1. Слабые таблицы</a></li>
    <li><a href="#17.2. Функции с кэшированием">17.2. Функции с кэшированием</a></li>
    <li><a href="#17.3. Атрибуты обьекта">17.3. Атрибуты обьекта</a></li>
    <li><a href="#17.4. Опять таблицы со значениями по умолчанию">17.4. Опять таблицы со значениями по умолчанию</a></li>
    <li><a href="#17.5. Эфемерные таблицы">17.5. Эфемерные таблицы</a></li>
    <li><a href="#17.6. Финализаторы">17.6. Финализаторы</a></li>
    <li><a href="#17. Упражнения">Упражнения</a></li>
    </ul>
  <hr>
  <li class="head">ЧАСТЬ III. Стандартные библиотеки</li>
  <hr>
  <li class="head"><a href="#Глава 18. Математическая библиотека">Глава 18. Математическая библиотека</a></li>
    <ul>
    <li><a href="#18. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 19. Библиотека для побитовых операций">Глава 19. Библиотека для побитовых операций</a></li>
    <ul>
    <li><a href="#19. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 20. Библиотека для работы с таблицами">Глава 20. Библиотека для работы с таблицами</a></li>
    <ul>
    <li><a href="#20.1. Функции insert и remove">20.1. Функции <i>insert</i> и <i>remove</i></a></li>
    <li><a href="#20.2. Сортировка">20.2. Сортировка</a></li>
    <li><a href="#20.3. Конкатенация">20.3. Конкатенация</a></li>
    <li><a href="#20. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 21. Библиотека для работы со строками">Глава 21. Библиотека для работы со строками</a></li>
    <ul>
    <li><a href="#21.1. Основные функции для работы со строками">21.1. Основные функции для работы со строками</a></li>
    <li><a href="#21.2. Функции для работы с шаблонами">21.2. Функции для работы с шаблонами</a></li>
      <ul>
      <li><a href="#21.2. Функция string.find">Функция <i>string.find</i></a></li>
      <li><a href="#21.2. Функция string.match">Функция <i>string.match</i></a></li>
      <li><a href="#21.2. Функция string.gsub">Функция <i>string.gsub</i></a></li>
      <li><a href="#21.2. Функция string.gmatch">Функция <i>string.gmatch</i></a></li>
      </ul>
    <li><a href="#21.3. Шаблоны">21.3. Шаблоны</a></li>
    <li><a href="#21.4. Захваты">21.4. Захваты</a></li>
    <li><a href="#21.5. Замены">21.5. Замены</a></li>
      <ul>
      <li><a href="#21.5. Кодировка URL">Кодировка <i>URL</i></a></li>
      <li><a href="#21.5. Замена табов">Замена табов</a></li>
      </ul>
    <li><a href="#21.6. Хитрые приемы">21.6. Хитрые приемы</a></li>
    <li><a href="#21.7. Юникод">21.7. Юникод</a></li>
    <li><a href="#21. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 22. Библиотека ввода/вывода">Глава 22. Библиотека ввода/вывода</a></li>
    <ul>
    <li><a href="#22.1. Простая модель ввода/вывода">22.1. Простая модель ввода/вывода</a></li>
    <li><a href="#22.2. Полная модель ввода/вывода">22.2. Полная модель ввода/вывода</a></li>
      <ul>
      <li><a href="#22.2. Небольшой прием для увеличения быстродействия">Небольшой прием для увеличения быстродействия</a></li>
      <li><a href="#22.2. Бинарные файлы">Бинарные файлы</a></li>
      </ul>
    <li><a href="#22.3. Другие операции над файлами">22.3. Другие операции над файлами</a></li>
    <li><a href="#22. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 23. Библиотека функций операционной системы">Глава 23. Библиотека функций операционной системы</a></li>
    <ul>
    <li><a href="#23.1. Дата и время">23.1. Дата и время</a></li>
    <li><a href="#23.2. Другие вызовы системы">23.2. Другие вызовы системы</a></li>
    <li><a href="#23. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 24. Отладочная библиотека">Глава 24. Отладочная библиотека</a></li>
    <ul>
    <li><a href="#24.1. Возможности по доступу (интроспекции)">24.1. Возможности по доступу (<i>интроспекции</i>)</a></li>
      <ul>
      <li><a href="#24.1. Доступ к локальным переменным">Доступ к локальным переменным</a></li>
      <li><a href="#24.1. Доступ к нелокальным переменным">Доступ к нелокальным переменным</a></li>
      <li><a href="#24.1. Доступ к другим сопрограммам">Доступ к другим сопрограммам</a></li>
      </ul>
    <li><a href="#24.2. Ловушки(hooks)">24.2. Ловушки (<i>hooks</i>)</a></li>
    <li><a href="#24.3. Профилирование">24.3. Профилирование</a></li>
    <li><a href="#24. Упражнения">Упражнения</a></li>
    </ul>
  <!--<hr>
  <li class="head">ЧАСТЬ IV. С API</li>
  <hr>
  <li class="head"><a href="#Глава 25. Обзор С API">Глава 25. Обзор С API</a></li>
    <ul>
    <li><a href="#25.1. Первый пример">25.1. Первый пример</a></li>
    <li><a href="#25.2. Стек">25.2. Стек</a></li>
      <ul>
      <li><a href="#25.2. Помещение элементов на стек">Помещение элементов на стек</a></li>
      <li><a href="#25.2. Обращение к элементам">Обращение к элементам</a></li>
      <li><a href="#25.2. Другие операции со стеком">Другие операции со стеком</a></li>
      </ul>
    <li><a href="#25.3. Обработка ошибок в С API">25.3. Обработка ошибок в С API</a></li>
      <ul>
      <li><a href="#25.3. Обработка ошибок в коде приложения">Обработка ошибок в коде приложения</a></li>
      <li><a href="#25.3. Обработка ошибок в коде библиотек">Обработка ошибок в коде библиотек</a></li>
      </ul>
    <li><a href="#25. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head">Глава 26. Расширение вашего приложения</li>
    <ul>
    <li><a href="#26.1. Основы">26.1. Основы</a></li>
    <li><a href="#26.2. Работа с таблицами">26.2. Работа с таблицами</a></li>
    <li><a href="#26.3. Вызовы функций на Lua">26.3. Вызовы функций на Lua</a></li>
    <li><a href="#26.4. Обобщенный вызов функции">26.4. Обобщенный вызов функции</a></li>
    <li><a href="#26. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head">Глава 27. Вызываем С из Lua</li>
    <ul>
    <li><a href="#27.1. Функции на С">27.1. Функции на С</a></li>
    <li><a href="#27.2. Продолжения">27.2. Продолжения</a></li>
    <li><a href="#27.3. Модули на С">27.3. Модули на С</a></li>
    <li><a href="#27. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head">Глава 28. Приемы написания функций на С</li>
    <ul>
    <li><a href="#28.1. Работа с массивами">28.1. Работа с массивами</a></li>
    <li><a href="#28.2. Работа со строками">28.2. Работа со строками</a></li>
    <li><a href="#28.3. Сохранение состояния в функциях на С">28.3. Сохранение состояния в функциях на С</a></li>
      <ul>
      <li><a href="#28.3. Реестр">Реестр</a></li>
      <li><a href="#28.3. Значения, связанные с функцией">Значения, связанные с функцией</a></li>
      <li><a href="#28.3. Значения, связанные с функцией, используемые несколькими функциями">Значения, связанные с функцией, используемые несколькими функциями</a></li>
      </ul>
    <li><a href="#28. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head"><a href="#Глава 29. Задаваемые пользователем типы в С">Глава 29. Задаваемые пользователем типы в С</a></li>
    <ul>
    <li><a href="#29.1. Пользовательские данные (userdata)">29.1. Пользовательские данные (userdata)</a></li>
    <li><a href="#29.2. Метатаблицы">29.2. Метатаблицы</a></li>
    <li><a href="#29.3. Обьектно-ориентированный доступ">29.3. Обьектно-ориентированный доступ</a></li>
    <li><a href="#29.4. Доступ как к обычному массиву">29.4. Доступ как к обычному массиву</a></li>
    <li><a href="#29.5. Легкие обьекты типа userdata (light userdata)">29.5. Легкие обьекты типа userdata (light userdata)</a></li>
    <li><a href="#29. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head">Глава 30. Управление ресурсами</li>
    <ul>
    <li><a href="#30.1. Итератор по каталогу">30.1. Итератор по каталогу</a></li>
    <li><a href="#30.2. Парсер XML">30.2. Парсер XML</a></li>
    <li><a href="#30. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head">Глава 31. Нити и состояния</li>
    <ul>
    <li><a href="#31.1. Многочисленные нити">31.1. Многочисленные нити</a></li>
    <li><a href="#31.2. Состояния Lua">31.2. Состояния Lua</a></li>
    <li><a href="#31. Упражнения">Упражнения</a></li>
    </ul>
  <li class="head">Глава 32. Управление памятью</li>
    <ul>
    <li><a href="#32.1. Функция для выделения памяти">32.1. Функция для выделения памяти</a></li>
    <li><a href="#32.2. Сборщик мусора">32.2. Сборщик мусора</a></li>
      <ul>
      <li><a href="#32.2. API сборщика мусора">API сборщика мусора</a></li>
      </ul>
    <li><a href="#32. Упражнения">Упражнения</a></li>
    </ul>-->
</ul>

<!-- ================================================================================ -->
<div class="section">
  <a name="Введение"></a>ВВЕДЕНИЕ
</div>

<p>Когда Вальдемар, Луис и я начали разработку Lua в 1993 году, мы с трудом могли себе представить, что Lua так распространится. Начавшись как домашний язык для двух специфичных проектов, сейчас Lua широко используется во всех областях, которые могут получить выигрыш от простого, расширяемого, переносимого и эффективного скриптового языка, таких как встроенные системы, мобильные устройства и, конечно, игры.</p>

<p>Мы разработали Lua с самого начала для интегрирования с программным обеспечением, написанным на C/C++ и других распространенных языках. Эта интеграция несет с собой много преимуществ. Lua - это крошечный и простой язык, частично из-за того, что он не пытается делать то, в чем уже хорош С, например быстродействие, низкоуровневые операции и взаимодействие с программами третьих сторон. Для этих задач Lua полагается на С. Lua предлагает то, для чего С недостаточно хорош: достаточная удаленность от аппаратного обеспечения, динамические структуры, отсутствие избыточности и легкость тестирования и отладки. Для этих целей Lua располагает безопасным окружением, автоматическим управлением памятью и хорошими возможностями для работы со строками и другими типами данных с изменяемым размером.</p>

<p>Часть силы Lua идет от его библиотек. И это не случайно. В конце концов, одной из главных сил Lua является расширяемость. Многие особенности языка вносят в это свой вклад. Динамическая типизация предоставляет большую степень полиморфизма. Автоматическое управление памятью упрощает интерфейсы, поскольку нет необходимости решать, кто отвечает за выделение и освобождение памяти или как обрабатывать переполнения. Функции высших порядков и анонимные функции позволяют высокую степень параметризации, делая функции более универсальными.</p>

<p>В большей степени, чем расширяемым языком, Lua является «<i>склеивающим»</i> (<i>glue</i>) языком. Lua поддерживает компонентный подход к разработке программного обеспечения, когда мы создаем приложение, склеивая вместе существующие высокоуровневые компоненты. Эти компоненты написаны на компилируемом языке со статической типизацией, таком как C/C++; Lua является «клеем», который мы используем для компоновки и соединения этих компонентов. Обычно компоненты (или обьекты) представляют более конкретные низкоуровневые сущности (такие как виджеты и структуры данных), которые почти не меняются во время разработки программы и которые занимают основную часть времени выполнения итоговой программы. Lua придает итоговую форму приложению, которая, скорее всего, сильно меняется во время жизни данного программного продукта. Однако, в отличие от других «склеивающих» технологий, Lua является полноценным языком программирования. Поэтому мы можем использовать Lua не только для «склеивания» компонентов, но и для адаптации и настройки этих компонентов, а также для создания полностью новых компонентов.</p>

<p>Конечно, Lua не единственный скриптовый язык. Существуют другие языки, которые вы можете использовать примерно для тех же целей. Тем не менее Lua предоставляет целый набор возможностей, которые делают его лучшим выбором для многих задач и дает ему свой уникальный профиль:</p>

<ul>
  <li><b>Расширяемость</b>. Расширяемость Lua настолько велика, что многие рассматривают Lua не как язык, а как набор для построения DSL (<i>domain-specific language</i>, язык, созданный для определенной области, применения). Мы разрабатывали Lua с самого начала, чтобы он был расширяемым как через код па Lua, так и через код на С. Как доказательство Lua реализует большую часть своей базовой функциональности через внешние библиотеки. Взаимодействие с C/C++ действительно просто, и Lua был успешно интегрирован со многими другими языками, такими как <i>Fortran, Java, Smalltalk, Ada, C#</i>, и даже со скриптовыми языками, такими как <i>Perl</i> и <i>Python</i>.</li>
  </b><br>
  <li><b>Простота</b>. Lua - это простой и маленький язык. Он основан на небольшом числе понятий. Эта простота облегчает изучение. Lua вносит свой вклад в то, что его размер очень мал. Полный дистрибутив (исходный код, руководство, бинарные файлы для некоторых платформ) спокойно размещается на одном флоппи-диске.</li>
  </b><br>
  <li><b>Эффективность</b>. Lua обладает весьма эффективной реализацией. Независимые тесты показывают, что Lua - один из самых быстрых языков среди скриптовых языков.</li>
  </b><br>
  <li><b>Нормируемость</b>. Когда мы шпорим о портируемости, мы говорим о запуске Lua на всех платформах, о которых вы только слышали: нее версии <i>Unix</i> и <i>Windows, PlayStation, Xbox, Mac OS X 11 iOS, Android, Kindle Fire, NOOK, Haiku, QUALCOMM Brew</i>, большие серверы от <i>IBM, RISC OS, Symbian OS</i>, процессоры <i>Rabbit, Raspberry Pi, Arduino</i> и многое другое. Исходный код для каждой из этих платформ практически одинаков. Lua не использует условную компиляцию для адаптации своего кода под различные машины, вместо этого он придерживается стандартного ANSI (ISO) С. Таким образом, вам обычно не нужно адаптировать его под новую среду: если у вас есть компилятор с ANSI С, то вам просто нужно откомпилировать Lua.</li>
</ul>

<!-- ================================================================================ -->
<div class="section">
  <a name="Аудитория"></a>Аудитория
</div>

<p>Пользователи Lua обычно относятся к одной из трех широких групп: те, кто используют Lua, уже встроенный в приложение, те, кто используют Lua отдельно от какого-либо приложения (<i>standalone</i>), и те, кто используют Lua и С вместе.</p>

<p>Многие используют Lua, встроенный в какое-либо приложение, например в <i>Adobe Lightroom, Nmap</i> или <i>World of Warcraft</i>. Эти приложения используют Lua-C API для регистрации новых функций, создания новых типов и изменения поведения некоторых операций языка, конфигурируя Lua для своей области. Часто пользователи такого приложения даже не знают, что Lua - это независимый язык, адаптированный под данную область. Например, многие разработчики плагинов для <i>Lightroom</i> не знают о других использованиях этого языка; пользователи <i>Nmap</i> обычно рассматривают Lua как скриптовый язык <i>Nmap</i>; игроки в <i>World of Warcraft</i> могут рассматривать Lua как язык исключительно для данной игры.</p>

<p>Lua также полезен и как просто независимый язык, не только для обработки текста и одноразовых маленьких программ, но также и для различных проектов от среднего до большого размера. Для подобного использования основная функциональность Lua идет от ее библиотек. Стандартные библиотеки, например, предоставляют базовую функциональность по работе с шаблонами и другие функции для работы со строками. По мере того как Lua улучшает свою поддержку библиотек, появилось большое количество внешних пакетов. Lua Rocks, система для сборки и управления модулями для Lua, сейчас насчитывает более 150 пакетов.</p>

<p>Наконец, есть программисты, которые используют Lua как библиотеку для С. Такие люди больше пишут на С, чем на Lua, хотя им требуется хорошее понимание Lua для создания интерфейсов, которые являются простыми, легкими для использования и хорошо интегрированными с языком.</p>

<p>Эта книга может оказаться полезной всем этим людям. Первая часть покрывает сам язык, показывая, как можно использовать весь его потенциал. Мы фокусируемся на различных конструкциях языка и используем многочисленные примеры и упражнения, чтобы показать, как их использовать для практических задач. Некоторые главы этой части покрывают базовые понятия, такие как управляющие структуры, в то время как остальные главы покрывают более продвинутые темы, такие как итераторы и сопрограммы.</p>

<p>Вторая часть полностью посвящена таблицам, единственной структуре данных в Lua. Главы этой части обсуждают структуры данных, их сохранение (<i>persistence</i>), пакеты и обьектно-ориентированное программирование. Именно там мы покажем всю силу языка.</p>

<p>Третья часть представляет стандартные библиотеки. Эта часть особенно полезна для тех, кто использует Lua как самостоятельный язык, хотя многие приложения включают частично или полностью стандартные библиотеки. В этой части каждой библиотеке посвящена отдельная глава: математической библиотеке, побитовой библиотеке, библиотеке по работе с таблицами, библиотеке по работе со строками, библиотеке ввода/вывода, библиотеке операционной системы и отладочной библиотеке.</p>

<p>Наконец, последняя часть книги покрывает API между Lua и С. Эта часть заметно отличается от всей остальной книги. В этой части мы будем программировать на С, а не на Lua. Для кого-то эта часть может оказаться неинтересной, а для кого-то - наоборот, самой полезной частью книги.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="О третьем издании"></a>О третьем издании
</div>

<p>Эта книга является обновленной и расширенной версией второго издания «<i>Programming in Lua</i>» (также известной как PiL 2). Хотя структура книги практически та же самая, это издание включает в себя полностью новый материал.</p>

<p>Во-первых, я обновил всю книгу на Lua 5.2. Глава об окружениях (<i>environments</i>) была практически полностью переписана. Я также переписал несколько примеров для того, чтобы показать преимущества использования новых возможностей, предоставляемых Lua 5.2. Однако я четко обозначил отличия от Lua 5.1, поэтому вы можете использовать книгу для работы с этой версией языка.</p>

<p>Во-вторых, и более важно, я добавил упражнения во все главы книги. Сложность этих упражнений варьируется от простых вопросов до полноценных небольших проектов. Некоторые примеры иллюстрируют важные аспекты программирования на Lua и так же, как и примеры, расширят ваш набор полезных приемов.</p>

<p>Так же, как мы поступили с первым и вторым изданиями «<i>Programming in Lua</i>», мы сами опубликовали третье издание. Несмотря на маркетинговые ограничения, этот подход обладает рядом преимуществ: мы сохраняем полный контроль над содержимым книги; мы сохраняем все права для предложения книги в других формах; мы обладаем свободой для выбора, когда выпустить следующее издание; мы можем быть уверены, что книга всегда будет доступна.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="Другие ресурсы"></a>Другие ресурсы
</div>

<p>Краткое руководство необходимо всем, кто хочет освоить язык. Эта книга не заменяет краткое руководство. Напротив, они дополняют друг друга. Руководство только описывает Lua. Оно не показывает ни примеров, ни обьяснений для конструкций языка. С другой стороны, оно полностью описывает язык: эта книга опускает некоторые, редко используемые, «темные углы» Lua. Более того, руководство описывает язык. Там, где эта книга расходится с руководством, доверяйте руководству. Чтобы получить руководство и дополнительную информацию по Lua, посетите веб-сайт <a href="http://www.lua.org">http://www.lua.org</a></p>

<p>Вы также можете найти полезную информацию на сайте пользователей Lua, поддерживаемом сообществом пользователей Lua, <a href="http://lua-users.org">http://lua-users.org</a>. Помимо других ресурсов, он предлагает также обучающий курс (<i>tutorial</i>), список сторонних пакетов и документации, архив официальной рассылки по Lua.</p>

<p>Эта книга описывает Lua 5.2, хотя большая часть содержимого также применима к Lua 5.1 и Lua 5.0. Некоторые отличия Lua 5.2 от предыдущих версий Lua 5 четко обозначены в книге. Если вы используете более свежую версию (выпущенную после этой книги), обратитесь к руководству по поводу отличий между версиями. Если вы используете версию старее, чем 5.2, то, может, пора подумать о переходе на более новую версию.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="Некоторые типографские соглашения"></a>Некоторые типографские соглашения
</div>

<p>В этой книге строки символов <code>("literal string")</code> заключены в двойные кавычки, а одиночные символы, например <code>'а'</code>, заключены в одиночные кавычки. Строки, которые являются шаблонами, также заключены в одиночные кавычки, например <code>'[%w_]*'</code>. В книге моноширинный шрифт используется для фрагментов кода и идентификаторов. Для зарезервированных слов используется жирный шрифт. Большие фрагменты кода показаны с применением следующего стиля:</p>

<pre class="code">
<font color=008000>--&nbsp;program&nbsp;"Hello&nbsp;World"</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"Hello&nbsp;World"</font><font color=FF0000>)</font>&nbsp;<font color=008000>-->&nbsp;Hello&nbsp;World</font>
</pre>

<p>Обозначение <code>--&gt;</code> показывает результат выполнения оператора или результат выражения:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>)</font>&nbsp;<font color=008000>-->&nbsp;10</font>
<font color=AC00A9>13</font><font color=FF0000>+</font><font color=AC00A9>3</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;16</font>
</pre>

<p>Поскольку двойной знак минус <code>(--)</code> начинает комментарий в Lua, ничего не будет если вы включите такой результат вывода (вместе с <code>--&gt;</code>) в свою программу. Наконец, в книге используется обозначение <code>&lt;--&gt;</code> для обозначения того, что что-то эквивалентно чему-то другому:</p>

<pre class="code">this &lt;--&gt; that</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="Запуск примеров"></a>Запуск примеров
</div>

<p>Вам понадобится интерпретатор Lua для запуска примеров из этой книги. В идеале вам следует использовать Lua 5.2, однако большинство примеров без каких-либо изменений будет работать и на Lua 5.1.</p>

<p>Сайт Lua (<a href="http://www.lua.org">http://www.lua.org</a>) хранит весь исходный код для интерпретатора. Если у вас есть компилятор с С и знание того, как скомпилировать С код на вашем компьютере, то вам лучше попробовать поставить Lua из исходного кода; это действительно легко. Сайт <i>Lua Binaries</i> (поищите <i>luabinaries</i>) предлагает уже откомпилированные интерпретаторы для всех основных платформ. Если вы используете Linux или другую UNIX-подобную систему, вы можете проверить репозиторий вашего дистрибутива; многие дистрибутивы уже предлагают готовые пакеты с Lua. Для Windows хорошим выбором является <i>Lua for Windows</i> (поищите <i>luaforwindows</i>), являющийся удобным набором для работы с Lua.Он включает в себя интерпретатоp, интегрированный редактор и много библиотек.</p>

<p>Если вы используете Lua, встроенный и приложение, как <i>WoW</i> или <i>Nmap</i>, то нам может понадобиться руководство по данному приложению (или помощь «местного гуру»), для того чтобы разобраться, как запускать ваши программы. Тем не менее Lua остается все тем же языком; большинство примеров, которые мы рассмотрим в этой книге, применимы, несмотря на то, как вы используете Lua. Однако я рекомендую начать изучение Lua с интерпретатора для запуска ваших примеров.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="Благодарности"></a>Благодарности
</div>

<p>Прошло уже почти десять лет с тех пор, как я опубликовал первое издание этой книги. Многие друзья и различные организации помогли мне в этом пути.</p>

<p>Как всегда, <i>Луиг Хенрик де Фигуредо</i> и <i>Вальдемар Селес</i>, соавторы Lua, предлагали все варианты помощи. <i>Андре Карригал, Аско Кауппи, Бретт Капилик, Диего Мехаб, Эдвин Морагас, Фернандо Джефферсон, Гэвин Врес, Джон Д. Рамсделл</i> и <i>Норман Ремси</i> предложили неоценимые замечания и полезные взгляды для различных изданий этой книги.</p>

<p><i>Луиза Новаэс</i>, глава отдела искусства и дизайна в PUC-Rio, смогла найти время в своем занятом графике, чтобы создать идеальную обложку для данного издания.</p>

<p><i>Lightning Source, Inc</i>. предложило надежный и эффективный вариант для печати и распространения данной книги. Без них самим издать эту книгу не получилось бы.</p>

<p>Центр латино-американских исследований в <i>Стендфордском университете</i> предоставил мне крайне необходимый перерыв от регулярной работы в очень стимулирующем окружении, во время которого я и сделал большую часть работы над третьим изданием.</p>

<p>Я также хотел бы поблагодарить <i>Pontifical Catholic University</i> Рио де Жанейро (PUC-Rio) и Бразильский национальный исследовательский совет (<i>CNPq</i>) за их продолжающуюся поддержку моей работы.</p>

<p>Наконец, я должен выразить мою глубокую благодарность <i>Ноэми Родригес</i> за все виды помощи (технической, и не только) и за освещение моей жизни.</p>

<!-- ================================================================================ -->

<div class="part">ЧАСТЬ I. Язык</div>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 1. Начинаем"></a>Глава 1. Начинаем
</div>

<p>Продолжая традицию, наша первая программа на Lua просто печатает "Hello World":</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"Hello&nbsp;World"</font><font color=FF0000>)</font></pre>

<p>Если вы используете отдельный интерпретатор Lua, то все, что вам надо для запуска вашей первой программы, - это запустить интерпретатор - обычно он называется <code>lua</code> или <code>luа5.2</code> - с именем текстового файла, содержащего вашу программу. Если вы сохранили приведенную выше программу в файле <code>hello.lua</code>, то вам следует выполнить следующую команду:</p>

<pre class="code">% lua hello.lua</pre>

<p>Как более сложный пример наша следующая программа определяет функцию для вычисления факториала заданного числа, спрашивает у пользователя число и печатает его факториал:</p>

<pre class="code">
<font color=008000>--&nbsp;defines&nbsp;a&nbsp;factorial&nbsp;function</font>
<font color=0000DF>function</font>&nbsp;fact&nbsp;<font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>==</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;n&nbsp;<font color=FF0000>*</font>&nbsp;fact<font color=FF0000>(</font>n<font color=FF0000>-</font><font color=AC00A9>1</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"enter&nbsp;a&nbsp;number:"</font><font color=FF0000>)</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(</font><font color=8888CC>"*n"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;прочитать&nbsp;число</font>
<font color=0080C0>print</font><font color=FF0000>(</font>fact<font color=FF0000>(</font>a<font color=FF0000>))</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="1.1. Блоки"></a>1.1. Блоки
</div>

<p>Каждый кусок кода, который Lua выполняет, такой как файл или отдельная строка в интерактивном режиме, называется блоком (<i>chunk</i>). Блок - это просто последовательность команд (или операторов).</p>

<p>Lua не нужен разделитель между подряд идущими операторами, но вы можете использовать точку с запятой, если хотите. Я лично использую точку с запятой только для разделения операторов, записанных в одной строке. Разбиение на строки не играет никакой роли в синтаксисе Lua. Так, следующие четыре блока допустимы и эквивалентны:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>*</font><font color=AC00A9>2</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>;</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>*</font><font color=AC00A9>2</font><font color=FF0000>;</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>;</font>&nbsp;b&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>*</font><font color=AC00A9>2</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;b&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>*</font><font color=AC00A9>2</font>&nbsp;<font color=008000>--&nbsp;не&nbsp;красиво,&nbsp;но&nbsp;правильно</font>
</pre>

<p>Блок может состоять всего из одного оператора, как в примере <i>«Hello World»</i>, или состоять из набора операторов и определений функций (которые на самом деле являются просто присваиваниями, как мы увидим позже), как в примере с факториалом. Блок может быть так велик, как вы хотите. Поскольку Lua используется также как язык для описания данных, блоки в несколько мегабайт не являются редкостью. Интерпретатор Lua не имеет каких-либо проблем при работе с большими блоками.</p>

<p>Вместо того чтобы записывать ваши программы в файл, вы можете запустить интерпретатор в интерактивном режиме. Если вы запустите lua без аргументов , то вы увидите его приглашения для ввода:</p>

<pre class="code">
% lua
Lua 5.2 Copyright (C) 1994-2012 Lua.org, PUC-Rio
&gt;
</pre>

<p>Соответственно, каждая команда, которую вы вводите (как, например, <code>print "Hello World"</code>), выполняется немедленно, после того как вы ее введете. Для выходя из интерпретатора, просто наберите символ конца файла (<i>ctrl-D</i> в UNI, <i>ctrl-Z</i> в Windows) или позовите функцию <code>exit</code> из библиотеки операционной системы - вам нужно набрать <code>os.exit()</code>.</p>

<p>В интерактивном режиме Lua обычно интерпретирует каждую строку, которую вы вводите, как отдельный блок. Однако если он обнаруживает, что строка не является законченным блоком, то он ждет продолжения ввода до тех пор, пока не получится законченный блок. Таким образом вы можете вводить многострочные определения, такие как функция <code>factiorial</code>, прямо в интерактивном режиме. Однако обычно более удобным является помещать подобные определения в файл и затем вызывать Lua для выполнения этого файла.</p>

Вы можете использовать опцию <code>-i</code> для того, чтобы заставить Lua перейти в интерактивный режим после выполнения заданного блока:

<pre class="code">% lua -i prog</pre>

<p>Команда вроде этой выполнит блок в файле <code>prog</code> и затем перейдет в интерактивный режим. Это особенно полезно для отладки и ручного тестирования. В конце данной главы мы рассмотрим другие опции командной строки для интерпретатора Lua.</p>

<p>Другим способом запускать блоки является функция <code>dofile</code>, которая немедленно выполняет файл. Например, допустим, что у вас есть файл <code>libl.lua</code> со следующим кодом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;norm&nbsp;<font color=FF0000>(</font>x<font color=FF0000>,</font>&nbsp;y<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>^</font><font color=AC00A9>2</font>&nbsp;<font color=FF0000>+</font>&nbsp;y<font color=FF0000>^</font><font color=AC00A9>2</font><font color=FF0000>)^</font><font color=AC00A9>0.5</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;twice&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>*</font>x
<font color=0000DF>end</font>
</pre>

<p>Тогда в интерактивном режиме вы можете набрать</p>

<pre class="code">
<font color=0080C0>dofile</font>&nbsp;<font color=FF0000>(</font><font color=9999CC>"libl.lua"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;load&nbsp;your&nbsp;library</font>
n&nbsp;<font color=FF0000>=</font>&nbsp;norm<font color=FF0000>(</font><font color=AC00A9>3.4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1.0</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>twice<font color=FF0000>(</font>n<font color=FF0000>))</font>&nbsp;<font color=008000>-->&nbsp;7.0880180586677</font>
</pre>

<p>Функция <code>dofile</code> также полезна, когда вы тестируете фрагмент кода. Вы можете работать с двумя окнами: в одном находится текстовый редактор с вашей программой (например, в файле <code>prog.lua</code>), и в другом находится консоль с запущенным интерпретатором Lua в интерактивном режиме. После того как вы сохранили изменения в вашей программе, вы выполняете <code>dofile("prog, lua")</code> в консоли для загрузки нового кода; затем вы можете начать использование нового кода, вызывая функции и печатая результаты.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="1.2. Некоторые лексические соглашения"></a>1.2. Некоторые лексические соглашения
</div>

<p><i>Идентификаторы</i> (или имена) в Lua являются строками из латинских букв, цифр и знака подчеркивания, не начинающимися с цифры; например:</p>

<pre class="code">
i      j      i10      _ij
aSomewhatLongName   _INPUT
</pre>

<p>Вам лучше избегать идентификаторов, состоящих из подчеркивания, за которым следуют заглавные латинские буквы (например, <code>_VERSION</code>); они зарезервированы для специальных целей в Lua. Обычно я использую идентификатор <code>_</code> (одиночное подчеркивание) для пустых (<i>dummy</i>) переменных.</p>

<p>В старых версиях Lua понятие того, что является буквой, зависело от локали. Однако подобные буквы делают вашу программу неподходящей для запуска на системах, которые не поддерживают данную локаль. Поэтому Lua 5.2 рассматривает в качестве букв только буквы из следующих диапазонов: <code>A-Z</code> и <code>a-z</code>.</p>

<p>Следующие слова зарезервированы, вы не можете использовать их в качестве идентификаторов:</p>

<font color=0000DF>
<pre class="code">
and     break     do        else    elseif
end     false     goto      for     function
if      in        local     nil     not
or      repeat    return    then    true
until   while
</pre></font>

<p>Lua учитывает регистр букв: <code>and</code> - это зарезервированное слово, однако <code>And</code> и <code>and</code> - это два разных идентификатора.</p>

<p>Комментарий начинается с двух знаков минуса (<code>--</code>) и продолжается до конца строки. Lua также поддерживает блочный комментарий, который начинается с <code>--[[</code> и идет до следующего <code>]]</code> (Блочные комментарии могут быть более сложными, как мы увидим в разделе 2.4.). Стандартный способ закомментировать фрагмент кода - это поместить его между <code>--[[</code> и  <code>--]]</code>, как показано ниже:</p>

<pre class="code">
<font color=008000>--[[</font>
<font color=008000>print&nbsp;(10)&nbsp;--&nbsp;действия&nbsp;нет&nbsp;(закомментировано)</font>
<font color=008000>--]]</font>
</pre>

<p>Для того чтобы снова сделать этот код активным, просто добавьте один минус к первой строке:</p>

<pre class="code">
<font color=008000>---[[</font>
<font color=0080C0>print</font>&nbsp;<font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;10</font>
<font color=008000>--]]</font>
</pre>

<p>В первом примере <code>--[[</code> в первой строке начинает блочный комментарий, и двойной минус в последней строке также находится в этом комментарии. Во втором примере <code>---[</code> начинает начинает обычный однострочный комментарий, поэтому первая и последняя строки становятся обычными независимыми комментариями. В этом случае <code>print</code> находится вне комментариев.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="1.3. Глобальные переменные"></a>1.3. Глобальные переменные
</div>

<p>Глобальным переменным не нужны описания; вы их просто используете. Не является ошибкой обратиться к неинициализированной переменной, вы просто получите значение <b>nil</b> в качестве результата:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>b<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>
<font color=0080C0>print</font><font color=FF0000>(</font>b<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;10</font>
</pre>

<p>Если вы присвоите <code>nil</code> глобальной переменной, то Lua поведет себя, как будто эта переменная никогда не была использована:</p>

<pre class="code">
b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0080C0>print</font><font color=FF0000>(</font>b<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
</pre>

<p>После этого присваивания Lua может со временем вернуть себе память, занимаемую данной переменной.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="1.4. Отдельный интерпретатор"></a>1.4. Отдельный интерпретатор
</div>

<p>Отдельный (<i>stand-alone</i>) интерпретатор (также называемый <code>lua.с</code> в связи с названием его исходного файла или просто <code>lua</code> по имени выполнимого файла) - это небольшая программа, которая позволяет непосредственное использование Lua. В этой секции представлены ее основные опции.</p>

<p>Когда интерпретатор загружает файл, то он пропускает первую строку, если она начинается с символа '<code>#</code>'. Это позволяет использовать Lua как скриптовый интерпретатор в UNIX-системах. Если вы начнете ваш скрипт с чего-нибудь вроде</p>

<pre class="code">#!/usr/local/bin/lua</pre>

<p>(предполагая, что интерпретатор находится в <code>/usr/local/bin</code>) или</p>

<pre class="code">#!/usr/bin/env lua,</pre>

<p>то вы можете непосредственно запускать ваш скрипт без явного запуска интерпретатора Lua.</b><br>
Интерпретатор вызывается следующим образом:</p>

<pre class="code">lua [options] [script [args]]</pre>

<p>Все параметры необязательны. Как мы уже видели, когда мы запускаем <code>lua</code> без аргументов, то он переходит в интерактивный режим.</b><br>
Опция <code>-е</code> позволяет непосредственно задать код прямо в командной строке, как показано ниже:</p>

<pre class="code">% lua -е "print (math.sin(12))" --&gt; -0.53657291800043</pre>

<p>(UNIX требует двойных кавычек, чтобы командный интерпретатор (<i>shell</i>) не разбирал скобки).</b><br>
Опция <code>-l</code> загружает библиотеку. Как мы уже видели ранее, <code>-i</code> переводит интерпретатор в интерактивный режим после обработки остальных аргументов. Таким образом, следующий вызов загрузит библиотеку <code>lib</code>, затем выполнит присваивание <code>х=10</code> и наконец перейдет в интерактивный режим.</p>

<pre class="code">% lua -i -llib -е "х = 10"</pre>

<p>В интерактивном режиме вы можете напечатать значение выражения, просто набрав строку, начинающуюся со знака равенства, за которым следует выражение:</p>

<pre class="code">
&gt;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.sin</font><font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;0.14112000805987</font>
&gt;&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>30</font>
&gt;&nbsp;<font color=FF0000>=</font>&nbsp;a&nbsp;<font color=008000>--&gt;&nbsp;30</font>
</pre>

<p>Эта особенность позволяет использовать Lua как калькулятор.
</b><br>
Перед выполнением своих аргументов интерпретатор ищет переменную окружения с именем <code>LUA_INIT_5_2</code> или, если такой переменной нет, <code>LUA_INIT</code>. Если одна из этих переменных присутствует и ее значение имеет вид <i>@имяфайла</i>, то интерпретатор запускает данный файл. Если <code>LUA_INIT_5_2</code> (или <code>LUA_INIT</code>) определена, но не начинается с символа '<code>@</code>', то интерпретатор предполагает, что она содержит выполнимый код на Lua и выполняет его. <code>LUA_INIT</code> дает огромные возможности по конфигурированию интерпретатора, поскольку при конфигурировании нам доступна вся мощь Lua. Мы можем загрузить пакеты, изменить текущий путь, определить свои собственные функции, переименовать или уничтожить функции и т. п.
</b><br>
Скрипт может получить свои аргументы в глобальной переменной <code>arg</code>. Если у нас есть вызов вида <code>%lua script a b c</code>, то интерпретатор создает таблицу <code>arg</code> со всеми аргументами командной строки перед выполнением скрипта. Имя скрипта расположено по индексу <code>0</code>, первый аргумент (и примере этоо "<code>a</code>") расположен по индексу 1 и т.д. Предшестнующие опции расположены по негативным индексам, поскольку они расположены перед именем скрипта. Например, рассмотрим следующий вызов:</p>

<pre class="code">% lua -e "sin=math.sin" script a b</pre>

Интерпретатор собирает аргументы следующим образом:

<pre class="code">
arg<font color=FF0000>[-</font><font color=AC00A9>3</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"lua"</font>
arg<font color=FF0000>[-</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"-e"</font>
arg<font color=FF0000>[-</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"sin=math.sin"</font>
arg<font color=FF0000>[</font><font color=AC00A9>0</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"script"</font>
arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a"</font>
arg<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"b"</font>
</pre>

<p>Чаще всего скрипт использует только положительные индексы (в примере это <code>arg[1]</code> и <code>arg[2]</code>).
</b><br>
Начиная с Lua 5.1 скрипт также может получить свои аргументы при помощи выражения <code>...</code> (три точки). В главной части скрипта это выражение дает все аргументы скрипта (мы обсудим подобные выражения в разделе 5.2).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="1. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 1.1.</b><br>
Запустите пример с факториалом. Что случится с вашей программой, если вы введете отрицательное число? Измените пример, чтобы избежать этой проблемы.

<hr color=99CCFF>

<p><b>Упражнение 1.2.</b><br>
Запустите пример twice, один раз загружая файл при помощи опции <code>-l</code>, а другой раз через <code>dofile</code>. Что быстрее?</p>

<hr color=99CCFF>

<p><b>Упражнение 1.3.</b><br>
Можете ли вы назвать другой язык, использующий (<code>--</code>) для комментариев?</p>

<hr color=99CCFF>

<p><b>Упражнение 1.4.</b><br>
Какие из следующих строк являются допустимыми идентификаторами?</p>

<pre class="code">_end End end until? nil NULL</pre>

<hr color=99CCFF>

<p><b>Упражнение 1.5.</b><br>
Напишите простой скрипт, который печатает свое имя, не зная его заранее.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 2. Типы и значения"></a>Глава 2. Типы и значения
</div>

<p>Lua - язык с динамической типизацией. В языке нет определений типов, каждое значение несет свой собственный тип.</p>

<p>В Lua существует восемь базовых типов: <code>nil, boolean, number, string, userdata, function, thread</code> и <code>table</code>. Функция type возвращает тип для любого переданного значения:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font><font color=8888CC>"Hello&nbsp;world"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;string</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font><font color=AC00A9>10.4</font><font color=FF0000>*</font><font color=AC00A9>3</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;number</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font><font color=0080C0>print</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;function</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;function</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font><font color=0000DF>true</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;boolean</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font><font color=0000DF>nil</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font>X<font color=FF0000>)))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;string</font>
</pre>

<p>Последняя строка всегда вернет <code>string</code> вне зависимости от значения <code>х</code>, поскольку результат функции <code>type</code> всегда является строкой.</p>

<p>У переменных нет предопределенных типов, любая переменная может содержать значения любого типа:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font>a<font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;nil&nbsp;(*а'&nbsp;еще&nbsp;не&nbsp;определена)</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font>a<font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;number</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a&nbsp;string!!"</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font>a<font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;string</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>print</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;дa,&nbsp;это&nbsp;возможно!</font>
a<font color=FF0000>(</font><font color=0080C0>type</font><font color=FF0000>(</font>a<font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;function</font>
</pre>

<p>Обратите внимание на последние две строки: функции являются значения первого класса в Lua; ими можно манипулировать, как и любыми другими значениями. (Больше об этом будет рассказано в <a href="#Глава 6. Ещё о функциях">Главе 6</a>.)</p>

<p>Обычно когда вы используете одну и ту же переменную для значений разных типов, вы получаете отвратительный код. Однако иногда разумное использование этой возможности оказывается полезным, например использование <code>nil</code> для того, чтобы отличать нормальное возвращаемое значение от какой-либо ошибки.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.1. Nil"></a>2.1. Nil
</div>

<p><code>Nil</code> - это тип, состоящий из всего одного значения, <code>nil</code>, основной задачей которого является отличаться от всех остальных значений. Lua использует <code>nil</code> для обозначения отсутствующего значения. Как мы уже видели, глобальные переменные по умолчанию имеют значение <code>nil</code> до своего первого присваивания, вы также можете присвоить <code>nil</code> глобальной переменной, чтобы удалить ее.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.2. Boolean (логические значения)"></a>2.2. Boolean (логические значения)
</div>

<p>Тип <code>boolean</code> имеет два значения, <code>true</code> и <code>false</code>, которые служат для представления традиционных логических значений. Однако эти значения не монополизируют все условные значения: в Lua любое значение может представлять условие (<i>condition</i>). Соответствующие проверки (проверки условия в различных управляющих структурах) трактуют оба значения <code>nil</code> и <code>false</code> как ложные и все остальные значения как истинные. В частности, Lua трактует ноль и пустую строку как истину в логических условиях.</p>

<p>Во всей книге под ложным значением будет подразумеваться <code>nil</code> и <code>false</code>. В случае когда речь идет именно о булевых значениях, будет явно использовано значение <code>false</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.3. Числа"></a>2.3. Числа
</div>

<p>Тип <code>number</code> представляет значения с плавающей точкой, заданные с двойной точностью. В Lua нет встроенного целочисленного типа.</p>

<p>Некоторые опасаются, что даже такие простые операции, как увеличение на единицу (<i>инкремент</i>) и сравнение, могут некорректно работать с числами с плавающей точкой. Однако на самом деле это не так. Практически все платформы сейчас поддерживают стандарт IEEE 754 для представления чисел с плавающей точкой. Согласно этому стандарту, единственным возможным источником ошибок является случай, когда число не может быть точно представлено. Операция округляет свой результат, только если результат не может быть точно представлен в виде соответствующего значения с плавающей точкой. Любая операция, результат которой может быть точно представлен, будет иметь точное значение.</p>

<p>Ha самом деле любое целое число вплоть до <code>2^53</code> (приблизительно <code>10^16</code>) имеет точное представление в виде числа с плавающей точкой с двойной точностью (<i>double</i>). Когда вы используете значение с плавающей точкой с двойной точностью для представления целых чисел, нет никаких ошибок округления, за исключением случая, когда значение по модулю превосходит <code>2^53</code>. В частности, Lua способен представлять любые 32-битовые целые значения без проблем с округлениями.</p>

<p>Конечно, дробные числа будут иметь проблемы с округлением. Эта ситуация не отличается от случая, когда у вас есть бумага и ручка. Если мы хотим записать <code>1/7</code> в десятичном виде, то мы где-то должны остановиться. Если мы используем десять цифр для представления числа, то <code>1/7</code> станет <code>0.142857142</code>. Если мы вычислим <code>1/7*7</code> с десятью цифрами, то мы получим <code>0.999999994</code>, что отличается от <code>1</code>. Более того, числа, которые имеют конечное представление в виде десятичных дробей, могут иметь бесконечное представление в виде двоичных дробей. Так, <code>12.7-20+7.3</code> не равно нулю, поскольку оба числа <code>12.7</code> и <code>7.3</code> не имеют точного двоичного представления (см. <a href="#упражнение 2.3">упражнение 2.3</a>).</p>

<p>Прежде чем мы продолжим, запомните, целые числа имеют точное представление и поэтому не имеют ошибок с округлением.</p>

<p>Большинство современных CPU выполняет операции с плавающей точкой так же быстро (или даже быстрее), чем с целыми числами. Тем не менее легко скомпилировать Lua так, чтобы для числовых значений использовался другой тип, например длинные целочисленные значения или числа с плавающей точкой с одинарной точностью. Это особенно полезно для платформ без аппаратной поддержки чисел с плавающей точкой, таких как, например, встроенные системы. За деталями обратитесь к файлу <code>luaconf.h</code> в исходных файлах Lua.</p>

Мы можем записывать числа, при необходимости указывая дробную часть и десятичную степень. Примерами допустимых числовых констант являются:

<font color=#AC00A9>
<pre class="code">4    0.4    4.57е-3    0.3е12    5Е+20</pre>
</font>

<p>Более того, мы можем также использовать шестнадцатеричные константы, начиная их с <code>0х</code>. Начиная с Lua 5.2 шестнадцатеричные константы также могут иметь дробную часть и двоичную степень (перед степенью ставится или '<code>p</code>' или '<code>P</code>'), как в следующих примерах:</p>

<pre class="code">0xff (255)    0х1АЗ (419)    0x0.2 (0.125)    0х1р-1 (0.5)    Оха.Ьр2 (42.75)</pre>

<p>(Для каждой константы мы добавили ее десятичное представление.)</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.4. Строки"></a>2.4. Строки
</div>

<p>Строки в Lua имеют обычное значение: последовательность символов. Lua поддерживает все 8-битовые символы, и строки могут содержать символы с любыми кодами, включая нули. Это значит, что вы можете хранить любые бинарные данные в виде строк. Вы также можете хранить юникодные строки в любом представлении (<i>UTF-8, UTF-16</i> и т. д.). Стандартная библиотека, которая идет вместе с Lua, не содержит встроенной поддержки для этих представлений. Тем не менее вы вполне можете работать с UTF-8 строками, что мы рассмотрим в <a href="#21.7. Юникод">разделе 21.7</a>.</p>

<p>Строки в Lua являются неизменяемыми значениями. Вы не можете поменять символ внутри строки, как вы это можете в С. Вместо этого вы создаете новую строку с желаемыми изменениями, как показано в следующем примере:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"one&nbsp;string"</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;<font color=8888CC>"one"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"another"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;изменим&nbsp;чaсть&nbsp;строки</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;one&nbsp;string</font>
<font color=0080C0>print</font><font color=FF0000>(</font>b<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;another&nbsp;string</font>
</pre>

<p>Строки в Lua подвержены автоматическому управлению памятью, так же как и другие обьекты Lua (таблицы, функции и т. д.). Это значит, что вам не надо беспокоиться о выделении и освобождении строк, этим за вас займется Lua. Строка может состоять из одного символа или целой книги. Программы, работающие со строками в 100К или 10М символов, - не редкость в Lua.</p>

<p>Вы можете получить длину строки, используя в качестве префикса оператор '<code>#</code>' (называемый <i>оператором длины</i>):</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"hello"</font>
<font color=0080C0>print</font><font color=FF0000>(#</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;5</font>
<font color=0080C0>print</font><font color=FF0000>(#</font><font color=8888CC>"good\0bye"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;8</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.4. Литералы"></a>2.4. Литералы
</div>

<p>Мы можем помещать строки внутри одиночных или двойных кавычек:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a&nbsp;line"</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>'another&nbsp;line'</font>
</pre>

<p>Эти виды записи эквивалентыю Единственным отличием является то, что внутри строки, ограниченной одним типов кавычек, вы можете непосредственно вставлять кавычки другого типа.</p>

<p>Обычно большинство программистов использует кавычки одного типа для одного и того же типа строк. Например, библиотека, которая работает с XML, может использовать одиночные кавычки для строк, содержащих фрагменты XML, поскольку эти фрагменты часто содержат двойные кавычки.</p>

<p>Строки в Lua могут содержать следующие <i>еsсаре</i>-последовательности:</p>

<table>
  <tr>
    <td width="10%"><code>\a</code></td>
    <td><i>звонок (bell</i>)</td>
  </tr>
  <tr>
    <td width="10%"><code>\b</code></td>
    <td><i>back space</i></td>
  </tr>
  <tr>
    <td width="10%"><code>\f</code></td>
    <td><i>перевод страницы (form feed)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>\n</code></td>
    <td><i>новая строка (newline)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>\r</code></td>
    <td><i>возврат каретки (carriage return)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>\t</code></td>
    <td><i>таб (horizontal tab)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>\v</code></td>
    <td><i>вертикальный таб (vertical tab)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>\\</code></td>
    <td><i>backslash</i></td>
  </tr>
  <tr>
    <td width="10%"><code>\"</code></td>
    <td><i>двойная кавычка (double quote)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>\'</code></td>
    <td><i>одинарная кавычка (single quote)</i></td>
  </tr>
</table>

<p>Следующий пример иллюстрирует их использование:</p>

<pre class="code">
<font color=0080C0>print</font>&nbsp;<font color=FF0000>(</font><font color=8888CC>"one&nbsp;line\nnext&nbsp;line\n\"in&nbsp;quotes\",&nbsp;'in&nbsp;quotes'"</font><font color=FF0000>)</font>
<font color=008000>--&nbsp;one&nbsp;line</font>
<font color=008000>--&nbsp;next&nbsp;line</font>
<font color=008000>--&nbsp;"in&nbsp;quotes",&nbsp;'in&nbsp;quotes'</font>
<font color=0080C0>print</font>&nbsp;<font color=FF0000>(</font><font color=8888CC>'a&nbsp;backslash&nbsp;inside&nbsp;quotes:&nbsp;\'\\\''</font><font color=FF0000>)</font>
<font color=008000>--&nbsp;a&nbsp;backslash&nbsp;inside&nbsp;quotes:&nbsp;'\'</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"a&nbsp;simpler&nbsp;way:&nbsp;'\\'"</font><font color=FF0000>)</font>
<font color=008000>--&nbsp;a&nbsp;simpler&nbsp;way:&nbsp;'\'</font>
</pre>

<p>Мы можем задать символ в строке при помощи его числового значения, используя конструкции вида <code>\ddd</code> и <code>\x\hh</code>, где <code>ddd</code> - это последовательность не более чем из трех десятичных цифр, a <code>hh</code> - последовательность ровно из двух шестнадцатеричных цифр. В качестве сложного примера две строки <code>"alo\nl23\""</code> и <code>'\971o\10\04923'"</code> обладают одним и тем же значением в системе, использующей ASCII: <code>97</code> - это ASCII-код для '<code>а</code>', <code>10</code> - это код для символа перевода строки, и <code>49</code> - это код для цифры '<code>1</code>' (в этом примере мы должны записать значение <code>49</code> при помощи трех десятичных цифр <code>\049</code>, поскольку за ним следует другая цифра; иначе Lua трактовал это как код <code>492</code>). Мы можем также записать ту же самую строку как <code>'\x61\x6c\x6f\x0a\х31\х32\х33\х22'</code>, представляя каждый символ его шестнадцатеричным значением.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.4. Длинные строки"></a>2.4. Длинные строки
</div>

<p>Мы можем ограничивать символьные строки при помощи двойных квадратых скобок, как мы делали это с комментариями. Строка в этой форме может занимать много строк, и управляющие последовательности в этих строках не будут интерпретироваться. Более того, эта форма игнорирует первый символ строки, если это символ перехода на следующую строку. Эта форма особенно удобна для написания строк, содержащих большие фрагменты кода, как показано ниже:</p>

<pre class="code">
page&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>[[</font>
<font color=8888CC>&lt;html&gt;</font>
<font color=8888CC>&lt;head&gt;</font>
<font color=8888CC>&nbsp;&nbsp;&lt;title&gt;An&nbsp;HTML&nbsp;Page&lt;/title&gt;</font>
<font color=8888CC>&lt;/head&gt;</font>
<font color=8888CC>&lt;body&gt;</font>
<font color=8888CC>&nbsp;&nbsp;&lt;a&nbsp;href="http://www.lua.org"&gt;Lua&lt;/a&gt;</font>
<font color=8888CC>&lt;/body&gt;</font>
<font color=8888CC>&lt;/html&gt;</font>
<font color=8888CC>]]</font>
write<font color=FF0000>(</font>page<font color=FF0000>)</font>
</pre>

<p>Иногда вы можете захотеть поместить в строку что-то вроде <code>a=b[с[i]]</code> (обратите внимание на <code>]]</code> в этом коде) или вы можете захотеть поместить в строку часть кода, где какой-то фрагмент уже закомментарен. Для работы с подобными случаями вы можете поместить любое количество знаков равенства между двумя открывающими квадратными скобками, например <code>[===[</code>. После этого строка завершится только на паре закрывающих квадратных скобок с тем же самым количеством знаков равенства (<code>]===]</code> для нашего примера). Сканер будет игнорировать пары скобок с другим количеством знаков равенства. Путем выбора подходящего количества знаков равенства вы можете заключить в строку любой фрагмент.</p>

<p>То же самое верно и для комментариев. Например, если вы начинаете длинный комментарий с <code>--[=[</code>, то он будет продолжаться вплоть до <code>]=]</code>. Эта возможность позволяет закомментировать любой фрагмент кода, содержащий уже закомментированные фрагменты.</p>

<p>Длинные строки очень удобны для включения текста в ваш код, но вам не следует использовать их для нетекстовых строк. Хотя строки в Lua могут содержать любые символы, это не очень хорошая идея -использовать эти символы в своем коде: вы можете столкнуться с проблемами с вашим текстовым редактором; более того, строки вида <code>"\r\n"</code> могут превратиться в <code>"\n"</code>. Поэтому для представления произвольных бинарных данных лучше использовать управляющие последовательности, начинающиеся с символа такие как <code>"\х13\х01\хA1\хBB"</code>.Однако это представляет проблему для длинных строк из-за получающейся длины.</p>

<p>Для подобных ситуаций Lua 5.2 предлагает управляющую последовательность <code>\z</code>: она пропускает все символы в строке до первого непробельного символа. Следующий пример иллюстрирует его использование:</p>

<pre class="code">
data&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"\x00\x01\x02\x03\x04\x05\x06\x07\z</font>
<font color=8888CC>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"</font>
</pre>

<p>Находящийся в конце первой строки <code>\z</code> пропускает последующий конец строки и индентацию следующей строки так, что за байтом <code>\х07</code> сразу же следует байт <code>\х08</code> в получающейся строке.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.4. Приведения типов"></a>2.4. Приведения типов
</div>

<p>Lua предоставляет автоматическое преобразование значений между строками и числами на этапе выполнения. Любая числовая операция, примененная к строке, пытается преобразовать строку в число:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"10"</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;11</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"10&nbsp;+&nbsp;1"</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;10&nbsp;+&nbsp;1</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"-5.3e-10"</font><font color=FF0000>*</font><font color=8888CC>"2"</font><font color=FF0000>)</font>&nbsp;<font color=008000>-->&nbsp;-1.06e-09</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"hello"</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;ERROR&nbsp;(cannot&nbsp;convert&nbsp;"hello")</font>
</pre>

<p>Lua применяет подобные преобразования не только в арифметических операторах, но также и в других местах, где ожидается число, например для аргумента <code>math.sin</code>.</p>

<p>Аналогично, когда Lua ожидает получить строку, а получает число, он преобразует число в строку:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>10</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>)</font>&nbsp;<font color=008000>-->&nbsp;1020</font></pre>

<p>(Оператор <code>..</code> служит в Lua для конкатенации строк. Когда вы его записываете сразу после числа, то вы должны отделить их друг от друга при помощи пробела; иначе Lua решит, что первая точка - это десятичная точка числа.)</p>

<p>Сегодня мы не уверены, что эти автоматические преобразования типов были хорошей идеей в дизайне Lua. Как правило, лучше на них не рассчитывать. Они удобны в некоторых местах; но добавляют сложности как языку, так и программам, которые их используют.</p>

<p>В конце концов, строки и числа - это разные типы, несмотря на все эти преобразования. Сравнение вроде <code>10="10"</code> дает ложное значение, поскольку <code>10</code> - это число, а <code>"10"</code> - это строка.</p>

<p>Если вам нужно явно преобразовать строку в число, то вы можете использовать функцию <code>tonumber</code>, которая возвращает <b>nil</b>, если строка не содержит число:</p>

<pre class="code">
line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;прочесть&nbsp;строку</font>
n&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>tonumber</font><font color=FF0000>(</font>line<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;попробовать&nbsp;перевести&nbsp;ее&nbsp;в&nbsp;число</font>
<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font>line&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;is&nbsp;not&nbsp;a&nbsp;valid&nbsp;number"</font><font color=FF0000>)</font>
<font color=0000DF>else</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>n<font color=FF0000>*</font><font color=AC00A9>2</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Для преобразования числа в строку вы можете использовать функцию <code>tostring</code> или конкатенировать число с пустой строкой:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>tostring</font><font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"10"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>10</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>""</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"10"</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
</pre>

<p>Эти преобразования всегда работают.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.5. Таблицы"></a>2.5. Таблицы
</div>

<p>Тип таблицы соответствует ассоциативному массиву. <i>Ассоциативный массив</i> - это массив, который можно индексировать не только числами, но и строками или любым другим значением из языка, кроме <b>nil</b>.</p>
<p>
Таблицы являются главным (на самом деле единственным) механизмом структурирования данных в Lua, притом очень мощным. Мы используем таблицы для представления обычных массивов, множеств, записей и других структур данных простым, однородным и эффективным способом. Также Lua использует таблицы для представления пакетов и обьектов. Когда мы пишем <code>io.read</code>, мы думаем о «функции <code>read</code> из модуля <code>io</code>». Для Lua это выражение означает «возьми из таблицы <code>io</code> значение по ключу <code>read</code>».</p>

<p>Таблицы в Lua не являются ни значениями, ни переменными - они обьекты. Если вы знакомы с массивами в <i>Java</i> или <i>Scheme</i>, то вы понимаете, что я имею в виду. Вы можете рассматривать таблицу как динамически выделяемый обьект. Ваша программа работает только со ссылкой (<i>указателем</i>) на него. Lua никогда не прибегает к скрытому копированию или созданию новых таблиц. Более того, вам даже не нужно обьявлять таблицу в Lua. На самом деле даже нет способа обьявить таблицу. Вы создаете таблицы при помощи специального выражения, которое в простейшем случае выглядит как <code>{}</code> :</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создать&nbsp;таблицу&nbsp;и&nbsp;запомнить&nbsp;ссылку&nbsp;на&nbsp;нее&nbsp;в&nbsp;'а'</font>
k&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"x"</font>
a<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;новая&nbsp;запись&nbsp;с&nbsp;ключом&nbsp;"х"&nbsp;и&nbsp;значением&nbsp;10</font>
a<font color=FF0000>[</font><font color=AC00A9>20</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"great"</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;новая&nbsp;запись&nbsp;с&nbsp;ключом&nbsp;20&nbsp;и&nbsp;значением&nbsp;"great"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10</font>
k&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>20</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font>k<font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;"great"</font>
a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=008000>--&nbsp;увеличить&nbsp;запись&nbsp;"х"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;11</font>
</pre>

<p>Таблица всегда анонимна. Не существует постоянной связи между переменной, которая содержит таблицу, и самой таблицей:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;'b'&nbsp;ссылается&nbsp;на&nbsp;ту&nbsp;же&nbsp;таблицу,&nbsp;что&nbsp;и&nbsp;'а'</font>
<font color=0080C0>print</font><font color=FF0000>(</font>b<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;10</font>
b<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>20</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;20</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;только&nbsp;'b'&nbsp;по-прежнему&nbsp;ссылается&nbsp;на&nbsp;таблицу</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;на&nbsp;таблицу&nbsp;не&nbsp;осталось&nbsp;ссылок</font>
</pre>

<p>Когда в программе не остается больше ссылок на таблицу, сборщик мусора в Lua со временем уничтожит таблицу и переиспользует ее память.</p>

<p>Каждая таблица может содержать значения с разными типами индексов, и таблица растет по мере добавления новых записей:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;пустая&nbsp;таблица</font>
<font color=008000>--&nbsp;создать&nbsp;1000&nbsp;новых&nbsp;записей</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1000</font>&nbsp;<font color=0000DF>do</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;i<font color=FF0000>*</font><font color=AC00A9>2</font>&nbsp;<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=AC00A9>9</font><font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;18</font>
a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;10</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=8888CC>"y"</font><font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
</pre>

<p>Обратите внимание на последнюю строку: как и в случае глобальных переменных, неинициализированные поля таблицы возвращают <code>nil</code>. Так же как и для глобальных переменных, вы можете присвоить полю таблицы <code>nil</code>, для того чтобы его уничтожить. Это не совпадение: Lua хранит глобальные переменные в обыкновенных таблицах. Мы рассмотрим это подробнее в <a href="#Глава 14. Окружение">главе 14</a>.</p>

<p>Для представления записей вы используете имя поля как индекс. Lua поддерживает это представление, предлагая следующий «синтаксический сахар»: вместо <code>a["name"]</code> вы можете писать <code>a.name</code>. Таким образом, мы можем переписать последние несколько строк предыдущего примера более чистым образом:</p>

<pre class="code">
a<font color=FF0000>.</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;то&nbsp;же,&nbsp;что&nbsp;и&nbsp;a["x"]&nbsp;=&nbsp;10</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>.</font>x<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;то&nbsp;же,&nbsp;что&nbsp;и&nbsp;print(a["x"])</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>.</font>y<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;то&nbsp;же,&nbsp;что&nbsp;и&nbsp;print(a["y"])</font>
</pre>

<p>Для Lua эти две формы полностью эквивалентны и могут быть свободно использованы. Для читателя, однако, каждая форма может сообщать об определенном намерении. Запись через точку ясно показывает, что мы используем таблицу как запись (<i>структуру</i>), где у нас есть определенный набор заданных, предопределенных ключей. Другая запись подталкивает к мысли о том, что таблица может использовать в качестве ключа любую строку и по какой-то причине в данном месте мы работаем с конкретным ключом.</p>

<p>Часто встречающаяся ошибка новичков заключается в том, что они путают <code>а.х</code> и <code>а[х]</code>. Первая форма на самом деле соответствует <code>а["х"]</code>, то есть обращению к таблице с ключом <code>"х"</code>. Во втором случае в качестве ключа выступает значение переменной <code>х</code>. Ниже показана разница:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"y"</font>
a<font color=FF0000>[</font>x<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;записать&nbsp;10&nbsp;в&nbsp;поле&nbsp;"у"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font>x<font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;--&nbsp;значение&nbsp;поля&nbsp;"у"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>.</font>x<font color=FF0000>)</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;nil&nbsp;--&nbsp;значение&nbsp;поля&nbsp;"х"&nbsp;(не&nbsp;определено)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>.</font>y<font color=FF0000>)</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;--&nbsp;значение&nbsp;поля&nbsp;"у"</font>
</pre>

<p>Чтобы представить традиционный массив или список, просто используйте таблицу с целочисленными ключами. Нет ни способа, ни необходимости обьявлять размер; вы просто инициализируете те элементы, которые вам нужны:</p>

<pre class="code">
<font color=008000>--&nbsp;прочесть&nbsp;10&nbsp;строк,&nbsp;запоминая&nbsp;их&nbsp;в&nbsp;таблице</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font>&nbsp;<font color=0000DF>do</font>
a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
<font color=0000DF>end</font>
</pre>

<p>Поскольку вы можете индексировать таблицу по любому значению, вы можете начать индексы в массиве с любого числа, которое вам нравится. Однако в Lua принято начинать массивы <i>с единицы</i> (а не с нуля, как в С), и некоторые средства Lua придерживаются этого соглашения.</p>

<p>Обычно, когда вы работаете со списком, вам нужно знать его длину. Она может быть константой или может быть где-то записана. Обычно мы записываем длину списка в поле с нечисловым ключом. По историческим причинам некоторые программы используют для этих целей поле "<code>n</code>".</p>

<p>Часто, однако, длина явно не задается. Поскольку любому неинициализированному полю соответствует значение <b>nil</b>, то мы можем использовать это значение для определения конца списка. Например, если вы прочли десять строк в список, то легко запомнить, что его длина равна 10, поскольку его ключами являются числа 1, 2, ..., 10. Этот подход работает только со списками, в которых нет дыр, которые содержат значение <b>nil</b>. Мы называем подобные списки <i>последовательностями</i> (<i>sequence</i>).</p>

<p>Для последовательностей Lua предлагает оператор длины '<code>#</code>'. Он возвращает последний индекс или длину последовательности. Например, вы можете напечатать строки, прочитанные в предыдущем примере, при помощи следующего кода:</p>

<pre class="code">
<font color=008000>--&nbsp;print&nbsp;the&nbsp;lines</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>a&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>])</font>
<font color=0000DF>end</font>
</pre>

<p>Поскольку мы можем индексировать таблицу значениями любого типа, то при индексировании таблицы возникают те же тонкости, что и при проверке на равенство. Хотя мы можем индексировать таблицу и с помощью целого числа <code>0</code>, и с помощью строки <code>"0"</code>, эти два значения различны и соответствуют разным элементам таблицы. Аналогично строки <code>"+1", "01"</code> и <code>"1"</code> также соответствуют разным элементам таблицы. Когда вы не уверены насчет типа ваших индексов, используйте явное приведение типов:</p>

<pre class="code">
i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>;</font>&nbsp;j&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"10"</font><font color=FF0000>;</font>&nbsp;k&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"+10"</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"one&nbsp;value"</font>
a<font color=FF0000>[</font>j<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"another&nbsp;value"</font>
a<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"yet&nbsp;another&nbsp;value"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;one&nbsp;value</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font>j<font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;another&nbsp;value</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font>k<font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;yet&nbsp;another&nbsp;value</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=0080C0>tonumber</font><font color=FF0000>(</font>j<font color=FF0000>)])</font>&nbsp;<font color=008000>--&gt;&nbsp;one&nbsp;value</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=0080C0>tonumber</font><font color=FF0000>(</font>k<font color=FF0000>)])</font>&nbsp;<font color=008000>--&gt;&nbsp;one&nbsp;value</font>
</pre>

<p>Если не обращать внимания на эти тонкости, то легко внести в программу трудно находимые ошибки.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.6. Функции"></a>2.6. Функции
</div>

<p>Функции являются <i>значениями первого класса</i> в Lua: программы могут записывать функции в переменные, передавать функции как аргументы для других функций и возвращать функции как результат. Подобная возможность придает огромную гибкость языку; программа может переопределить функцию, чтобы добавить новую функциональность, или просто удалить функцию для создания безопасного окружения для выполнения фрагмента ненадежного кода (например, кода, полученного по сети). Более того, Lua предоставляет хорошую поддержку функционального программирования, включая вложенные функции с соответствующим лексическим окружением; просто подождите до <a href="#Глава 6. Ещё о функциях">главы 6</a>. Наконец, функции первого класса играют важную роль в обьектно-ориентированных возможностях Lua, как мы увидим в <a href="#Глава 16. Обьектно-ориентированное программирование">главе 16</a>.</p>

<p>Lua может вызывать функции, написанные на Lua, и функции, написанные на С. Обычно мы используем функции, написанные на С, для того чтобы получить высокое быстродействие и доступ к возможностям, недоступным непосредственно из Lua, таким как доступ к средствам операционной системы. Все стандартные библиотеки в Lua написаны на С. Они включают в себя функции для работы со строками, работы с таблицами, ввод/вывод, доступ к базовым возможностям операционной системы, математические функции и отладку.</p>

<p>Мы обсудим функции Lua в <a href="#Глава 5. Функции">главе 5</a> и функции на С в главе 27.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2.7. userdata и нити"></a>2.7. userdata и нити
</div>

<p>Тип <i>userdata</i> позволяет запоминать произвольные данные языка С в переменных Lua. У этого типа нет встроенных операций, за исключением присваивания и проверки на равенство. Значения данного типа используются для представления новых типов, созданных приложением или библиотекой, написанной на С. Например, стандартная библиотека ввода/вывода использует их для представления открытых файлов. Мы более подробно обсудим этот тип позже, когда перейдем к С API.</p>

<p>Тип нить (<i>thread</i>) будет рассмотрен в <a href="#Глава 9. Сопрограммы">главе 9</a>, где мы рассмотрим сопрограммы.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="2. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 2.1.</b><br>
Что является значением выражения type <code>(nil) == nil</code>? (Вы можете использовать Lua для проверки своего ответа.) Можете ли вы обьяснить результат?</p>

<hr color=99CCFF>

<p><b>Упражнение 2.2.</b><br>
Что из приведенного ниже является допустимыми числами? Каковы их значения?</p>

<pre class="code">.0е12 .е12 О.Ое 0x12 0xABFG ОхА FFFF 0xFFFFFFFF 0x 0xlPlO O.lel 0x0.lpl</pre>

<hr color=99CCFF>

<p><a name="упражнение 2.3"></a><b>Упражнение 2.3.</b><br>
Число <code>12.7</code> равно дроби <code>127/10</code>, где все числа являются десятичными. Можете ли вы представить его как значение двоичной дроби? А число <code>5.5</code>?</p>

<hr color=99CCFF>

<p><b>Упражнение 2.4.</b><br>
Как вы запишете следующий фрагмент XML в строку Lua?</p>

<pre class="code">
&lt;![СDATA[
Hello world
]]&gt;
</pre>

<p>Используйте как минимум два разных способа.</p>

<hr color=99CCFF>

<p><b>Упражнение 2.5.</b><br>
Допустим, вам нужно записать длинную последовательность произвольных байт как строковую константу в Lua. Как вы это сделаете? Обратите внимание на читаемость, максимальную длину строки и быстродействие. </p>

<hr color=99CCFF>

<p><b>Упражнение 2.6.</b><br>
Рассмотрите следующий код:</p>

<pre class="code">a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{};</font>&nbsp;a<font color=FF0000>.</font>a&nbsp;<font color=FF0000>=</font>&nbsp;a</pre>

<p>Что будет значением <code>а.а.а.а</code> ? Какое-либо <code>а</code> в этой последовательности как-то отличается от остальных? Теперь добавьте следующую строку к предыдущему коду:</p>

<pre class="code">a<font color=FF0000>.</font>a<font color=FF0000>.</font>a<font color=FF0000>.</font>a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>3</font></pre>

<p>Что теперь будет значением <code>a.a.a.a</code> ?</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 3. Выражения"></a>Глава 3. Выражения
</div>

<hr>

<p>Выражения представляют значения. Выражения в Lua включают числовые константы и строковые литералы, переменные, унарные и бинарные операции и вызовы функций. Выражения также включают в себя нестандартные определения функций и конструкторы для таблиц.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="3.1. Арифметические операторы"></a>3.1. Арифметические операторы
</div>

<p>Lua поддерживает стандартные арифметические операторы: бинарные '<code>+</code>' (<i>сложение</i>), '<code>-</code>' (<i>вычитание</i>), '<code>*</code>' (<i>умножение</i>), '<code>/</code>' (<i>деление</i>), '<code>^</code>' (<i>возведение в степень</i>), '<code>%</code>' (<i>остаток отделения</i>) и унарный '<code>-</code>' (<i>изменение знака</i>). Все из них работают с числами с плавающей точкой. Например, <code>х^0.5</code> вычисляет квадратный корень из <code>х</code>, а <code>х^(-1/3)</code> вычисляет обратное значение к кубическому корню из <code>х</code>.</p>

<p>Следующее правило определяет оператор остатка от деления:</p>

<pre class="code">a&nbsp;<font color=FF0000>%</font>&nbsp;b&nbsp;<font color=FF0000>==</font>&nbsp;a&nbsp;<font color=FF0000>-</font>&nbsp;<font color=8000FF>math.floor</font><font color=FF0000>(</font>a<font color=FF0000>/</font>b<font color=FF0000>)*</font>b</pre>

<p>Для целочисленных операндов у него стандартное значение, и результат имеет тот же знак, что и второй операнд. Для вещественных операндов у него есть некоторые дополнительные возможности. Например, <code>х%1</code> дает дробную часть <code>х</code>, а <code>х-х%1</code> дает его целую часть. Аналогично <code>х-х%0.01</code> дает <code>х</code> точно с двумя десятичными знаками после запятой:</p>

<pre class="code">
x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.pi</font>
<font color=0080C0>print</font><font color=FF0000>(</font>x&nbsp;<font color=FF0000>-</font>&nbsp;x<font color=FF0000>%</font><font color=AC00A9>0.01</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;3.14</font>
</pre>

<p>В качестве другого примера использования оператора остатка от деления рассмотрим следующий пример: допустим, вы хотите узнать, будет ли транспортное средство после поворота на заданный угол сдвигаться в обратном направлении. Если угол задан в градусах, то вы можете использовать следующую формулу:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;tolerance&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>
<font color=0000DF>function</font>&nbsp;isturnback&nbsp;<font color=FF0000>(</font>angle<font color=FF0000>)</font>
&nbsp;&nbsp;angle&nbsp;<font color=FF0000>=</font>&nbsp;angle&nbsp;<font color=FF0000>%</font>&nbsp;<font color=AC00A9>360</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font><font color=0080C0>math</font><font color=FF0000>.</font>abs<font color=FF0000>(</font>angle&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>180</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>&lt;</font>&nbsp;tolerance<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Это определение работает даже для отрицательных углов:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font>isturnback<font color=FF0000>(-</font><font color=AC00A9>180</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;true</font></pre>

<p>Если вы хотите работать с радианами вместо градусов, мы просто изменим константы в функциях:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;tolerance&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0.17</font>
<font color=0000DF>function</font>&nbsp;isturnback&nbsp;<font color=FF0000>(</font>angle<font color=FF0000>)</font>
&nbsp;&nbsp;angle&nbsp;<font color=FF0000>=</font>&nbsp;angle&nbsp;<font color=FF0000>%</font>&nbsp;<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>*</font><font color=8000FF>math.pi</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font><font color=0080C0>math</font><font color=FF0000>.</font>abs<font color=FF0000>(</font>angle&nbsp;<font color=FF0000>-</font>&nbsp;<font color=8000FF>math.pi</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>&lt;</font>&nbsp;tolerance<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Все, что нам нужно, - это операция <code>angle%(2*math.pi)</code> для приведения любого угла к интервалу <code>[0,2л]</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="3.2. Операторы сравнения"></a>3.2. Операторы сравнения
</div>

<p>Lua предоставляет следующие операторы сравнения:</p>

<font color="#FF0000">
<pre class="code">&lt;    &gt;    &lt;=   &gt;=    ==    ~=</pre>
</font>

<p>Все эти операторы всегда дают булево значение.</b><br>
Оператор <code>==</code> проверяет на равенство; оператор <code>~=</code> - это отрицание равенства. Мы можем использовать оба этих оператора к любым двум значениям. Если значения имеют различные типы, то Lua считает, что они не равны. В противном случае Lua сравнивает их соответственно их типу. Значение <code>nil</code> равно только самому себе.</p>

<p>Lua сравнивает таблицы и обьекты типа <code>userdata</code> по ссылке, то есть два таких значения считаются равными, только если они являются одним и тем же обьектом. Например, после выполнения следующего кода:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{};</font>&nbsp;a<font color=FF0000>.</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>;</font>&nbsp;a<font color=FF0000>.</font>y&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{};</font>&nbsp;b<font color=FF0000>.</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>;</font>&nbsp;b<font color=FF0000>.</font>y&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
c&nbsp;<font color=FF0000>=</font>&nbsp;a
</pre>

<p>мы получим <code>а == с</code>, но <code>а ~= Ь</code>.</p>

<p>Мы можем применять операторы порядка лишь к паре чисел или паре строк. Lua сравнивает строки в алфавитном порядке, следуя установленной для Lua локали. Например, для португальской локали <i>Latin-1</i> мы получим <code>"acai"&lt;"agai"&lt;"acorde"</code>. Значения типов, отличных от строк и чисел, могут быть сравнены только на равенство (и неравенство).</p>

<p>При сранпении значений различных типов нужно быть аккуратным: помните, что <code>"0"</code> отличается от <code>0</code>. Более того, <code>2&lt;15</code> очевидно истинно, но <code>"2"&lt;"15"</code> ложно. В случае, когда вы пытаетесь сравнить строку и число, например <code>2&lt;"15"</code>, возникает ошибка.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="3.3. Логические операторы"></a>3.3. Логические операторы
</div>

<p>Логическими операторами являются <b>and</b>, <b>or</b> и <b>not</b>. Как и управляющие конструкции, логические операторы трактуют <code>false</code> и <code>nil</code> как ложные, а все остальные - как истинные значения. Оператор <b>and</b> возвращает свой первый операнд, если он ложен, иначе он возвращает свой второй операнд. Оператор <b>or</b> возвращает свой первый операнд, если он не ложен; иначе он возвращает свой второй операнд:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>4</font>&nbsp;<font color=0000DF>and</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;5</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0000DF>nil</font>&nbsp;<font color=0000DF>and</font>&nbsp;<font color=AC00A9>13</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;nil</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0000DF>false</font>&nbsp;<font color=0000DF>and</font>&nbsp;<font color=AC00A9>13</font><font color=FF0000>)</font>&nbsp;<font color=008000>-->&nbsp;false</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>4</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;4</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0000DF>false</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;5</font>
</pre>

<p>Оба оператора (<b>and</b> и <b>or</b>) использует сокращенное вычисление, то есть они вычисляют свой второй операнд, только когда это необходимо. Это гарантирует, что выражения вроде <code>(type(v)=="table" and v.tag=="hl")</code> не вызовут ошибок при их вычислении: Lua не будет пытаться вычислить <code>v.tag</code>, когда <code>v</code> не является таблицей.</p>

<p>Полезной конструкцией в Lua является <code>х = х or v</code>, эквивалентная следующему коду:</p>

<pre class="code"><font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;x&nbsp;<font color=0000DF>then</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;v&nbsp;<font color=0000DF>end</font></pre>

<p>To есть значение <code>x</code> устанавливается равным значению по умолчанию <code>v</code>, если <code>х</code> не определено (при условии, что <code>х</code> не равно <code>false</code>).</p>

<p>Другой полезной конструкцией является <code>(a and b) or с</code> или просто <code>a and b or с</code>, поскольку у оператора <b>and</b> более высокий приоритет, чем у <b>or</b>. Она эквивалентна выражению <code>а?b:с</code> в языке С, при условии что <code>b</code> не ложно. Например, мы можем выбрать максимум из двух чисел <code>х</code> и <code>у</code> при помощи следующего оператора:</p>

<pre class="code">max&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>x&nbsp;<font color=FF0000>&gt;</font>&nbsp;y<font color=FF0000>)</font>&nbsp;<font color=0000DF>and</font>&nbsp;x&nbsp;<font color=0000DF>or</font>&nbsp;y</pre>

<p>Когда <code>х &gt; у</code>, то первое выражение в операторе <b>and</b> истинно, поэтому он возвращает свое второе значение (<code>х</code>), которое всегда истинно (поскольку это число), и затем оператор <b>or</b> возвращает свой первый операнд, <code>х</code>. Если выражение <code>х &gt; у</code> ложно, то результат оператора <b>and</b> также ложен, и поэтому оператор <b>or</b> возвращает свой второй операнд, <code>у</code>.</p>

<p>Оператор <b>not</b> всегда возвращает булево значение:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0000DF>not</font>&nbsp;<font color=0000DF>nil</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0000DF>not</font>&nbsp;<font color=0000DF>false</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0000DF>not</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;false</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0000DF>not</font>&nbsp;<font color=0000DF>not</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0000DF>not</font>&nbsp;<font color=0000DF>not</font>&nbsp;<font color=0000DF>nil</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;false</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="3.4. Конкатенация"></a>3.4. Конкатенация
</div>

<p>Lua обозначает оператор конкатенации как <code>..</code> (две точки). Если операнд является числом, то Lua переведет его в строку. (Некоторые языки используют для конкатенации оператор '<code>+</code>', но в Lua <code>3+5</code> отличается от <code>3..5</code>.)</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"Hello&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"World"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;Hello&nbsp;World</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>0</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;01</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>000</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=AC00A9>01</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;01</font>
</pre>

<p>Помните, что строки в Lua являются неизменяемыми значениями. Оператор конкатенации всегда создает новую строку, не изменяя своих операндов:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Hello"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;World"</font><font color=FF0000>)</font>&nbsp;<font color=008000>-->&nbsp;Hello&nbsp;World</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>-->&nbsp;Hello</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="3.5. Оператор длины"></a>3.5. Оператор длины
</div>

<p>Оператор длины работает со строками и таблицами. Со строками он дает количество байт в строке. С таблицами он возвращает длину последовательности, представленной таблицей.</p>

<p>С оператором длины связано несколько распространенных идиом для работы с последовательностями.</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[#</font>a<font color=FF0000>])</font>&nbsp;&nbsp;<font color=008000>--&nbsp;печатает&nbsp;последний&nbsp;элемент&nbsp;последовательности&nbsp;'а'</font>
a<font color=FF0000>[#</font>a<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;удаляет&nbsp;последний&nbsp;элемент</font>
a<font color=FF0000>[#</font>a&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;v&nbsp;<font color=008000>--&nbsp;добавляет&nbsp;к&nbsp;концу&nbsp;списка</font>
</pre>

<p>Как мы видели в предыдущей главе, оператор длины непредсказуем для списков с дырками (<code>nil</code>). Он работает только для последовательностей, которые мы определили как списки без дырок. Более точно <i>последовательность</i> - это таблица, где ключи образуют последовательность <code>1, ..., n</code> для некоторого <i>n</i>. (Помните, что любой ключ со значением <code>nil</code> на самом деле в таблице отсутствует.) В частности, таблица без числовых ключей - это последовательность длины ноль.</p>

<p>С годами было много предложений по расширению значения оператора длины на списки с дырками, но это легче сказать, чем сделать. Проблема в том, что поскольку список - это таблица, то понятие «длины» несколько расплывчато. Например, рассмотрим список, получаемый следующим фрагментом кода:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
a<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=008000>--&nbsp;ничего&nbsp;не&nbsp;делает,&nbsp;так&nbsp;как&nbsp;а[2]&nbsp;уже&nbsp;nil</font>
a<font color=FF0000>[</font><font color=AC00A9>3</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
a<font color=FF0000>[</font><font color=AC00A9>4</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
</pre>

<p>Легко сказать, что длина этого списка четыре и у него есть дырка по индексу <code>2</code>. Однако что можно сказать о следующем примере?</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
a<font color=FF0000>[</font><font color=AC00A9>10000</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
</pre>

<p>Должны ли мы рассматривать это а как список с 10000 элементами, где 9998 элементов равны <b>nil</b>? Теперь пусть программа делает следующее:</p>

<pre class="code">a<font color=FF0000>[</font><font color=AC00A9>10000</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font></pre>

<p>Что же произошло с длиной списка? Должна ли она быть 9999, поскольку программа удалила последний элемент? Или может быть 10 000, так как программа просто изменила значение последнего элемента на <b>nil</b>? Или же длина должна стать <code>1</code>?</p>

<p>Другим распространенным предложением является сделать так, чтобы оператор <code>#</code> возвращал число элементов в таблице. Эта семантика ясна и хорошо определена, но не несет в себе никакой пользы. Рассмотрим все предыдущие примеры и представим, насколько полезным оказался бы подобный оператор для алгоритмов, работающих со списками или массивами.</p>

<p>Еще более проблемными являются значения <b>nil</b> в конце списка. Какой должна быть длина следующего списка?</p>


<pre class="code">a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>30</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>nil</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>nil</font><font color=FF0000>}</font></pre>


<p>Вспомним, что для Lua поле со значением <b>nil</b> не отличается от отсутствующего поля. Таким образом, предыдущая таблица неотличима от <code>{10,20, 30}</code>; ее длина равна <code>3</code>, а не <code>5</code>.</p>

<p>Вы можете считать, что <b>nil</b> в конце списка - это особенный случай. Однако многие списки строятся путем добавления элементов, одного за другим. Любой список с дырками, который был построен таким образом, просто получен добавлением <b>nil</b> в свой конец.</p>

<p>Многие списки, которые мы используем в наших программах, являются последовательностями (например, строка файла не может быть <b>nil</b>), и поэтому большую часть времени оператор длины безопасен для использования. Если вам действительно нужно работать со списками с дырками, то вам лучше явно запоминать где-то длину списка.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="3.6. Приоритеты операторов"></a>3.6. Приоритеты операторов
</div>

<p>Приоритеты операторов в Lua заданы в таблице ниже, от самого старшего к самому низшему:</p>

<pre class="code">
<font color=FF0000>^</font>
<font color=0000DF>not</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>#</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>-</font>&nbsp;<font color=FF0000>(</font>unary<font color=FF0000>)</font>
<font color=FF0000>*</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>/</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>%</font>
<font color=FF0000>+</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>-</font>
<font color=FF0000>..</font>
<font color=FF0000>&lt;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&gt;</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&lt;=</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&gt;=</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>~=</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>==</font>
<font color=0000DF>and</font>
<font color=0000DF>or</font>
</pre>

<p>Все бинарные операторы ассоциативны влево, за исключением '<code>^</code>' (<i>экспоненцирование</i>) и '<code>..</code>' (<i>конкатенация</i>), которые ассоциативны вправо. Поэтому следующие выражения слева эквивалентны выражениям справа:</p>

<pre class="code">
a<font color=FF0000>+</font>i&nbsp;<font color=FF0000>&lt;</font>&nbsp;b<font color=FF0000>/</font><font color=AC00A9>2</font><font color=FF0000>+</font><font color=AC00A9>1</font>         &lt;--&gt;    <font color=FF0000>(</font>a<font color=FF0000>+</font>i<font color=FF0000>)</font>&nbsp;<font color=FF0000>&lt;</font>&nbsp;<font color=FF0000>((</font>b<font color=FF0000>/</font><font color=AC00A9>2</font><font color=FF0000>)+</font><font color=AC00A9>1</font><font color=FF0000>)</font>
<font color=AC00A9>5</font><font color=FF0000>+</font>x<font color=FF0000>^</font><font color=AC00A9>2</font><font color=FF0000>*</font><font color=AC00A9>8</font>             &lt;--&gt;    <font color=AC00A9>5</font><font color=FF0000>+((</font>x<font color=FF0000>^</font><font color=AC00A9>2</font><font color=FF0000>)*</font><font color=AC00A9>8</font><font color=FF0000>)</font>
a&nbsp;<font color=FF0000>&lt;</font>&nbsp;y&nbsp;<font color=0000DF>and</font>&nbsp;y&nbsp;<font color=FF0000>&lt;=</font>&nbsp;z    &lt;--&gt;    <font color=FF0000>(</font>a&nbsp;<font color=FF0000>&lt;</font>&nbsp;y<font color=FF0000>)</font>&nbsp;<font color=0000DF>and</font>&nbsp;<font color=FF0000>(</font>y&nbsp;<font color=FF0000>&lt;=</font>&nbsp;z<font color=FF0000>)</font>
<font color=FF0000>-</font>x<font color=FF0000>^</font><font color=AC00A9>2</font>                &lt;--&gt;    <font color=FF0000>-(</font>x<font color=FF0000>^</font><font color=AC00A9>2</font><font color=FF0000>)</font>
x<font color=FF0000>^</font>y<font color=FF0000>^</font>z               &lt;--&gt;    x<font color=FF0000>^(</font>y<font color=FF0000>^</font>z<font color=FF0000>)</font>
</pre>

<p>Когда сомневаетесь, всегда используйте скобки. Это легче, чем смотреть в руководстве, и, скорее всего, потом, когда вы будете читать этот код, у вас снова возникнут сомнения.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="3 7. Конструкторы таблиц"></a>3 7. Конструкторы таблиц
</div>

<p>Конструкторы - это выражения, которые создают и инициализируют таблицы. Они являются отличительной чертой Lua и одним из его наиболее полезных и универсальных механизмов.
Простейший конструктор - это пустой конструктор, <code>{}</code>, который создает пустую таблицу; мы раньше это уже видели. Конструкторы также инициализируют списки. Например, оператор</p>

<pre class="code">days&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"Sunday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Monday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Tuesday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Wednesday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Thursday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Friday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Saturday"</font><font color=FF0000>}</font></pre>

<p>проинициализирует <code>days[l]</code> значением <code>"Sunday"</code> (первый элемент конструктора имеет индекс <code>1</code>, а не <code>0</code>), <code>days[2]</code> - значением <code>"Monday"</code> и т. д.:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font>days<font color=FF0000>[</font><font color=AC00A9>4</font><font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;Wednesday</font></pre>

<p>Lua также предлагает специальный синтаксис для инициализации таблиц по полям, как в следующем примере:</p>

<pre class="code">a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>20</font><font color=FF0000>}</font></pre>

<p>Эта строка эквивалентна следующим командам:</p>

<pre class="code">a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{};</font>&nbsp;a<font color=FF0000>.</font>x<font color=FF0000>=</font><font color=AC00A9>10</font><font color=FF0000>;</font>&nbsp;a<font color=FF0000>.</font>y<font color=FF0000>=</font><font color=AC00A9>20</font></pre>

<p>Исходное выражение проще и быстрее, поскольку Lua сразу создает таблицу с правильным размером.</p>

<p>Вне зависимости от того, каким конструктором мы пользовались для создания таблицы, мы всегда можем добавлять и удалять поля из нее:</p>

<pre class="code">
w&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;label<font color=FF0000>=</font><font color=8888CC>"console"</font><font color=FF0000>}</font>
x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8000FF>math.sin</font><font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>),</font>&nbsp;<font color=8000FF>math.sin</font><font color=FF0000>(</font><font color=AC00A9>1</font><font color=FF0000>),</font>&nbsp;<font color=8000FF>math.sin</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>)}</font>
w<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"another&nbsp;field"</font>&nbsp;<font color=008000>--&nbsp;добавить&nbsp;ключ&nbsp;1&nbsp;к&nbsp;таблице&nbsp;'w'</font>
x<font color=FF0000>.</font>f&nbsp;<font color=FF0000>=</font>&nbsp;w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;добавить&nbsp;ключ&nbsp;"f"&nbsp;к&nbsp;таблице&nbsp;'х'</font>
<font color=0080C0>print</font><font color=FF0000>(</font>w<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0</font>
<font color=0080C0>print</font><font color=FF0000>(</font>w<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;другое&nbsp;поле</font>
<font color=0080C0>print</font><font color=FF0000>(</font>x<font color=FF0000>.</font>f<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;другое&nbsp;поле</font>
w<font color=FF0000>.</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;удалить&nbsp;поле&nbsp;"х"</font>
</pre>

<p>Однако создание таблицы сразу с правильным конструктором более эффективно и наглядно.</b><br>
Мы можем смешивать эти два стиля инициализации (списком и по полям) в одном и том же конструкторе:</p>

<pre class="code">
polyline&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>color<font color=FF0000>=</font><font color=8888CC>"blue"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thickness<font color=FF0000>=</font><font color=AC00A9>2</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;npoints<font color=FF0000>=</font><font color=AC00A9>4</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>},</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;polyline[1]</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>{</font>x<font color=FF0000>=-</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>},</font>&nbsp;<font color=008000>--&nbsp;polyline[2]</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>{</font>x<font color=FF0000>=-</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>},</font>&nbsp;<font color=008000>--&nbsp;polyline[3]</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>}</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;polyline[4]</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>}</font>
</pre>

<p>Приведенный выше пример также показывает, как можно вкладывать конструкторы один в другой для представления более сложных структур данных. Каждый из элементов <code>polyline[i]</code> - это таблица, представляющая собой запись:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>polyline<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>].</font>x<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;-10</font>
<font color=0080C0>print</font><font color=FF0000>(</font>polyline<font color=FF0000>[</font><font color=AC00A9>4</font><font color=FF0000>].</font>y<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;1</font>
</pre>

<p>Эти две формы конструктора имеют свои ограничения. Например, вы не можете инициализировать поля с отрицательными индексами или с индексами, которые не являются идентификаторами. Для таких целей есть другой, более общий формат. В этом формате мы явно пишем индекс как выражение между квадратными скобками:</p>

<pre class="code">
opnames&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{[</font><font color=8888CC>"+"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"add"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=8888CC>"-"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"sub"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"*"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"mul"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=8888CC>"/"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"div"</font><font color=FF0000>}</font>
i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>;</font>&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"-"</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{[</font>i<font color=FF0000>+</font><font color=AC00A9>0</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;s<font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font>i<font color=FF0000>+</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;s<font color=FF0000>..</font>s<font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font>i<font color=FF0000>+</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;s<font color=FF0000>..</font>s<font color=FF0000>..</font>s<font color=FF0000>}</font>

<font color=0080C0>print</font><font color=FF0000>(</font>opnames<font color=FF0000>[</font>s<font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;sub</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=AC00A9>22</font><font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;---</font>
</pre>

<p>Этот синтаксис более неудобен, но и более общ: рассмотренные ранее формы конструктора являются частными случаями этого более общего синтаксиса. Конструктор <code>{х=0,у=0}</code> эквивалентен <code>{["х"]=0,["у"]=0)</code>, и конструктор <code>{"r","g","b"}</code> эквивалентен <code>{[1]="r",[2]="g",[3]="b"}</code></p>

<p>Вы всегда можете поставить запятую после последней записи в конструкторе. Эти запятые необязательны: </p>

<pre class="code">a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{[</font><font color=AC00A9>1</font><font color=FF0000>]=</font><font color=8888CC>"red"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>]=</font><font color=8888CC>"green"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=AC00A9>3</font><font color=FF0000>]=</font><font color=8888CC>"blue"</font><font color=FF0000>,}</font></pre>

<p>Это освобождает программы, генерирующие конструкторы Lua, от необходимости обрабатывать последний элемент особым образом.</p>

<p>Наконец, вы всегда можете использовать в конструкторе точку с запятой вместо запятой. Я обычно использую точки с запятой для отделения различных секций в конструкторе, например отделения части, оформленной как записи, от части, оформленной как список:</p>

<pre class="code"><font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>45</font><font color=FF0000>;</font>&nbsp;<font color=8888CC>"one"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"two"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"three"</font><font color=FF0000>}</font></pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="3. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 3.1.</b><br>
Что напечатает следующая программа?</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>,</font>&nbsp;i&nbsp;<font color=FF0000>%</font>&nbsp;<font color=AC00A9>3</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<hr color=99CCFF>

<p><b>Упражнение 3.2.</b><br>
Что является результатом выражения <code>2^3^4</code>? А что насчет <code>2^ - 3^4</code> ?</p>

<hr color=99CCFF>

<p><a name="упражнение 3.3"></a><b>Упражнение 3.3.</b><br>
Мы можем представить многочлен</p>

<pre class="code">   n        n-1            1
A X  + A   X    + ... + A X + A
 n      n-1              1     0</pre>

<p>в Lua как список его коэффициентов <code>{a0, а1 , ... , аN}</code>.
Напишите функцию, которая получает многочлен (представленный таблицей) и значение <code>х</code> возвращает значение полинома в <code>X</code>.</p>

<hr color=99CCFF>

<p><b>Упражнение 3.4.</b><br>
Можете ли вы написать функцию из предыдущего упражнения так, чтобы использовать <code>n</code> сложений и <code>n</code> умножений (и не использовать возведение в степень)?</p>

<hr color=99CCFF>

<p><b>Упражнение 3.5.</b><br>
Как вы можете проверить, является ли значение булевым, не прибегая к функции <code>type</code>?</p>

<hr color=99CCFF>

<p><b>Упражнение 3.6.</b><br>
Рассмотрим следующее выражение:</p>

<pre class="code"><font color=FF0000>(</font>x&nbsp;<font color=0000DF>and</font>&nbsp;y&nbsp;<font color=0000DF>and</font>&nbsp;<font color=FF0000>(</font><font color=0000DF>not</font>&nbsp;z<font color=FF0000>))</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>((</font><font color=0000DF>not</font>&nbsp;y<font color=FF0000>)</font>&nbsp;<font color=0000DF>and</font>&nbsp;x<font color=FF0000>)</font></pre>

<p>Нужны ли в этом выражении круглые скобки? Как бы вы посоветовали использовать их в данном выражении? </p>

<hr color=99CCFF>

<p><b>Упражнение 3.7.</b><br>
Что напечатает следующий фрагмент кода? обьясните.</p>

<pre class="code">
sunday&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"monday"</font><font color=FF0000>;</font>&nbsp;monday&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"sunday"</font>
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>sunday&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"monday"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font>sunday<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;monday<font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>t<font color=FF0000>.</font>sunday<font color=FF0000>,</font>&nbsp;t<font color=FF0000>[</font>sunday<font color=FF0000>],</font>&nbsp;t<font color=FF0000>[</font>t<font color=FF0000>.</font>sunday<font color=FF0000>])</font>
</pre>

<hr color=99CCFF>

<p><b>Упражнение 3.8.</b><br>
Предположим, вы хотите создать таблицу, которая с каждой управляющей последовательностью (escape sequence) для строк связывает ее значение. Как бы вы написали конструктор такой таблицы?</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 4. Операторы"></a>Глава 4. Операторы
</div>

<p>Lua поддерживает почти традиционный набор операторов, похожий на набор, используемый в <i>С</i> или <i>Pascal</i>. Традиционные операторы включают в себя присваивание, управляющие конструкции и вызовы процедур. Lua также поддерживает менее распространенные операторы, такие как множественное присваивание и определение локальных переменных.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="4.1. Операторы присваивания"></a>4.1. Операторы присваивания
</div>

<p>Присваивание - это базовое средство изменения значений переменной и поля таблицы:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"hello"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"world"</font>
t<font color=FF0000>.</font>n&nbsp;<font color=FF0000>=</font>&nbsp;t<font color=FF0000>.</font>n&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
</pre>

<p>Lua позволяет осуществлять множественное присваивание, которое присваивает список значений списку переменных за один шаг. Например, в операторе</p>

<pre class="code">a<font color=FF0000>,</font>&nbsp;b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>*</font>x</pre>

<p>переменная <code>а</code> получает значение <code>10</code>, а переменная <code>b</code> - значение <code>2*х</code>.</p>

<p>В множественном присваивании Lua сперва вычисляет все значения и только затем выполняет присваивания. Поэтому мы можем использовать множественное присваивание для того, чтобы поменять местами два значения, как в следующих примерах:</p>

<pre class="code">
x<font color=FF0000>,</font>&nbsp;y&nbsp;<font color=FF0000>=</font>&nbsp;y<font color=FF0000>,</font>&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;поменять&nbsp;местами&nbsp;'х'&nbsp;и&nbsp;'y'</font>
a<font color=FF0000>[</font>i<font color=FF0000>],</font>&nbsp;a<font color=FF0000>[</font>j<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font>j<font color=FF0000>],</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=008000>--&nbsp;поменять&nbsp;местами&nbsp;'а[1]'и&nbsp;"a[j]'</font>
</pre>

<p>Lua всегда приводит количество значений к числу переменных: когда количество значений меньше, чем количество переменных, то Lua дополняет список значений соответствующим количеством <b>nil</b>, а когда количество значений больше, то лишние значения просто отбрасываются:</p>

<pre class="code">
a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0&nbsp;1&nbsp;nil</font>
a<font color=FF0000>,</font>&nbsp;b&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>+</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;b<font color=FF0000>+</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;b<font color=FF0000>+</font><font color=AC00A9>2</font>&nbsp;<font color=008000>--&nbsp;значение&nbsp;b+2&nbsp;отбрасывается</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;1&nbsp;2</font>
a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0&nbsp;nil&nbsp;nil</font>
</pre>

<p>Последнее присваивание в примере выше показывает распространенную ошибку. Для того чтобы проинициализировать список переменных, вы должны предоставить значение для каждой переменной:</p>

<pre class="code">
a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0&nbsp;0&nbsp;0</font>
</pre>

<p>В действительности большинство предыдущих примеров в чем-то искусственны. Я редко использую множественное присваивание просто для того, чтобы соединить несколько не связанных между собой присваиваний в одну строку. В частности, множественное присваивание не быстрее, чем набор соответствующих одиночных присваиваний. Тем не менее часто нам действительно нужно множественное присваивание. Мы уже видели пример, меняющий две переменные значениями. Более частое использование заключается в получении сразу нескольких значений, возвращенных функцией. Как мы обсудим в <a href="#5.1. Множественные результаты">разделе 5.1</a>, функция может вернуть сразу несколько значений. В таких случаях обычно используется множественное присваивание, чтобы получить все эти значения. Например, в присваивании <code>a, b = f()</code> вызов <code>f</code> дает два значения: первое из них записывается в <code>a</code>, а второе - в <code>b</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="4.2. Локальные переменные и блоки"></a>4.2. Локальные переменные и блоки
</div>

<p>Кроме глобальных переменных, Lua также поддерживает и локальные переменные. Мы создаем локальные переменные при помощи оператора <b>local</b>:</p>

<pre class="code">
j&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;глобальная&nbsp;переменная</font>
<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=008000>--&nbsp;локальная&nbsp;переменная</font>
</pre>

<p>В отличие от глобальных переменных, область действия локальной переменной ограничена блоком, где она была обьявлена. <i>Блок</i> - это тело управляющей конструкции, тело функции и блок кода (файл или строка, где переменная была обьявлена):</p>

<pre class="code">
x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>
<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;локальная&nbsp;в&nbsp;блоке</font>
<font color=0000DF>while</font>&nbsp;i&nbsp;<font color=FF0000>&lt;=</font>&nbsp;x&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;i<font color=FF0000>*</font><font color=AC00A9>2</font>&nbsp;<font color=008000>--&nbsp;локальная&nbsp;внутри&nbsp;блока&nbsp;while</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;2,&nbsp;4,&nbsp;6,&nbsp;8,&nbsp;...</font>
&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>end</font>
<font color=0000DF>if</font>&nbsp;i&nbsp;<font color=FF0000>&gt;</font>&nbsp;<font color=AC00A9>20</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;локальная&nbsp;внутри&nbsp;"then"</font>
&nbsp;&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>20</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>x&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>&nbsp;&nbsp;<font color=008000>--&nbsp;(напечатает&nbsp;22,&nbsp;если&nbsp;условие&nbsp;выполнится)</font>
<font color=0000DF>else</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;(глобальная)</font>
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;(глобальная)</font>
</pre>

<p>Обратите внимание, что этот пример не будет работать так, как ожидается, если вы его введете в интерактивном режиме. В интерактивном режиме каждая строка - это самостоятельный блок (за исключением случая, когда строка не является законченной конструкцией). Как только вы введете вторую строку примера (<code>local i=1</code>), Lua выполнит ее и начнет новый блок кода (следующая строка). К тому моменту область действия локальной переменной <code>i</code> уже завершится. Чтобы решить эту проблему, мы можем явно заключить весь этот блок между ключевыми словами <b>do-end</b>. Когда вы введете <b>do</b>, блок закончится, только когда вы введете соответствующий ему <b>end</b>, поэтому Lua не будет пытаться выполнить каждую строку как отдельный блок.</p>

<p>Подобные <b>do</b>-блоки оказываются полезными, когда нам нужен более точный контроль за областью действия локальных переменных:</p>

<pre class="code">
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;a2&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>*</font>a
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;d&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>b<font color=FF0000>^</font><font color=AC00A9>2</font>&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>*</font>a<font color=FF0000>*</font>c<font color=FF0000>)^(</font><font color=AC00A9>1</font><font color=FF0000>/</font><font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;x1&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(-</font>b&nbsp;<font color=FF0000>+</font>&nbsp;d<font color=FF0000>)/</font>a2
&nbsp;&nbsp;x2&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(-</font>b&nbsp;<font color=FF0000>-</font>&nbsp;d<font color=FF0000>)/</font>a2
<font color=0000DF>end</font>&nbsp;<font color=008000>--&nbsp;область&nbsp;действия&nbsp;*a2'&nbsp;и&nbsp;заканчивается&nbsp;здесь</font>
<font color=0080C0>print</font><font color=FF0000>(</font>x1<font color=FF0000>,</font>&nbsp;x2<font color=FF0000>)</font>
</pre>

<p>Хорошим стилем является использование локальных переменных везде, где только это возможно. Локальные переменные помогают вам избежать забивания глобального окружения ненужными именами. Более того, доступ к локальной переменной быстрее, чем доступ к глобальной. И наконец, локальная переменная перестает существовать, как только заканчивается ее область действия, позволяя сборщику мусора освободить память, занимаемую ее значением.</p>

<p>Lua рассматривает описания локальных переменных просто как операторы. Поэтому вы можете вставить описание локальной переменной всюду, где вы можете вставить оператор. Область действия описанных переменных начинается сразу после описания и заканчивается концом блока. Каждое описание может включать присвоение начального значения, которое действует так же, как и оператор присваивания: лишние значения отбрасываются, лишние переменные получают значение <b>nil</b>. Если в описании переменной нет присваивания, то соответствующая переменная получает значение <b>nil</b>:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;a<font color=FF0000>,</font>&nbsp;b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font>
<font color=0000DF>if</font>&nbsp;a&nbsp;&lt<font color=FF0000>;</font>&nbsp;b&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;1</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;a&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;подразумевается&nbsp;'=&nbsp;nil'</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
<font color=0000DF>end</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;заканчивает&nbsp;блок,&nbsp;начатый&nbsp;'then'</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;1&nbsp;10</font>
</pre>

<p>Распространенной идиомой в Lua является следующая:</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;foo&nbsp;<font color=FF0000>=</font>&nbsp;foo</pre>

<p>Этот код создает локальную переменную <code>foo</code> и инициализирует ее значением глобальной переменной <code>foo</code>. (Локальная переменная <code>foo</code> становится видимой только после этого обьявления.) Эта идиома оказывается полезной, когда блоку необходимо сохранить значение оригинальной переменной, если оно изменяется где-то далее в коде. Также это ускоряет доступ к этой переменной.</p>

<p>Поскольку многие языки вынуждают декларировать все локальные переменные в начале блока (или процедуры), некоторые считают, что обьявлять переменные в середине блока является плохой практикой. На самом деле верно обратное: обьявляя переменную, только когда она действительно нужна, вам редко понадобится обьявлять ее без начального значения (и поэтому вы вряд ли забудете ее проинициа-лизировать). Более того, вы уменьшаете область действия переменной, что облегчает чтение кода.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="4.3. Управляющие конструкции"></a>4.3. Управляющие конструкции
</div>

<p>Lua предоставляет небольшой и довольно традиционный набор управляющих конструкций, используя <b>if</b> для условного выполнения и <b>while</b>, <b>repeat</b> и <b>for</b> для итерирования. Все управляющие конструкции обладают явным окончанием: <b>end</b> завершает <b>if</b>, <b>for</b> и <b>while</b>, в то время как <b>until</b> завершается <b>repeat</b>.</p>

<p>Условное выполнение управляющей структуры может дать любое значение. Помните о том, что Lua рассматривает все значения, отличные от <code>false</code> и <code>nil</code>, как истинные. (В частности, Lua рассматривает ноль и пустую строку как истинные значения.)</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="4.3. if then else"></a>if then else
</div>

<p>Оператор <b>if</b> проверяет условие и выполнять свою <b>then</b>-часть или свою <b>else</b>-часть соответственно. Часть <b>else</b> является необязательной.</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;a&nbsp;<font color=FF0000>&lt;</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>end</font>

<font color=0000DF>if</font>&nbsp;a&nbsp;<font color=FF0000>&lt;</font>&nbsp;b&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;a&nbsp;<font color=0000DF>else</font>&nbsp;<font color=0000DF>return</font>&nbsp;b&nbsp;<font color=0000DF>end</font>

<font color=0000DF>if</font>&nbsp;line&nbsp;<font color=FF0000>&gt;</font>&nbsp;MAXLINES&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;showpage<font color=FF0000>()</font>
&nbsp;&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>end</font>
</pre>

<p>Для записи вложенных операторов <b>if</b> вы можете использовать <b>elseif</b>. Это аналогично <b>else</b>, за которым следует <b>if</b>, но при этом не возникает потребности во,многих <b>end</b>:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;op&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"+"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;a&nbsp;<font color=FF0000>+</font>&nbsp;b
<font color=0000DF>elseif</font>&nbsp;op&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"-"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;a&nbsp;<font color=FF0000>-</font>&nbsp;b
<font color=0000DF>elseif</font>&nbsp;op&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"*"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>*</font>b
<font color=0000DF>elseif</font>&nbsp;op&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"/"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>/</font>b
<font color=0000DF>else</font>
&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"invalid&nbsp;operation"</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Поскольку в Lua нет оператора <b>switch</b>, то такие конструкции довольно распространены.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="4.3. while"></a>while
</div>

<p>Как следует из названия, данный оператор повторяет свое тело, пока условие истинно. Как обычно, Lua сперва проверяет условие. Если оно ложно, то цикл завершается; в противном случае Lua выполняет тело цикла и повторяет данный процесс.</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>while</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>])</font>
&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="4.3. repeat"></a>repeat
</div>

<p>Как следует из названия, оператор <b>repeat-until</b> повторяет свое тело до тех пор, пока условие не станет истинным. Проверка условия осуществляется после выполнения тела цикла, поэтому тело цикла будет выполнено хотя бы один раз.</p>

<pre class="code">
<font color=008000>--&nbsp;напечатать&nbsp;первую&nbsp;непустую&nbsp;строку</font>
<font color=0000DF>repeat</font>
&nbsp;&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
<font color=0000DF>until</font>&nbsp;line&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>""</font>
<font color=0080C0>print</font><font color=FF0000>(</font>line<font color=FF0000>)</font>
</pre>

<p>В отличие от многих языков, в Lua в область действия локальных переменных входит условие цикла:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;sqr&nbsp;<font color=FF0000>=</font>&nbsp;x<font color=FF0000>/</font><font color=AC00A9>2</font>
<font color=0000DF>repeat</font>
&nbsp;&nbsp;sqr&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>sqr&nbsp;<font color=FF0000>+</font>&nbsp;x<font color=FF0000>/</font>sqr<font color=FF0000>)/</font><font color=AC00A9>2</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;<font color=0080C0>error</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>math</font><font color=FF0000>.</font>abs<font color=FF0000>(</font>sqr<font color=FF0000>^</font><font color=AC00A9>2</font>&nbsp;<font color=FF0000>-</font>&nbsp;x<font color=FF0000>)</font>
<font color=0000DF>until</font>&nbsp;<font color=0080C0>error</font>&nbsp;<font color=FF0000>&lt;</font>&nbsp;x<font color=FF0000>/</font><font color=AC00A9>10000</font>&nbsp;<font color=008000>--&nbsp;локальная&nbsp;переменная&nbsp;'error'&nbsp;видна&nbsp;здесь</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="4.3. Числовой оператор for"></a>Числовой оператор for
</div>

<p>Оператор <b>for</b> существует в двух вариантах - числовой <b>for</b> и общий <b>for</b>.
</b><br>
Числовой оператор <b>for</b> имеет следующий вид:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;var&nbsp;<font color=FF0000>=</font>&nbsp;exp1<font color=FF0000>,</font>&nbsp;exp2<font color=FF0000>,</font>&nbsp;exp3&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>something<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Этот цикл будет выполнять <i>something</i> для каждого значения <code>var</code> от <code>expl</code> до <code>ехр2</code>, используя <code>ехрЗ</code> как <i>шаг</i> для увеличения <code>var</code>. Это третье выражение (<code>ехрЗ</code>) необязательно; когда оно отсутствует, то Lua в качестве шага использует <code>1</code>. В качестве типичных примеров таких циклов можно рассмотреть</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;f<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>1</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
</pre>

<p>Если вы хотите получить цикл без верхнего предела, то вы можете использовать константу <code>math.huge</code>:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.huge</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=FF0000>(</font><font color=AC00A9>0.3</font><font color=FF0000>*</font>i<font color=FF0000>^</font><font color=AC00A9>3</font>&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>*</font>i<font color=FF0000>^</font><font color=AC00A9>2</font>&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>500</font>&nbsp;<font color=FF0000>&gt;=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>break</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>У цикла <b>for</b> есть некоторые тонкости, которые вам лучше знать, чтобы использовать его хорошо. Во-первых, все три выражения вычисляются только один раз, перед началом цикла. Например, в нашем первом примере Lua выполнит <code>f(х)</code> всего один раз. Во-вторых, управляющая переменная является локальной переменной, автоматически обьявленной для оператора <b>for</b>, и она видна только внутри цикла. Типичной ошибкой является мнение, что эта переменная все еще существует после конца цикла:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
max&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=008000>--&nbsp;возможна&nbsp;неточность!&nbsp;Здесь&nbsp;'i'&nbsp;глобальная</font>
</pre>

<p>Если вам нужно значение управляющей переменной после цикла (обычно когда вы выходите раньше времени из цикла), то вы должны сохранить ее значение в другой переменной:</p>

<pre class="code">
<font color=008000>--&nbsp;найти&nbsp;значение&nbsp;в&nbsp;списке</font>
<font color=0000DF>local</font>&nbsp;found&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>a&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>&lt;</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=008000>--&nbsp;сохранить&nbsp;значение&nbsp;'i'</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>break</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>found<font color=FF0000>)</font>
</pre>

<p>В-третьих, вы не должны никогда менять значение управляющей переменной. Эффект подобных изменений непредсказуем. Если вы хотите закончить цикл <b>for</b> для его нормального завершения, используйте <b>break</b> (как мы сделали в предыдущем примере).</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="4.3. Оператор for общего вида"></a>Оператор for общего вида
</div>

<p>Оператор for общего вида пробегает все значения, возвращаемые итерирующей функцией:</p>

<pre class="code">
<font color=008000>--&nbsp;напечатать&nbsp;все&nbsp;значения&nbsp;в&nbsp;таблице&nbsp;'t'</font>
<font color=0000DF>for</font>&nbsp;k<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>k<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Этот пример использует <code>pairs</code>, удобную итерирующую функцию для обхода всей таблицы, предоставленную базовой библиотекой Lua. На каждом шаге этого цикла <code>k</code> получает индекс, a <code>v</code> -- значение, связанное с этим индексом.</p>

<p>Несмотря на свою внешнюю простоту, оператор <b>for</b> общего вида - это очень мощная конструкция языка. С подходящими итераторами вы можете обойти практически все, что угодно, в легкочитаемой форме. Стандартные библиотеки предоставляют несколько итераторов, позволяющих нам перебирать строки файла (<code>io. lines</code>), пары из таблицы (<code>pairs</code>), элементы последовательности (<code>ipairs</code>), слова внутри строки (<code>string.gmatch</code>) и т. д.</p>

<p>Конечно, мы можем писать и свои собственные итераторы. Хотя использование оператора <b>for</b> в общей форме легко, задача написания функции-итератора имеет свои тонкости; мы рассмотрим эту тему позже, в <a href="#Глава 7. Итераторы и обобщенный for">главе 7</a>.</p>

<p>Оператор цикла общего вида имеет две общие особенности с числовым оператором цикла. Переменные цикла локальны для тела цикла, и вы никогда не должны записывать в них какие-либо значения.</p>

<p>Рассмотрим более конкретный пример использования оператора <b>for</b> общего вида. Допустим, у вас есть таблица с названиями дней недели:</p>

<pre class="code">days&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"Sunday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Monday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Tuesday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Wednesday"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8888CC>"Thursday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Friday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Saturday"</font><font color=FF0000>}</font></pre>

<p>Теперь вы хотите перевести название дня в его положение в неделе. Вы можете обойти всю таблицу в поисках заданного имени. Однако, как вы скоро узнаете, вам редко понадобится искать в Lua. Более эффективным подходом будет построение обратной таблицы, например <code>revDays</code>, в которой названия дней являются индексами, а значениями являются номера дней. Эта таблица будет выглядеть следующим образом:</p>

<pre class="code">
revDays&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{[</font><font color=8888CC>"Sunday"</font><font color=FF0000>]</font>&nbsp;&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=8888CC>"Monday"</font><font color=FF0000>]</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"Tuesday"</font><font color=FF0000>]</font>&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>3</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=8888CC>"Wednesday"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"Thursday"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=8888CC>"Friday"</font><font color=FF0000>]</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>6</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"Saturday"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>7</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>}</font>
</pre>

<p>Тогда все, что вам нужно для того, чтобы найти номер дня - это обратиться к этой обратной таблице:</p>

<pre class="code">
x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Tuesday"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>revDays<font color=FF0000>[</font>x<font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;3</font>
</pre>

<p>Конечно, не нужно явно задавать эту обратную таблицу. Мы можем построить ее автоматически из исходной:</p>

<pre class="code">
revDays&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;k<font color=FF0000>,</font>v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>days<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;revDays<font color=FF0000>[</font>v<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;k
<font color=0000DF>end</font>
</pre>

<p>Этот цикл выполнит присваивание для каждого элемента <code>days</code>, где переменная <code>k</code> получает ключ (1, 2, ...), a <code>v</code> получает значение (<code>"Sunday", "Monday", ...</code>).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="4.4. break, return и goto"></a>4.4. break, return и goto
</div>

<p>Операторы <b>break</b> и <b>return</b> позволят нам выпрыгнуть прямо из блока. Оператор <b>goto</b> позволяет нам перепрыгнуть практически в любое место функции.</p>

<p>Мы используем оператор <b>break</b> для завершения цикла. Этот оператор прерывает внутренний цикл (<b>for</b>, <b>repeat</b> или <b>while</b>), содержащий его. Также он может использоваться для возврата из функции, поэтому вам необязательно использовать оператор <b>return</b>, если вы не возвращаете никакого значения.</p>

<p>Из синтаксических соображений оператор <b>return</b> может быть только последним оператором блока: другими словами, либо последним оператором, либо прямо перед <b>end</b>, <b>else</b> или <b>until</b>. В следующем примере <b>return</b> - последний оператор блока <b>then</b>.</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>while</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;v&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;i&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>end</font>
</pre>

<p>Обычно это именно те места, где мы используем <b>return</b>, поскольку любые другие операторы, следующие за ним, никогда бы не выполнились. Иногда на самом деле бывает полезно написать <b>return</b> в середине блока. Например, вы можете отлаживать функцию и хотите избежать ее выполнения. В подобных случаях вы можете использовать явный блок <b>do</b> вокруг оператора <b>return</b>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=008000>--&lt;&lt;&nbsp;SYNTAX&nbsp;ERROR</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;'return'&nbsp;is&nbsp;the&nbsp;last&nbsp;statement&nbsp;in&nbsp;the&nbsp;next&nbsp;block</font>
&nbsp;&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>end</font>&nbsp;<font color=008000>--&nbsp;OK</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>other&nbsp;statements<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Оператор <b>goto</b> переводит выполнение программы к соответствующей метке. Насчет <b>goto</b> были длинные обсуждения, некоторые люди даже сейчас считают, что они вредны для программирования и должны быть исключены из языков программирования. Однако многие языки предлагают подобный оператор, и у них есть для этого повод. Эти операторы представляют собой мощный механизм, который, будучи аккуратно использованным, способен улучшить качество вашего кода.</p>

<p>В Lua синтаксис для оператора <b>goto</b> вполне традиционный: это зарезервированное слово <b>goto</b>, за которым следует имя метки, которое может быть любым допустимым идентификатором. Синтаксис для метки, однако, более сложный: она состоит из двух двоеточий, за которыми следует имя метки, за которыми следуют еще два двоеточия, например <code>::name::</code>. Эта сложность намеренная, ее цель - заставить программиста дважды подумать, прежде чем использовать <b>goto</b>.</p>

<p>Lua накладывает некоторые ограничения на то, куда вы можете перескочить при помощи <b>goto</b>. Во-первых, метки следуют обычным правилам видимости, поэтому вы не можете прыгнуть прямо внутрь блока (поскольку метка внутри блока невидима снаружи его). Во-вторых, вы не можете выпрыгнуть из функции. (Обратите внимание, что первое правило исключает возможность прыгнуть <i>внутрь</i> функции.) В-третьих, вы не можете прыгнуть внутрь области действия локальной переменной.</p>

<p>Типичным и хорошо используемым применением оператора <b>goto</b> является эмулирование некоторой конструкции, которую вы узнали из другого языка, но которая отсутствует в Lua, например <b>continue</b>, многоуровневый <b>break</b>, <b>redo</b> и т. п. Оператор <b>continue</b> - это просто переход на метку в конце цикла, оператор <b>redo</b> перепрыгивает к началу блока:</p>

<pre class="code">
<font color=0000DF>while</font>&nbsp;some_condition&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;::redo::
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;some_other_condition&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;continue
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=0000DF>if</font>&nbsp;yet_another_condition&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;redo
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
&nbsp;&nbsp;::continue::
<font color=0000DF>end</font>
</pre>

<p>Полезным нюансом в спецификациях Lua является то, что область действия локальной переменной заканчивается на первом <i>непустом</i> операторе блока, где переменная определенаю Метки считаются пустыми операторами. Для того чтобы увидеть полезность этого, рассмотрим следующий фрагмент кода:</p>

<pre class="code">
<font color=0000DF>while</font>&nbsp;some_condition&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;some_other_condition&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;continue&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;var&nbsp;<font color=FF0000>=</font>&nbsp;something
&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
&nbsp;&nbsp;::continue::
<font color=0000DF>end</font>
</pre>

<p>Вы можете подумать, что этот оператор <b>goto</b> перепрыгивает прямо в область действия переменной <code>var</code>. Однако метка <code>continue</code> находится после последнего непустого оператора блока, и поэтому не в области действия переменной <code>var</code>.</p>

<p>Оператор <b>goto</b> также полезен при написании конечных автоматов. В качестве примера <a href="#листинг 4.1">листинг 4.1</a> является примером программы, проверяющей, содержит ли ее ввод четное количество нулей. Существуют более удачные способы написания этой программы, но данный подход весьма полезен, если вы хотите автоматически перевести конечный автомат в код на Lua (подумайте об автоматической генерации кода).</p>

<p>В качестве другого примера рассмотрим простую игру в лабиринт. Лабиринт содержит несколько комнат, в каждой до четырех дверей: север, юг, восток и запад. На каждом шаге пользователь вводит направление движения. Если в этом направлении есть дверь, то пользователь входит в соответствующую комнату; иначе программа печатает предупреждение. Целью является дойти от начальной комнаты до конечной комнаты.</p>
 
<p>Эта игра является типичным автоматом, где текущая комната является состоянием. Мы можем реализовать эту игру, используя один блок для каждой комнаты и оператор <b>goto</b> для перехода из одной комнаты в другую. <a href="#листинг 4.2">Листинг 4.2</a> показывает, как можно написать простейший лабиринт из четырех комнат.</p>

<p>Для этой простой игры вы можете решить, что программа, управляемая данными, когда вы описываете комнаты и перемещения при помощи таблиц, является более удачным решением. Однако если в каждой комнате нас ждут свои особенности, то этот подход оказывается вполне удачным.</p>
 
<p><a name="листинг 4.1"></a><b class="sect">Листинг 4.1</b>. Пример конечного автомата с использованием <b>goto</b></p>

<pre class="code">
::s1::
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(</font><font color=AC00A9>1</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;c&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>'0'</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;s2
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;c&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0080C0>print</font><font color=8888CC>'ok'</font><font color=FF0000>;</font>&nbsp;<font color=0000DF>return</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=0000DF>goto</font>&nbsp;s1
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
::s2::
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(</font><font color=AC00A9>1</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;c&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>'0'</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;s1
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;c&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0080C0>print</font><font color=8888CC>'not&nbsp;ok'</font><font color=FF0000>;</font>&nbsp;<font color=0000DF>return</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=0000DF>goto</font>&nbsp;s2
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
<font color=0000DF>goto</font>&nbsp;s1
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="4. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 4.1.</b><br>
Большинство языков с С-подобным синтаксисом не предлагает конструкцию <b>elseif</b>. Почему эта конструкция больше нужна в Lua, чем в других языках?</p>

<hr color="#99CCFF">

<p><b>Упражнение 4.2.</b><br>
Напишите четыре различных способа реализовать безусловный цикл в Lua. Какой из них вам больше нравится?</p>

<hr color="#99CCFF">

<p><b>Упражнение 4.3.</b><br>
Многие считают, что <b>repeat-until</b> используется редко и поэтому не должен присутствовать в минималистических языках вроде Lua. Чты вы думаете об этом?</p>

<hr color="#99CCFF">

<p><b>Упражнение 4.4.</b><br>
Перепишите конечный автомат из <a href="#листинг 4.2">листинга 4.2</a> без использования <b>goto</b>.</p>

<hr color="#99CCFF">

<p><b>Упражнение 4.5.</b><br>
Можете ли вы обьяснить, почему в Lua присутствует ограничение на то, что нельзя выпрыгнуть из функции? (<i>Подсказка</i>: как бы вы реализовали данную возможность?)</p>

<hr color="#99CCFF">

<p><b>Упражнение 4.6.</b><br>
Предполагая, что <b>goto</b> может выпрыгнуть из функции, обьясните, что программа на <a href="#листинг 4.3">листинге 4.3</a> должна делать. (Попытайтесь рассуждать о метке с использованием тех лее самых правил, которые используются для описания области действия локальных переменных.)</p>

<hr color="#99CCFF">

<p><a name="листинг 4.2"></a><b class="sect">Листинг 4.2</b>. Игра в лабиринт</p>

<pre class="code">
<font color=0000DF>goto</font>&nbsp;room1&nbsp;<font color=008000>--&nbsp;начальная&nbsp;комната</font>
::room1::
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;move&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;move&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"south"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;room3
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;move&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"east"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;room2
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"недопустимый&nbsp;ход"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>goto</font>&nbsp;room1&nbsp;<font color=008000>--&nbsp;остаемся&nbsp;в&nbsp;этой&nbsp;же&nbsp;комнате</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
::room2::
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;move&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;move&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"south"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;room4
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;move&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"west"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;room1
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"недопустимый&nbsp;ход"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>goto</font>&nbsp;room2
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
::room3::
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;move&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;move&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"north"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;room1
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;move&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"east"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>goto</font>&nbsp;room4
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"недопустимый&nbsp;ход"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>goto</font>&nbsp;room3
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
::room4::
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"Поздравляем,&nbsp;вы&nbsp;выиграли!"</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p><a name="листинг 4.3"></a><b class="sect">Листинг 4.3</b>. Странное (и неверное) использование <b>goto</b></p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;getlabel&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>goto</font>&nbsp;L1&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;::L1::
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>end</font>
<font color=0000DF>function</font>&nbsp;f&nbsp;<font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>==</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;getlabel<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;f<font color=FF0000>(</font>n&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;res
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
x&nbsp;<font color=FF0000>=</font>&nbsp;f<font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>)</font>
x<font color=FF0000>()</font>
</pre>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 5. Функции"></a>Глава 5. Функции
</div>

<p>Функции являются главным механизмом абстракции операторов и выражений в Lua. Функции могут выполнять определенное задание (в других языках это часто называется <i>procedure</i> или <i>subroutine</i>) или вычислить и вернуть значения. В первом случае мы используем вызов функции как оператор, во втором случае мы используем его как выражение:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>8</font><font color=FF0000>*</font><font color=AC00A9>9</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>9</font><font color=FF0000>/</font><font color=AC00A9>8</font><font color=FF0000>)</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.sin</font><font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=8000FF>math.cos</font><font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.date</font><font color=FF0000>())</font>
</pre>

<p>В обоих случаях список аргументов заключен в круглые скобки, обозначающие вызов; если у функции нет аргументов, то мы все равно должны написать <code>()</code> для обозначения вызова функции. Существует специальное исключение из этого правила: если у функции всего один аргумент и этот аргумент, либо литерал (строка символов), либо конструктор таблицы, то круглые скобки необязательны:</p>

<pre class="code">
<font color=0080C0>print</font>&nbsp;<font color=8888CC>"Hello&nbsp;World"</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"Hello&nbsp;World"</font><font color=FF0000>)</font>
<font color=0080C0>dofile</font>&nbsp;<font color=8888CC>'a.lua'</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>dofile</font>&nbsp;<font color=FF0000>(</font><font color=8888CC>'a.lua'</font><font color=FF0000>)</font>
<font color=0080C0>print</font>&nbsp;<font color=8888CC>[[a&nbsp;multi-line&nbsp;</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font>&nbsp;<font color=FF0000>(</font><font color=8888CC>[[a&nbsp;multi-line&nbsp;</font>
<font color=8888CC>&nbsp;&nbsp;message]]</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8888CC>&nbsp;&nbsp;&nbsp;&nbsp;message]]</font><font color=FF0000>)</font>
f<font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>20</font><font color=FF0000>}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;f<font color=FF0000>({</font>x<font color=FF0000>=</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>20</font><font color=FF0000>})</font>
<font color=0080C0>type</font><font color=FF0000>{}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>type</font><font color=FF0000>({})</font>
</pre>

<p>Lua также предлагает специальный синтаксис для обьектно-ориентированных вызовов, оператор двоеточие. Выражение вроде <code>о:foo(х)</code> -- это просто способ записать <code>о.foo(о, х)</code>, то есть вызвать <code>о.foo</code>, добавляя о как дополнительный аргумент. В <a href="#Глава 16. Обьектно-ориентированное программирование">главе 16</a> мы обсудим подобные вызовы (и обьектно-ориентированное программирование) более подробно.</p>

<p>Программа на Lua может использовать функции, написанные как на Lua, так и на С (или любом другом языке, используемом приложением). Например, все функции из стандартной библиотеки Lua написаны на С. Однако при вызове функции нет никакой разницы между функциями, написанными на Lua, и функциями, написанными на С.</p>

<p>Как мы видели в других примерах, определение функции следует традиционному синтаксису, например как показано ниже:</p>

<pre class="code">
<font color=008000>--&nbsp;сложить&nbsp;элементы&nbsp;последовательности&nbsp;'а'</font>
<font color=0000DF>function</font>&nbsp;add&nbsp;<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;sum&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>a&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;<font color=FF0000>=</font>&nbsp;sum&nbsp;<font color=FF0000>+</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;sum
<font color=0000DF>end</font>
</pre>

<p>В этом синтаксисе определение функции содержит <i>имя</i> (в примере <code>add</code>), список <i>параметров</i> и <i>тело</i>, которое является списком операторов.</p>

<p>Параметры работают как локальные переменные, проинициализированные значениями аргументов, переданных при вызове функции. Вы можете вызвать функцию с количеством аргументов, отличающимся от ее списка параметров. Lua приведет число аргументов к числу параметров так лее, как это делается во множественном присваивании: лишние аргументы отбрасываются, вместо недостающих добавляется <b>nil</b>. Например, рассмотрим следующую функцию:</p>

<pre class="code"><font color=0000DF>function</font>&nbsp;f&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font></pre>

<p>Она обладает таким поведением:</p>

<pre class="code">
f<font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;3&nbsp;nil</font>
f<font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;3&nbsp;4</font>
f<font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;3&nbsp;4&nbsp;(5&nbsp;отбрасывается)</font>
</pre>

<p>Хотя подобное поведение может привести к ошибкам (легко обнаруживаемым во время выполнения), оно также полезно, особенно для аргументов по умолчанию. Например, рассмотрим следующую функцию, увеличивающую глобальный счетчик:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;incCount&nbsp;<font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;n&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;count&nbsp;<font color=FF0000>+</font>&nbsp;n
<font color=0000DF>end</font>
</pre>

<p>У этой функции есть один параметр по умолчанию; если мы вызовем ее <code>incCount()</code> без аргументов, то она увеличит <code>count</code> на единицу. Когда вы вызываете <code>incCount()</code>, Lua сперва инициализирует <code>n</code> значением <b>nil</b>; оператор <code>or</code> возвращает свой второй аргумент, и в результате Lua присваивает переменной <code>n</code> значение <code>1</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="5.1. Множественные результаты"></a>5.1. Множественные результаты
</div>

<p>Мало распространенной, но тем не менее очень удобной особенностью Lua является то, что функция может вернуть несколько значений. Некоторые предопределенные функции в Lua возвращают несколько значений. В качестве примера можно взять функцию <code>string.find</code>, которая ищет шаблон в строке. Эта функция возвращает два индекса, когда находит шаблон: индекс начала шаблона в строке и индекс конца шаблона. Множественное присваивание позволяет программе получить оба результата:</p>

<pre class="code">
s<font color=FF0000>,</font>&nbsp;e&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font><font color=8888CC>"hello&nbsp;Lua&nbsp;users"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Lua"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;e<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;7&nbsp;9</font>
</pre>

<p>(Обратите внимание, что индекс первого символа строки равен <code>1</code>.)</p>

<p>Функции, которые мы сами пишем, также могут возвращать сразу несколько значений, просто перечисляя их после слова <b>return</b>. Например, функция, которая ищет максимальный элемент в последовательности, может вернуть сразу и сам максимальный элемент, и его индекс:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;maximum&nbsp;<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;mi&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;индекс&nbsp;максимального&nbsp;элемента</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;m&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font>mi<font color=FF0000>]</font>&nbsp;&nbsp;<font color=008000>--&nbsp;максимальное&nbsp;значение</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>a&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>&gt;</font>&nbsp;m&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mi&nbsp;<font color=FF0000>=</font>&nbsp;i<font color=FF0000>;</font>&nbsp;m&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;m<font color=FF0000>,</font>&nbsp;mi
<font color=0000DF>end</font>

<font color=0080C0>print</font><font color=FF0000>(</font>maximum<font color=FF0000>({</font><font color=AC00A9>8</font><font color=FF0000>,</font><font color=AC00A9>10</font><font color=FF0000>,</font><font color=AC00A9>23</font><font color=FF0000>,</font><font color=AC00A9>12</font><font color=FF0000>,</font><font color=AC00A9>5</font><font color=FF0000>}))</font>&nbsp;<font color=008000>--&gt;&nbsp;23&nbsp;3</font>
</pre>

<p>Lua всегда приводит количество значений, возвращенных функцией, к обстоятельствам ее вызова. Когда мы вызываем функцию как оператор, то Lua отбрасывает все возвращенные значения. Когда мы используем вызов функции в выражении, то Lua сохраняет только первое значение. Мы получим все значения, только когда вызов функции является последним (или единственным) выражением в списке выражений. В Lua эти списки встречаются в четырех конструкциях: множественное присваивание, аргументы для вызова функции, конструктор таблицы и оператор <b>return</b>. Чтобы проиллюстрировать все эти случаи, мы рассмоторим следующие определения функций:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo0&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>end</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;ничего&nbsp;не&nbsp;возвращает</font>
<font color=0000DF>function</font>&nbsp;foo1&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8888CC>"a"</font>&nbsp;<font color=0000DF>end</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;возвращает&nbsp;1&nbsp;значение</font>
<font color=0000DF>function</font>&nbsp;foo2&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8888CC>"a"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"b"</font>&nbsp;<font color=0000DF>end</font>&nbsp;<font color=008000>--&nbsp;возвращает&nbsp;2&nbsp;значения</font>
</pre>

<p>В множественном присваивании вызов функции как последнее (или единственное) выражение использует столько результатов, сколько нужно для соответствия списку переменных:</p>

<pre class="code">
x<font color=FF0000>,</font>y&nbsp;<font color=FF0000>=</font>&nbsp;foo2<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;x="a",&nbsp;y="b"</font>
x&nbsp;<font color=FF0000>=</font>&nbsp;foo2<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;x="a",&nbsp;"b"&nbsp;отбрасывается</font>
x<font color=FF0000>,</font>y<font color=FF0000>,</font>z&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>,</font>foo2<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;x=10,&nbsp;y="a",&nbsp;z="b"</font>
</pre>

<p>Если функция не возвращает значения или возвращает, но не так много, как требуется, то в качестве недостающих значений используется <b>nil</b>:</p>

<pre class="code">
x<font color=FF0000>,</font>y&nbsp;<font color=FF0000>=</font>&nbsp;foo0<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;x=nil,&nbsp;y=nil</font>
x<font color=FF0000>,</font>y&nbsp;<font color=FF0000>=</font>&nbsp;foo1<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;x="a",&nbsp;y=nil</font>
x<font color=FF0000>,</font>y<font color=FF0000>,</font>z&nbsp;<font color=FF0000>=</font>&nbsp;foo2<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;x="a",&nbsp;y="b",&nbsp;z=nil</font>
</pre>

<p>Вызов функции, который не является последним элементом в списке, дает ровно одно значение:</p>

<pre class="code">
x<font color=FF0000>,</font>y&nbsp;<font color=FF0000>=</font>&nbsp;foo2<font color=FF0000>(),</font>&nbsp;<font color=AC00A9>20</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;x="a",&nbsp;y=20</font>
x<font color=FF0000>,</font>y&nbsp;<font color=FF0000>=</font>&nbsp;foo0<font color=FF0000>(),</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>30</font>&nbsp;<font color=008000>--&nbsp;x=nil,&nbsp;y=20,&nbsp;30&nbsp;отбрасывается</font>
</pre>

<p>Когда вызов функции является последним (или единственным) аргументом другого вызова, то все результаты первого вызова идут как аргументы на вход второго вызова. Мы уже видели примеры этой конструкции с функцией <code>print</code>. Поскольку функция <code>print</code> может получать переменное число аргументов, оператор <code>print(g())</code> печатает все значения, возвращенные функцией <code>g</code>.</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>foo0<font color=FF0000>())</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;</font>
<font color=0080C0>print</font><font color=FF0000>(</font>foo1<font color=FF0000>())</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;a</font>
<font color=0080C0>print</font><font color=FF0000>(</font>foo2<font color=FF0000>())</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;a&nbsp;b</font>
<font color=0080C0>print</font><font color=FF0000>(</font>foo2<font color=FF0000>(),</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;a&nbsp;1</font>
<font color=0080C0>print</font><font color=FF0000>(</font>foo2<font color=FF0000>()</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"x"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;ax&nbsp;(смотрите&nbsp;далее)</font>
</pre>

<p>Когда вызов функции <code>foo2</code> оказывается внутри выражения, Lua приводит число возвращенных значений к одному, поэтому в последней строке конкатенация использует только "<code>а</code>".</p>

<p>Если мы запишем <code>f(g(х))</code> и у <code>f</code> фиксированное число аргументов, то Lua приводит число возвращенных значений к числу аргументов <code>f</code>, как мы уже видели ранее.</p>

<p>Конструктор таблицы также использует все значения, возвращенные функцией, без каких-либо изменений:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>foo0<font color=FF0000>()}</font>&nbsp;<font color=008000>--&nbsp;t&nbsp;=&nbsp;{}&nbsp;(пустая&nbsp;таблица)</font>
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>foo1<font color=FF0000>()}</font>&nbsp;<font color=008000>--&nbsp;t&nbsp;=&nbsp;{"a"}</font>
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>foo2<font color=FF0000>()}</font>&nbsp;<font color=008000>--&nbsp;t&nbsp;=&nbsp;{"a",&nbsp;"b"}</font>
</pre>

<p>Как всегда, это поведение встречается, только если вызов является последним выражением в списке. Вызовы в любых других местах дают ровно по одному значению:</p>

<pre class="code">t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>foo0<font color=FF0000>(),</font>&nbsp;foo2<font color=FF0000>(),</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>}</font>&nbsp;<font color=008000>--&nbsp;t[1]&nbsp;=&nbsp;nil,&nbsp;t[2]&nbsp;=&nbsp;"a",&nbsp;t[3]&nbsp;=&nbsp;4</font></pre>

<p>Наконец, оператор <code>return f()</code> возвращает все значения, которые вернула <code>f</code>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font>i<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;i&nbsp;<font color=FF0000>==</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;foo0<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;i&nbsp;<font color=FF0000>==</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;foo1<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;i&nbsp;<font color=FF0000>==</font>&nbsp;<font color=AC00A9>2</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;foo2<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>foo<font color=FF0000>(</font><font color=AC00A9>1</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;a</font>
<font color=0080C0>print</font><font color=FF0000>(</font>foo<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;a&nbsp;b</font>
<font color=0080C0>print</font><font color=FF0000>(</font>foo<font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&nbsp;(нет&nbsp;значений)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>foo<font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&nbsp;(нет&nbsp;значений)</font>
</pre>

<p>Вы можете «заставить» вызов вернуть только одно значение, заключив его в дополнительную пару круглых скобок:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>((</font>foo0<font color=FF0000>()))</font>&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
<font color=0080C0>print</font><font color=FF0000>((</font>foo1<font color=FF0000>()))</font>&nbsp;<font color=008000>--&gt;&nbsp;a</font>
<font color=0080C0>print</font><font color=FF0000>((</font>foo2<font color=FF0000>()))</font>&nbsp;<font color=008000>--&gt;&nbsp;a</font>
</pre>

<p>Будьте внимательны: оператор <b>return</b> не требует скобок вокруг возвращаемого значения. Поэтому выражение вроде <code>return(f(х))</code> всегда возвращает ровно одно значение, вне зависимости от того, сколько значений возвращает функция <code>f</code>. Иногда это именно то, что вам нужно, иногда нет.</p>

<p>Специальной функцией, возвращающей несколько значений, является <code>table.unpack</code>. Она получает на вход массив и возвращает все элементы этого массива, начиная с <code>1</code>:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>table</font><font color=FF0000>.</font>unpack<font color=FF0000>{</font><font color=AC00A9>10</font><font color=FF0000>,</font><font color=AC00A9>20</font><font color=FF0000>,</font><font color=AC00A9>30</font><font color=FF0000>})</font>&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;20&nbsp;30</font>
a<font color=FF0000>,</font>b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>table</font><font color=FF0000>.</font>unpack<font color=FF0000>{</font><font color=AC00A9>10</font><font color=FF0000>,</font><font color=AC00A9>20</font><font color=FF0000>,</font><font color=AC00A9>30</font><font color=FF0000>}</font>&nbsp;&nbsp;<font color=008000>--&nbsp;a=10,&nbsp;b=20,&nbsp;30&nbsp;отбрасывается</font>
</pre>

<p>Важным использованием <code>unpack</code> является обобщенный механизм вызова функции. Обобщенный механизм позволяет вам вызвать любую функцию с любыми аргументами динамически. В ANSI С, например, не существует способа построить обобщенный вызов. Вы можете обьявить функцию, которая получает переменное число аргументов (при помощи <code>stdarg.h</code>), и вы можете вызывать различные функции, используя указатели на функции. Однако вы не можете вызвать функцию с переменным числом аргументов: каждый раз, когда вы пишете на С, у вас фиксированное число аргументов, и каждый аргумент имеет фиксированный тип. В Lua если вы хотите вызвать функцию <code>f</code> с переменным числом аргументов из массива <code>а</code>, то можете просто написать следующее:</p>

<pre class="code">f<font color=FF0000>(</font><font color=0080C0>table</font><font color=FF0000>.</font>unpack<font color=FF0000>(</font>a<font color=FF0000>))</font></pre>

<p>Вызов функции <code>unpack</code> возвращает все значения из <code>а</code>, которые становятся аргументами вызова <code>f</code>. Например, рассмотрим следующий вызов:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.find</font><font color=FF0000>(</font><font color=8888CC>"hello"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"ll"</font><font color=FF0000>))</font></pre>

<p>Вы можете динамически построить эквивалентный вызов при помощи следующего кода:</p>

<pre class="code">
f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"hello"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"ll"</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>f<font color=FF0000>(</font><font color=0080C0>table</font><font color=FF0000>.</font>unpack<font color=FF0000>(</font>a<font color=FF0000>)))</font>
</pre>

<p>Обычно <code>unpack</code> использует оператор длины, для того чтобы узнать, сколько элементов следует вернуть, поэтому он работает только с последовательностями. Если нужно, то его можно явно ограничить:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>table</font><font color=FF0000>.</font>unpack<font color=FF0000>({</font><font color=8888CC>"Sun"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Mon"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Tue"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Wed"</font><font color=FF0000>},</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>3</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;Mon&nbsp;Tue</font></pre>

<p>Хотя функция <code>unpack</code> написана на С, мы можем записать ее на Lua, используя рекурсию:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;<font color=0080C0>unpack</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;i<font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;n&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>#</font>t
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;i&nbsp;<font color=FF0000><=</font>&nbsp;n&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;t<font color=FF0000>[</font>i<font color=FF0000>],</font>&nbsp;<font color=0080C0>unpack</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Первый раз, когда мы вызываем ее с единственным аргументом, в <code>i</code> записывается <code>1</code>, а в <code>n</code> записывается длина последовательности. Затем функция возвращает <code>t[l]</code> вместе с всеми результатами <code>unpack(t, 2, n)</code>, что, в свою очередь, возвращает <code>t[2]</code> и все результаты вызова <code>unpack(t, 3, п)</code> ит. д., останавливаясь после <code>n</code> элементов.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="5.2. Функции с переменным числом аргументов"></a>5.2. Функции с переменным числом аргументов
</div>

<p>Функция в Lua может иметь произвольное число аргументов (<i>variadic</i>). Например, мы уже вызывали функцию <code>print</code> с одним, двумя и большим числом аргументов. Хотя <code>print</code> определена в С, мы и на Lua можем писать функции с переменным числом аргументов.</p>

<p>В качестве следующего примера функция ниже возвращает сумму всех своих аргументов:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;add&nbsp;<font color=FF0000>(...)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>ipairs</font><font color=FF0000>{...}</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;s&nbsp;<font color=FF0000>+</font>&nbsp;v
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s
<font color=0000DF>end</font>

<font color=0080C0>print</font><font color=FF0000>(</font>add<font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>25</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>12</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;54</font>
</pre>

<p>Три точки (<code>...</code>) в списке параметров обозначают, что эта функция имеет переменное число аргументов. Когда мы вызываем такую функцию, Lua собирает все ее аргументы в список. Мы называем эти собранные аргументы <i>дополнительными аргументами</i> функции. Функция может получить доступ к своим дополнительным опять при помощи трех точек, теперь уже как в качестве выражения. В нашем примере выражение <code>{...}</code> дает массив со всеми собранными аргументами. Функция перебирает элементы этого массива для того, чтобы найти их сумму.</p>

<p>Мы называем выражение <code>...</code> выражением с <i>переменным числом аргументов</i> (<i>vararg expression</i>). Оно ведет себя как функция, возвращающая много значений, возвращая все дополнительные аргументы текущей функции. Например, команда <code>print(...)</code> напечатает все дополнительные аргументы текущей функции. Аналогично следующая команда создаст две локальные переменные со значениями первых двух дополнительных аргументов (или <b>nil</b>, если таких аргументов нет).</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;a<font color=FF0000>,</font>&nbsp;b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>...</font></pre>

<p>На самом деле мы можем имитировать стандартный механизм передачи параметров в Lua, переводя следующую конструкцию</p>

<pre class="code"><font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c<font color=FF0000>)</font></pre>

<p>к виду</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(...)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>...</font>
</pre>

<p>Тем, кому нравится механизм передачи параметров в Perl, это понравится.</b><br>
Функция, показанная ниже, просто возвращает все переданные аргументы:</p>

<pre class="code"><font color=0000DF>function</font>&nbsp;id&nbsp;<font color=FF0000>(...)</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>...</font>&nbsp;<font color=0000DF>end</font></pre>

<p>Следующая функция ведет себя так же, как и <code>foo</code>, за исключением того, что перед ее вызовом она печатает сообщение со всеми переданными аргументами:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo1&nbsp;<font color=FF0000>(...)</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"calling&nbsp;foo:"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>...)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;foo<font color=FF0000>(...)</font>
<font color=0000DF>end</font>
</pre>

<p>Это довольно полезный трюк для отслеживания всех вызовов к заданной функции.</p>

<p>Давайте рассмотрим еще один полезный пример. Lua предоставляет отдельные функции для форматирования текста (<code>string.format</code>) и для записи текста (<code>io.write</code>). Довольно просто обьединить эти две функции в одну функцию с переменным числом аргументов:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;fwrite&nbsp;<font color=FF0000>(</font>fmt<font color=FF0000>,</font>&nbsp;<font color=FF0000>...)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font>fmt<font color=FF0000>,</font>&nbsp;<font color=FF0000>...))</font>
<font color=0000DF>end</font>
</pre>

<p>Обратите внимание на присутствие параметра <code>fmt</code> перед точками. Функции с переменным числом аргументов могут иметь любое количество фиксированных параметров перед частью с переменным числом параметров. Lua присваивает первые значения этим переменным. Остальные (если есть) идут как дополнительные параметры. Ниже мы покажем несколько примеров вызовов и соответствующих параметров:</p>

<pre class="code">
ВЫЗОВ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ПАРАМЕТРЫ
fwrite<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font><font color=FF0000>,</font>&nbsp;нет&nbsp;дополнительных&nbsp;параметров
fwrite<font color=FF0000>(</font><font color=8888CC>"a"</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a"</font><font color=FF0000>,</font>&nbsp;нет&nbsp;дополнительных&nbsp;параметров
fwrite<font color=FF0000>(</font><font color=8888CC>"%d%d"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;fmt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"%d%d"</font><font color=FF0000>,</font>&nbsp;дополнительные&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>4</font>&nbsp;и&nbsp;<font color=AC00A9>5</font>
</pre>

<p>(Обратите внимание, что вызов <code>fwrite()</code> приведет к ошибке, поскольку <code>string.format</code> требует строку как свой первый аргумент.)</p>

<p>Для обхода всех дополнительных параметров функция может использовать выражение <code>{...}</code> для того, чтобы собрать их всех в таблицу, как мы это сделали в определении функции <code>add</code>.</p>

<p>В редких случаях, когда переданные аргументы могут принимать значение <b>nil</b>, таблица, созданная при помощи <code>{...}</code>, не будет настоящей последовательностью. Например, не существует способа для того, чтобы по этой таблице узнать, были ли в конце списка аргументов <b>nil</b>'ы. Для этих случаев Lua предлагает функцию <code>table.pack</code> (появилась только в Lua 5.2). Эта функция получает произвольное число аргументов и возвращает новую таблицу, содержащую все свои аргументы, как и <code>{...}</code>, но в этой таблице будет дополнительное поле <code>n</code>, содержащее полное число ее аргументов. Следующая функция использует <code>table.pack</code> для того, чтобы среди ее аргументов были значения <b>nil</b>.</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;nonils&nbsp;<font color=FF0000>(...)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;arg&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>table.pack</font><font color=FF0000>(...)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;arg<font color=FF0000>.</font>n&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;arg<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>false</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>true</font>
<font color=0000DF>end</font>

<font color=0080C0>print</font><font color=FF0000>(</font>nonils<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font><font color=AC00A9>3</font><font color=FF0000>,</font><font color=0000DF>nil</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;false</font>
<font color=0080C0>print</font><font color=FF0000>(</font>nonils<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font><font color=AC00A9>3</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font>nonils<font color=FF0000>())</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font>nonils<font color=FF0000>(</font><font color=0000DF>nil</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;false</font>
</pre>

<p>Запомните, однако, что <code>{...}</code> быстрее и чище, чем <code>table.pack</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="5.3. Именованные аргументы"></a>5.3. Именованные аргументы
</div>

<p>Механизм передачи параметров в Lua является <i>позиционным</i>: когда мы вызываем функцию, то соответствие между аргументами и формальными параметрами осуществляется по их положению. Первый аргумент дает значение первому параметру и т. д. Иногда, однако, полезно указать параметр по имени. Для того чтобы проиллюстрировать это, давайте рассмотрим функцию <code>os.rename</code> (из библиотеки <code>os</code>), которая переименовывает файл. Довольно часто мы забываем, какое имя идет первым, новое или старое; поэтому мы можем захотеть переопределить эту функцию так, чтобы она получала два именованных параметра:</p>

<pre class="code">
<font color=008000>--&nbsp;неверно</font>
rename<font color=FF0000>(</font>old<font color=FF0000>=</font><font color=8888CC>"temp.lua"</font><font color=FF0000>,</font>&nbsp;new<font color=FF0000>=</font><font color=8888CC>"temp1.lua"</font><font color=FF0000>)</font>
</pre>

<p>В Lua нет непосредственной поддержки для этого синтаксиса, но мы можем добиться требуемого эффекта путем небольшого синтаксического изменения. Идея заключается в том, чтобы собрать все аргументы в таблицу и использовать эту таблицу как единственный аргумент функции. Специальный синтаксис, который Lua предоставляет для вызова функции, с конструктором таблицы как единственным аргументом, поможет нам добиться этого:</p>

<pre class="code">rename<font color=FF0000>{</font>old<font color=FF0000>=</font><font color=8888CC>"temp.lua"</font><font color=FF0000>,</font>&nbsp;new<font color=FF0000>=</font><font color=8888CC>"temp1.lua"</font><font color=FF0000>}</font></pre>

<p>Соответственно, мы переопределяем функцию rename только с одним параметром и получаем настоящие аргументы из этого параметра:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;rename&nbsp;<font color=FF0000>(</font>arg<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF8000>os.rename</font><font color=FF0000>(</font>arg<font color=FF0000>.</font>old<font color=FF0000>,</font>&nbsp;arg<font color=FF0000>.</font>new<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Этот способ передачи параметров особенно полезен, когда у функции много аргументов и большинство из них необязательные. Например, функция, которая создает новое окно в библиотеке GUI, может иметь десятки аргументов, большинство из которых необязательные, и лучше всего их передать, используя имена:</p>

<p><a name="листинг 5.1"></a><b class="sect">Листинг 5.1</b>. Функция с именованными необязательными параметрами</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;Window&nbsp;<font color=FF0000>(</font>options<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;check&nbsp;mandatory&nbsp;options</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>options<font color=FF0000>.</font>title<font color=FF0000>)</font>&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"string"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"no&nbsp;title"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>options<font color=FF0000>.</font>width<font color=FF0000>)</font>&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"number"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"no&nbsp;width"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>options<font color=FF0000>.</font>height<font color=FF0000>)</font>&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"number"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"no&nbsp;height"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;everything&nbsp;else&nbsp;is&nbsp;optional</font>
&nbsp;&nbsp;_Window<font color=FF0000>(</font>options<font color=FF0000>.</font>title<font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options<font color=FF0000>.</font>x&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;значение&nbsp;по&nbsp;умолчанию</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options<font color=FF0000>.</font>y&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;значение&nbsp;по&nbsp;умолчанию</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options<font color=FF0000>.</font>width<font color=FF0000>,</font>&nbsp;options<font color=FF0000>.</font>height<font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options<font color=FF0000>.</font>background&nbsp;<font color=0000DF>or</font>&nbsp;<font color=8888CC>"white"</font><font color=FF0000>,</font>&nbsp;<font color=008000>--&nbsp;значение&nbsp;по&nbsp;умолчанию</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options<font color=FF0000>.</font>border&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;значение&nbsp;по&nbsp;умолчанию&nbsp;false&nbsp;(nil)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>)</font>
<font color=0000DF>end</font>

w&nbsp;<font color=FF0000>=</font>&nbsp;Window<font color=FF0000>{</font>&nbsp;x<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;width<font color=FF0000>=</font><font color=AC00A9>300</font><font color=FF0000>,</font>&nbsp;height<font color=FF0000>=</font><font color=AC00A9>200</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Lua"</font><font color=FF0000>,</font>&nbsp;background<font color=FF0000>=</font><font color=8888CC>"blue"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>}</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="5. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 5.1.</b><br>
Напишите функцию, которая получает произвольное число строк и возвращает их соединенными вместе.</p>

<hr color="#99CCFF">

<p><b>Упражнение 5.2.</b><br>
Напишите функцию, которая получает массив и печатает все элементы этого массива. Рассмотрите преимущества и недостатки использования <code>table.unpack</code> в этой функции.</p>

<hr color="#99CCFF">

<p><b>Упражнение 5.3.</b><br>
Напишите функцию, которая получает произвольное число значений и возвращает их все, кроме первого.</p>

<hr color="#99CCFF">

<p><a name="упражнение 5.4"></a><b>Упражнение 5.4.</b><br>
Напишите функцию, которая получает массив и печатает все комбинации элементов этого массива. (<i>Подсказка</i>: вы можете использовать рекурсивную формулу для числа комбинаций: <i>С(n, m) = С(n -1;m - 1) + С(n - 1, m)</i>. Для получения всех <i>С(n, m)</i> комбинаций из <i>n</i> элементов в группы размера <i>m</i> вы сперва добавляете первый элемент к результату и затем генерируете все <i>С(n-1, m-1)</i> комбинаций из оставшихся элементов в оставшихся местах. Когда <i>n</i> меньше, чем <i>m</i>, комбинаций больше нет. Когда <i>m</i> равно нулю, существует только одна комбинация, и она не использует никаких элементов.)</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 6. Ещё о функциях"></a>Глава 6. Ещё о функциях
</div>

<p>Функции в Lua являются значениями первого класса с соответствующей лексической областью действия.</p>

<p>Что значит, что функции являются «<i>значениями первого класса</i>»? Это значит что в Lua функция - это значение, обладающее тем же правами, что и стандартные значения воде чисел и строк. Мы можем сохранять функции в переменных (локальных и глобальных) и в таблицах, мы можем передавать функции как аргументы и возвращать их из других функций.</p>

<p>Что значит для функций «<i>лексическая область действия</i>»? Это значит, что функции могут обращаться к переменным, содержащим их функции (Это также значит, что Lua полностью содержит в себе лямбда-исчисление). Как мы увидим в этой главе, это вроде безобидное свойство дает огромную мощь языку, поскольку позволяет применять в Lua многие могущественные приемы из мира функционального программирования. Даже если вы совсем не интересуетесь функциональным программированием, все равно стоит немного узнать о том, как использовать эти возможности, поскольку они могут сделать вашу программу меньше и проще.</p>

<p>Несколько смущающим понятием в Lua является то, что функции, как и другие значения, являются анонимными; у них нет имен. Когда мы говорим об имени функции, например <code>print</code>, мы имеем в виду переменную, которая содержит данную функцию. Как и с любой другой переменной, содержащей любое другое значение, мы можем манипулировать этими переменными многими разными способами. Следующий пример, хотя и несколько надуман, показывает возможные примеры:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>p&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>}</font>
a<font color=FF0000>.</font>p<font color=FF0000>(</font><font color=8888CC>"Hello&nbsp;World"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;Hello&nbsp;World</font>
<font color=0080C0>print</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.sin</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;'print'&nbsp;теперь&nbsp;ссылается&nbsp;на&nbsp;синус</font>
a<font color=FF0000>.</font>p<font color=FF0000>(</font><font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>1</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0.841470</font>
sin&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>.</font>p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;'sin'&nbsp;теперь&nbsp;ссылается&nbsp;на&nbsp;функцию&nbsp;print</font>
sin<font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;20</font>
</pre>

<p>(Позже мы увидим полезные применения этой возможности.)</p>

<p>Если функции являются значениями, то существуют ли выражения, которые создают функции? Да. В частности, стандартный способ создать функцию в Lua, как, например,</p>

<pre class="code"><font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>*</font>x&nbsp;<font color=0000DF>end</font></pre>

<p>это просто пример того, что мы называем синтаксическим сахаром - просто более красивый способ написать следующий код:</p>

<pre class="code">foo&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>*</font>x&nbsp;<font color=0000DF>end</font></pre>

<p>По этому определение функции - это на самом деле оператор (присваивания), который создает значение типа "<code>function</code>" и присваивает его переменной. Мы можем рассматривать выражение <code>function (х) <b>body</b> end</code> как конструктор функции, точно так же, как <code>{}</code> является конструктором таблицы. Мы называем результат выполнения подобных конструкторов <i>анонимной функцией</i>. Хотя мы часто присваиваем функции глобальным переменным, давая им что-то вроде имени, бывают случаи, когда функции остаются анонимными. Давайте рассмотрим несколько примеров.</p>

<p>Библиотека <code>table</code> предоставляет функцию <code>table.sort</code>, которая получает таблицу и сортирует ее элементы. Подобная функция должна предоставлять бесконечные вариации порядка сортировки: по возрастанию и по убыванию, числовой или по алфавиту, по какому ключу и т. д. Вместо попытки предоставить все возможные опции sort предоставляет дополнительный параметр, который является <i>функцией упорядочения</i>: функция, которая получает два аргумента и определяет, должен ли первый элемент идти перед вторым в отсортированном списке. Например, допустим, что у нас есть следующая таблица записей:</p>

<pre class="code">
network&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;<font color=FF0000>{</font>name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"grauna"</font><font color=FF0000>,</font>&nbsp;IP&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"210.26.30.34"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>{</font>name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"arraial"</font><font color=FF0000>,</font>&nbsp;IP&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"210.26.30.23"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>{</font>name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"lua"</font><font color=FF0000>,</font>&nbsp;IP&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"210.26.23.12"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>{</font>name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"derain"</font><font color=FF0000>,</font>&nbsp;IP&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"210.26.23.20"</font><font color=FF0000>},</font>
<font color=FF0000>}</font>
</pre>

<p>Если вы хотите отсортировать таблицу по полю <code>name</code> в обратном алфавитном порядке, то вы можете просто записать:</p>

<pre class="code"><font color=8000FF>table.sort</font><font color=FF0000>(</font>network<font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>b<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>.</font>name&nbsp;<font color=FF0000>&gt;</font>&nbsp;b<font color=FF0000>.</font>name<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font></pre>

<p>Посмотрите, как удобно было использовать анонимную функцию в этом операторе.</p>

<p>Функция, которая получает другую функцию как аргумент, является тем, что мы называем <i>функцией высшего порядка</i>. Функции высшего порядка являются удобным программным механизмом, и использование анонимных функций для создания их функциональных аргументов является большим источником гибкости. Однако запомните, что функции высших порядков не являются чем-то особенным, они просто следствие способности Lua работать с функциями как значениями первого класса.</p>

<p>Для того чтобы проиллюстрировать использование функций высших порядков, мы напишем упрощенное определение часто встречающейся функции высшего порядка, производной. Следуя неформальному определению, производная функции <code>f</code> в точке <code>х</code> - это значение<code> (f(x + d) -f(x))/d</code>, когда <code>d</code> становится бесконечно малой. В соответствии с этим определением мы можем написать приближенное значение производной следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;derivative&nbsp;<font color=FF0000>(</font>f<font color=FF0000>,</font>&nbsp;delta<font color=FF0000>)</font>
&nbsp;&nbsp;delta&nbsp;<font color=FF0000>=</font>&nbsp;delta&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>1e-4</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font>f<font color=FF0000>(</font>x&nbsp;<font color=FF0000>+</font>&nbsp;delta<font color=FF0000>)</font>&nbsp;<font color=FF0000>-</font>&nbsp;f<font color=FF0000>(</font>x<font color=FF0000>))/</font>delta
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Получив функцию <code>f</code>, вызов <code>derivative(f)</code> вернет приближенное значение ее производной, которое является другой функцией:</p>

<pre class="code">
c&nbsp;<font color=FF0000>=</font>&nbsp;derivative<font color=FF0000>(</font><font color=8000FF>math.sin</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>math.cos</font><font color=FF0000>(</font><font color=AC00A9>5.2</font><font color=FF0000>),</font>&nbsp;c<font color=FF0000>(</font><font color=AC00A9>5.2</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0.46851667130038&nbsp;0.46856084325086</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>math.cos</font><font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>),</font>&nbsp;c<font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;-0.83907152907645&nbsp;-0.83904432662041</font>
</pre>

<p>Поскольку функции являются значениями первого класса в Lua, мы можем запоминать их не только в глобальных переменных, но и в локальных переменных и полях таблиц. Как мы увидим дальше, использование функций в полях таблицы - это ключевой компонент некоторых продвинутых возможностей Lua, таких как модули и обьектно-ориентированное программирование.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="6.1. Замыкания"></a>6.1. Замыкания
</div>

<p>Когда мы пишем функцию, заключенную внутри другой функции, то она имеет полный доступ к локальным переменным окружающей ее функции; мы называем это <i>лексической областью действия</i> (<i>lexical scoping</i>). Хотя это правило видимости может показаться очевидным, на самом деле это не так. Лексическая область видимости вместе с функциями, которые являются обьектами первого класса, является очень мощной концепцией в языке программирования, по многие языки этого не поддерживают.</p>

<p>Давайте начнем с простого примера. Пусть у вас есть список имен студентов и таблица, сопоставляющая им их оценки; вы хотите отсортировать список студентов по их оценкам, студенты с более высокими оценками должны идти раньше. Вы можете добиться этого следующим образом:</p>

<pre class="code">
names&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"Peter"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Paul"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Mary"</font><font color=FF0000>}</font>
grades&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>Mary&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;Paul&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>7</font><font color=FF0000>,</font>&nbsp;Peter&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>8</font><font color=FF0000>}</font>
<font color=8000FF>table.sort</font><font color=FF0000>(</font>names<font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>n1<font color=FF0000>,</font>&nbsp;n2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;grades<font color=FF0000>[</font>n1<font color=FF0000>]</font>&nbsp;<font color=FF0000>&gt;</font>&nbsp;grades<font color=FF0000>[</font>n2<font color=FF0000>]</font>&nbsp;<font color=008000>--&nbsp;сравнить&nbsp;оценки</font>
<font color=0000DF>end</font><font color=FF0000>)</font>
</pre>

<p>Теперь допустим, что вы хоте создать функцию для решения данной задачи:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;sortbygrade&nbsp;<font color=FF0000>(</font>names<font color=FF0000>,</font>&nbsp;grades<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=8000FF>table.sort</font><font color=FF0000>(</font>names<font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>n1<font color=FF0000>,</font>&nbsp;n2<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;grades<font color=FF0000>[</font>n1<font color=FF0000>]</font>&nbsp;<font color=FF0000>&gt;</font>&nbsp;grades<font color=FF0000>[</font>n2<font color=FF0000>]</font>&nbsp;<font color=008000>--&nbsp;compare&nbsp;the&nbsp;grades</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Интересной особенностью в этом примере является то, что анонимная функция, передаваемая функции <code>sort</code>, обращается к параметру <code>grades</code>, который является локальным для заключающей их функции <code>sortbygrade</code>. Внутри этой анонимной функции grades не является ни глобальной переменной, ни локальной переменной, а тем, что мы называем <i>нелокальной переменной</i>. (По историческим причинам для обозначения нелокальных переменных в Lua также используется термин <i>upvalue</i>.)</p>

<p>Почему это так интересно? Потому что функции являются значениями первого класса, и поэтому они могут <i>выйти</i> из начальной области действия своих переменных. Рассмотрим следующий пример:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;newCounter&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;анонимная&nbsp;функция</font>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;i
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

c1&nbsp;<font color=FF0000>=</font>&nbsp;newCounter<font color=FF0000>()</font>
<font color=0080C0>print</font><font color=FF0000>(</font>c1<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;1</font>
<font color=0080C0>print</font><font color=FF0000>(</font>c1<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;2</font>
</pre>

<p>В этом коде анонимная функция ссылается на нелокальную переменную <code>i</code> для учета значения. Однако к тому времени, как мы вызовем анонимную функцию, переменная <code>i</code> уже выйдет из своей области видимости, поскольку функция, которая создала эту переменную (<code>newCounter</code>), уже завершится. Тем не менее Lua правильно обрабатывает эту ситуацию, используя понятие <i>замыкания</i> (<i>closure</i>). Проще говоря, замыкание - это функция плюс все, что ей нужно для доступа к нелокальным переменным. Если мы снова вызовем <code>newCounter</code>, то она создаст новую локальную переменную <code>i</code>, поэтому мы получим новое замыкание, работающее с этой повой переменной:</p>

<pre class="code">
c2&nbsp;<font color=FF0000>=</font>&nbsp;newCounter<font color=FF0000>()</font>
<font color=0080C0>print</font><font color=FF0000>(</font>c2<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;1</font>
<font color=0080C0>print</font><font color=FF0000>(</font>c1<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;3</font>
<font color=0080C0>print</font><font color=FF0000>(</font>c2<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;2</font>
</pre>

<p>Таким образом, <code>cl</code> и <code>с2</code> - это разные замыкания одной и той же функции, и каждая использует свою независимо инстанциированпую локальную переменную <code>i</code>.</p>

<p>На самом деле в Lua значением является замыкание, а не функция. Функция - это просто прототип для замыкания. Тем не менее мы будем использовать термин «функция» для обозначения замыкания всегда, когда это не будет приводить к путанице.</p>

<p>Замыкания оказываются очень удобным инструментом во многих случаях. Как мы уже видели, они оказываются удобными в качестве аргументов функций высших порядков, таких как <code>sort</code>. Замыкания также полезны для функций, которые строят другие функции, как функция <code>newCounter</code> в нашем примере или же функция для нахождения производной; этот механизм позволяет программам на Lua использовать продвинутые методы из мира функционального программирования. Замыкания также удобны для различных <i>вызываемых функций</i> (<i>callback</i>). Типичный пример возникает, когда вы создаете различные кнопки в своей библиотеке для создания GUI. У каждой кнопки есть своя функция, которая должна быть вызвана, когда пользователь нажимает на эту кнопку. Обычно нужна, чтобы разные кнопки приводили к различным действиям. Например, калькулятору нужно десять кнопок, по одной на каждую цифру. Вы можете их создать с помощью подобной функции:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;digitButton&nbsp;<font color=FF0000>(</font>digit<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;Button<font color=FF0000>{</font>&nbsp;label&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font>digit<font color=FF0000>),</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_to_display<font color=FF0000>(</font>digit<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>}</font>
<font color=0000DF>end</font>
</pre>

<p>В этом примере мы предполагаем, что <code>Button</code> - это функция из библиотеки, которая создает новые кнопки; <code>label</code> - это метка кнопки; <code>action</code> -- это замыкание, которое нужно вызвать, когда кнопка будет нажата. Замыкание может быть заметно спустя длительное время после того, как <code>digitButton</code> выполнилась, и после того, как локальная переменная <code>digit</code> вышла из области своей видимости, по тем не менее замыкание все равно может к ней обращаться.</p>

<p>Замыкания также оказываются полезными в совсем другом случае. Поскольку функции хранятся в обычных переменных, мы можем легко переопределять функции в Lua, включая даже стандартные. Эта возможность является одной из причин, почему Lua столь гибок. Часто, когда вы переопределяете функцию, вам все равно нужна старая функция. Например, вы хотите переопределить функцию <code>sin</code>, чтобы она работала с градусами вместо радиан. Эта новая функция преобразует свой аргумент и затем зовет исходную функцию <code>sin</code> для выполнения работы. Ваш код при этом может выглядеть, как показано ниже:</p>

<pre class="code">
oldSin&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.sin</font>
<font color=8000FF>math.sin</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;oldSin<font color=FF0000>(</font>x<font color=FF0000>*</font><font color=8000FF>math.pi</font><font color=FF0000>/</font><font color=AC00A9>180</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Далее приведен немного более аккуратный способ выполнить это переопределение:</p>

<pre class="code">
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;oldSin&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.sin</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;k&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.pi</font><font color=FF0000>/</font><font color=AC00A9>180</font>
&nbsp;&nbsp;<font color=8000FF>math.sin</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;oldSin<font color=FF0000>(</font>x<font color=FF0000>*</font>k<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Теперь мы сохраняем старую версию в локальной переменной. Единственный способ обратиться к ней - через новую функцию.</p>

<p>Вы можете использовать этот же подход для создания безопасных окружений, также называемых <i>песочницами</i> (<i>sandbox</i>). Безопасные окружения крайне важны при выполнении кода из ненадежных источников, таких как Интернет. Например, чтобы ограничить файлы, к которым программа может обратиться, мы можем переопределить функцию <code>io.open</code>, используя замыкания:</p>

<pre class="code">
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;oldOpen&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.open</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;access_OK&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;mode<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&lt;</font>check&nbsp;access<font color=FF0000>&gt;</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF8000>io.open</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;mode<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;access_OK<font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;mode<font color=FF0000>)</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;oldOpen<font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;mode<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>nil</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"access&nbsp;denied"</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Что делает этот пример особенно приятным, так, что после этого переопределения нет абсолютно никакого способа программе вызвать исходный <code>open</code>, кроме как через новую версию с контролем. Небезопасная версия хранится в локальной переменной внутри замыкания, не достижима никак снаружи. С этим подходом вы можете строить песочницы для Lua на самом Lua, получая при этом в качестве плюсов простоту и гибкость. Вместо какого-то универсального решения для всех проблем Lua предоставляет мета-механизм, так что вы можете подогнать свое окружение под ваши цели.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="6.2. Неглобальные функции"></a>6.2. Неглобальные функции
</div>

<p>Очевидным последствием того, что функции являются значениями первого класса, является то, что мы можем сохранять функции не только в глобальных переменных, но также и в локальных переменных и полях таблицы.</p>

<p>Мы уже видели различные примеры функций, хранимых в полях таблиц. Большинство библиотек Lua использует этот механизм (например, <code>io.read, math.sin</code>). Для создания подобных функций в Lua нам нужно просто соединить стандартный синтаксис для функций с синтаксисом для таблиц:</p>

<pre class="code">
Lib&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
Lib<font color=FF0000>.</font>foo&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>,</font>y<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;x&nbsp;<font color=FF0000>+</font>&nbsp;y&nbsp;<font color=0000DF>end</font>
Lib<font color=FF0000>.</font>goo&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>,</font>y<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;x&nbsp;<font color=FF0000>-</font>&nbsp;y&nbsp;<font color=0000DF>end</font>

<font color=0080C0>print</font><font color=FF0000>(</font>Lib<font color=FF0000>.</font>foo<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>3</font><font color=FF0000>),</font>&nbsp;Lib<font color=FF0000>.</font>goo<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>3</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;5&nbsp;-1</font>
</pre>

<p>Конечно, мы также можем использовать конструкторы:</p>

<pre class="code">
Lib&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;foo&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>,</font>y<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;x&nbsp;<font color=FF0000>+</font>&nbsp;y&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>
&nbsp;&nbsp;goo&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>,</font>y<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;x&nbsp;<font color=FF0000>-</font>&nbsp;y&nbsp;<font color=0000DF>end</font>
<font color=FF0000>}</font>
</pre>

<p>Более того, Lua также предоставляет еще один синтаксис для подобных функций:</p>

<pre class="code">
Lib&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>function</font>&nbsp;Lib<font color=FF0000>.</font>foo&nbsp;<font color=FF0000>(</font>x<font color=FF0000>,</font>y<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;x&nbsp;<font color=FF0000>+</font>&nbsp;y&nbsp;<font color=0000DF>end</font>
<font color=0000DF>function</font>&nbsp;Lib<font color=FF0000>.</font>goo&nbsp;<font color=FF0000>(</font>x<font color=FF0000>,</font>y<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;x&nbsp;<font color=FF0000>-</font>&nbsp;y&nbsp;<font color=0000DF>end</font>
</pre>

<p>Когда мы запоминаем функцию в локальной переменной, мы получаем <i>локальную функцию</i>, то есть функцию с ограниченной областью видимости. Подобные определения особенно удобны для пакетов: поскольку Lua рассматривает каждый блок как функцию, блок может определять локальные функции, которые видны только из блока. Лексическая область видимости гарантирует, что другие функции из пакета могут использовать эти локальные функции:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(<</font>params<font color=FF0000>>)</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>body<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
<font color=0000DF>local</font>&nbsp;g&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(<</font>params<font color=FF0000>>)</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
&nbsp;&nbsp;f<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;'f'&nbsp;здесь&nbsp;видна</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Lua также поддерживает следующий синтаксический сахар для локальных функций:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;f&nbsp;<font color=FF0000>(<</font>params<font color=FF0000>>)</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>body<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>При определении рекурсивных локальных функций возникает тонкость. Наивный подход здесь не работает. Рассмотрим следующее определение:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;fact&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>==</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=0000DF>return</font>&nbsp;n<font color=FF0000>*</font>fact<font color=FF0000>(</font>n<font color=FF0000>-</font><font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;ошибка</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Когда Lua компилирует вызов <code>fact(n-l)</code> в теле функции, то локальная функция <code>fact</code> еще не определена. Поэтому данное определение попытается вызвать глобальную функцию <code>fact</code>, а не локальную. Мы можем решить эту проблему, сперва определив локальную переменную и затем уже определяя саму функцию:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;fact
fact&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>==</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=0000DF>return</font>&nbsp;n<font color=FF0000>*</font>fact<font color=FF0000>(</font>n<font color=FF0000>-</font><font color=AC00A9>1</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Теперь <code>fact</code> внутри функции ссылается на локальную переменную. Ее значение в момент, когда функцию определяют, ничего не значит. К тому моменту, когда функция будет выполняться, она уже получит правильное значение.</p>

<p>Когда Lua «раскрывает» свой синтаксический сахар для локальный функций, она не использует «наивный» путь. Вместо этого определение, как показано ниже:</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(<</font>params<font color=FF0000>>)</font>&nbsp;<font color=FF0000>&lt;</font>body<font color=FF0000>&gt;</font>&nbsp;<font color=0000DF>end</font></pre>

<p>переходит в</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;foo<font color=FF0000>;</font>&nbsp;foo&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(<</font>params<font color=FF0000>>)</font>&nbsp;<font color=FF0000>&lt;</font>body<font color=FF0000>&gt;</font>&nbsp;<font color=0000DF>end</font></pre>

<p>Поэтому мы можем спокойно использовать этот синтаксис для рекурсивных функций.</p>

<p>Конечно, этот прием не сработает, если у вас не прямая рекурсия - две функции вызывают друг друга. В таких случаях нужно явно записать соответствующие описания локальных переменных:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;f<font color=FF0000>,</font>&nbsp;g&nbsp;<font color=008000>--&nbsp;описали&nbsp;локальные&nbsp;переменные</font>

<font color=0000DF>function</font>&nbsp;g&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>&nbsp;f<font color=FF0000>()</font>&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;f&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>&nbsp;g<font color=FF0000>()</font>&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>В этом примере для функции <code>f</code> нельзя написать <code>local function f</code>, поскольку в подобном случае Lua создаст новую локальную переменную <code>f</code>, оставив старую (на которую ссылается <code>g</code>) неинициализированной.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="6.3. Оптимизация хвостовых вызовов"></a>6.3. Оптимизация хвостовых вызовов
</div>

<p>Другой интересной особенностью функций в Lua является то, что Lua выполняет оптимизацию хвостовых вызовов. (Это значит, что Lua поддерживает оптимизацию <i>хвостовой рекурсии</i> (<i>tail recursion</i>), хотя это здесь и не связано непосредственно с рекурсией, см. <a href="#упражнение 6.3">упражнение 6.3</a>.)</p>

<p><i>Хвостовой вызов</i> (tail call) - это фактически <b>goto</b>, выглядящее как вызов функции. Хвостовой вызов случается, когда функция вызывает другую функцию как последнее свое действие. Например, в следующем коде вызов функции <code>g</code> является хвостовым:</p>

<pre class="code"><font color=0000DF>function</font>&nbsp;f&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;g<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font></pre>

<p>После того как <code>f</code> вызовет <code>g</code>, ей больше нечего делать. В подобных ситуациях программе нет необходимости возвращаться в вызывающую функцию, когда вложенный вызов завершился. Поэтому после хвостового вызова программе нет необходимости хранить какую-либо информацию о вызывающей функции на стеке. Когда вызов <code>g</code> завершается, управление непосредственно переходит к точке, где была вызвана <code>f</code>. Реализации некоторых языков, например интерпретатор Lua, используют этот факт и не выделяют дополнительно места на стеке для хвостового вызова. Мы говорим, что эти реализации поддерживают <i>устранение хвостовых вызовов</i> (<i>tail-call elimination</i>).</p>

<p>Поскольку хвостовые вызовы не используют места на стеке, количество вложенных хвостовых вызовов, которое программа может выполнить, просто ничем не ограничено. Например, мы можем вызвать следующую функцию, передав любое число в качестве аргумента:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>&gt;</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;foo<font color=FF0000>(</font>n&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Этот вызов никогда не приведет к переполнению стека.</p>

<p>Тонким моментом в устранении хвостовых вызовов является вопрос о том, что же является хвостовым вызовом. Для некоторых вполне очевидных кандидатов требование о том, что вызывающая функция больше ничего не делает после вызова, не выполняется. Например, в следующем коде вызов функции <code>g</code> не является хвостовым.</p>

<pre class="code"><font color=0000DF>function</font>&nbsp;f&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;g<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font></pre>

<p>Проблема в этом примере - в том, что после вызова <code>g</code> функция <code>f</code> должна отбросить результаты <code>g</code> перед возвратом. Аналогично все следующие вызовы также не удовлетворяют условию:</p>

<pre class="code">
<font color=0000DF>return</font>&nbsp;g<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;<font color=008000>--&nbsp;необходимо&nbsp;выполнить&nbsp;сложение</font>
<font color=0000DF>return</font>&nbsp;x&nbsp;<font color=0000DF>or</font>&nbsp;g<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;необходимо&nbsp;привести&nbsp;к&nbsp;1&nbsp;значению</font>
<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font>g<font color=FF0000>(</font>x<font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;необходимо&nbsp;привести&nbsp;к&nbsp;1&nbsp;значению</font>
</pre>

<p>В Lua только вызов вида <code>return func(args)</code> является хвостовым. Однако и <code>func</code>, и ее аргументы могут быть сложными выражениями, поскольку Lua выполнит их перед вызовом. Например, следующий вызов является хвостовым:</p>

<pre class="code"><font color=0000DF>return</font>&nbsp;x<font color=FF0000>[</font>i<font color=FF0000>].</font>foo<font color=FF0000>(</font>x<font color=FF0000>[</font>j<font color=FF0000>]</font>&nbsp;<font color=FF0000>+</font>&nbsp;a<font color=FF0000>*</font>b<font color=FF0000>,</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;j<font color=FF0000>)</font></pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="6. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 6.1.</b><br>
Напишите функцию <code>integral</code>, которая получает функцию <code>f</code> и возвращает приближенное значение ее интеграла.</p>

<hr color="#99CCFF">

<p><b>Упражнение 6.2.</b><br>
В <a href="#упражнение 3.3">упражнении 3.3</a> вам надо было написать функцию, которая получает многочлен (представленный таблицей) и значение переменной и возвращает значение многочлена для этой переменной. Напишите функцию, которая получает многочлен и возвращает функцию, которая, будучи вызвана для какого-либо значения <code>х</code>, вернет значение многочлена для этого <code>х</code>. Например:</p>

<pre class="code">
f&nbsp;<font color=FF0000>=</font>&nbsp;newpoly<font color=FF0000>({</font><font color=AC00A9>3</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>})</font>
<font color=0080C0>print</font><font color=FF0000>(</font>f<font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;1</font>
<font color=0080C0>print</font><font color=FF0000>(</font>f<font color=FF0000>(</font><font color=AC00A9>5</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;76</font>
<font color=0080C0>print</font><font color=FF0000>(</font>f<font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;301</font>
</pre>

<hr color="#99CCFF">

<p><a name="упражнение 6.3"></a><b>Упражнение 6.3.</b><br>
Иногда язык, поддерживающий оптимизацию хвостовых вызовов, называется поддерживающим хвостовую рекурсию (<i>properly tail recursive</i>), если оптимизация хвостовых вызовов поддерживается только для рекурсивных вызовов. (Без рекурсивных вызовов максимальная глубина вызовов статически определена.)</p>

<p>Покажите, что это не справедливо в языке типа Lua. Напишите программу, которая реализует неограниченную глубину вызовов без использования рекурсии. (<i>Подсказка</i>: см. <a href="#8.1. Компиляция">раздел 8.1</a>.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 6.4.</b><br>
Как мы видели, хвостовой вызов - это замаскированное <b>goto</b>. Используя эту идею, перепишите код для игры в лабиринт из <a href="#4.4. break, return и goto">раздела 4.4</a>, используя хвостовые вызовы. Каждый блок должен стать поной функцией, и каждый <b>goto</b> становится хвостовым вызовом.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 7. Итераторы и обобщенный for"></a>Глава 7. Итераторы и обобщенный for
</div>

<p>В этой главе мы покажем, как писать итераторы для обобщенного <b>for</b> (оператор <b>for</b> общего вида). Начиная с простых итераторов, мы узнаем, как использовать всю силу обобщенного <b>for</b> для написания простых и более эффективных итераторов.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="7.1. Итераторы и замыкания"></a>7.1. Итераторы и замыкания
</div>

<p><i>Итератор</i> - это любая конструкция, которая позволяет вам перебирать элементы набора. В Lua мы обычно представляем итераторы при помощи функций: каждый раз, когда мы вызываем функцию, она возвращает «следующий» элемент из набора.</p>

<p>Любой итератор должен где-то сохранять свое состояние между вызовами, чтобы знать, где он находится и как продолжать дальше. Замыкания являются великолепным механизмом для этой задачи. Напомним, что <i>замыкание</i> - это функция, которая обращается к одной или нескольким локальным переменным из своего окружения. Эти переменные сохраняют свои значения между последовательными вызовами замыкания, помогая тем самым замыканию понять, где оно находится в своем пути. Конечно, для создания нового замыкания мы также должны создать его нелокальные переменные. Поэтому построение замыкания обычно включает в себя сразу две функции: само замыкание и <i>фабрику</i>, функцию, которая создает замыкание вместе с окружающими его переменными.</p>

<p>В качестве примера давайте напишем простой итератор для списка. В отличие от <code>ipairs</code>, этот итератор не будет возвращать индекс каждого элемента, а только его значение:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;values&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>;</font>&nbsp;<font color=0000DF>return</font>&nbsp;t<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>В этом примере <code>values</code> это фабрика. Каждый раз, когда мы вызываем эту фабрику, она создает новое замыкание (<i>итератор</i>). Это замыкание хранит свое состояние в своих внешних переменных <code>t</code> и <code>i</code>. Каждый раз, когда мы вызываем этот итератор, он возвращает следующее значение из списка <code>t</code>. После последнего элемента итератор вернет <b>nil</b>, что обозначает конец итераций.</p>
<p>
Мы можем использовать этот итератор в цикле <b>while</b>:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>30</font><font color=FF0000>}</font>
iter&nbsp;<font color=FF0000>=</font>&nbsp;values<font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;итератор</font>
<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;element&nbsp;<font color=FF0000>=</font>&nbsp;iter<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;вызываем&nbsp;итератор</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;element&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>element<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Однако гораздо легче использовать обобщенный оператор <b>for</b>. В конце концов, он был создан именно для подобного итерирования:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>30</font><font color=FF0000>}</font>
<font color=0000DF>for</font>&nbsp;element&nbsp;<font color=0000DF>in</font>&nbsp;values<font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>element<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Обобщенный <b>for</b> выполняет всю закулисную работу для итерирования: он внутри хранит итерирующую функцию, поэтому нам не нужна переменная <code>iter</code>, он вызывает итератор для каждой новой итерации, и он завершает итерирование, когда итератор возвращает <b>nil</b>. (В следующей секции мы увидим, что обобщенный <b>for</b> делает даже больше, чем только это.)</p>

<p>В качестве более продвинутого примера, - <a href="#листинг 7.1">листинг 7.1</a> для перебора всех слов из текущего входного файла. Для такого перебора нам нужно два значения: содержимое текущей строки (переменная <code>line</code>) и где мы находимся внутри этой строки (переменная <code>pos</code>). С этими данными мы можем всегда сгенерировать следующее слово. Основная часть итерирующей функции - это вызов <code>string.find</code>. Этот вызов ищет слово в текущей строке, начиная с текущей позиции. Он описывает «слово», используя шаблон <code>'%w+'</code>, которому удовлетворяет один или более алфавитно-цифровых символов. Если этот вызов находит слово, то функция обновляет текущую позицию на первый символ после слова и возвращает это слово (функция <code>string.sub</code> извлекает подстроку из <code>line</code> между заланными позициями; мы детально разберём её в <a href="#21.2. Функция string.find">разделе 21.2</a>). Иначе итератор читает следующую строку и повторяет поиск. Если больше строк нет, он возвращает <b>nil</b>, чтобы сообщить о конце обхода.</p>

<p>Несмотря на его сложность, использование <code>allwords</code> крайне просто:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;word&nbsp;<font color=0000DF>in</font>&nbsp;allwords<font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>word<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Это типичная ситуация с итераторами: их может быть не так легко написать, зато их легко использовать. Это не является проблемой, гораздо чаще конечные пользователи, программирующие на Lua, не пишут свои итераторы, а используют итераторы, предоставленные приложением.</p>

<p><a name="листинг 7.1"></a><b class="sect">Листинг 7.1</b>. Итератор для обхода всех слов из входного файла</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;allwords&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;текущая&nbsp;строка</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;pos&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;текущая&nbsp;позиция&nbsp;в&nbsp;строке</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;функция-итератор</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;line&nbsp;<font color=0000DF>do</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;повторять,&nbsp;пока&nbsp;есть&nbsp;строки</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s<font color=FF0000>,</font>&nbsp;e&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>line<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%w+"</font><font color=FF0000>,</font>&nbsp;pos<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;s&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;нашли&nbsp;слово?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;<font color=FF0000>=</font>&nbsp;e&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;следующая&nbsp;позиция&nbsp;после&nbsp;слова</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.sub</font><font color=FF0000>(</font>line<font color=FF0000>,</font>&nbsp;s<font color=FF0000>,</font>&nbsp;e<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;вернуть&nbsp;слово</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;слово&nbsp;не&nbsp;найдено;&nbsp;пробуем&nbsp;след.&nbsp;строку</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;начинаем&nbsp;с&nbsp;начала&nbsp;строки</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;больше&nbsp;нет&nbsp;строк,&nbsp;конец&nbsp;обхода</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="7.2. Семантика обобщенного for"></a>7.2. Семантика обобщенного for
</div>

<p>Одним из недостатков рассмотренных выше итераторов является то, что нам необходимо создавать новое замыкание для инициализации каждого нового цикла. Для большинства случаев это не является проблемой. Например, в случае итератора <code>allwords</code> цена создания одного замыкания несравнима с ценой чтения целого файла. Однако в некоторых ситуациях это может окапаться существенным. В таких случаях мы можем использовать сам обобщенный <b>for</b> для хранения состояния. И этом разделе мы увидим, какие возможности по хранению сое гояпия предлагает обобщенный <b>for</b>.</p>

<p>Мы видели, что обобщенный <b>for</b> во время цикла хранит итерирующую функцию внутри себя. На самом деле он хранит три значения: итерирующую функцию, <i>неизменяемое состояние</i> (<i>invariant state</i>) и <i>управляющую переменную</i>. Теперь давайте обратимся к деталям.</p>

<p>Синтаксис обобщенного <b>for</b> приводится ниже:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;<font color=FF0000>&lt;</font>var<font color=FF0000>-</font>list<font color=FF0000>&gt;</font>&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF0000>&lt;</font>exp<font color=FF0000>-</font>list<font color=FF0000>&gt;</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>body<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Здесь <i>var-list</i> - это список из одного или нескольких имен переменных, разделенных запятыми, a <i>exp-list</i> - это список из одного или нескольких выражений, также разделенных запятыми. Часто список выражений состоит из единственного элемента, вызова фабрики итераторов. В следующем коде, например, список переменных - это <code>k, v</code>, а список выражений состоит из единственного элемента <code>pairs(t)</code>:</p>

<pre class="code"><font color=0000DF>for</font>&nbsp;k<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>k<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font></pre>

<p>Часто список переменных также состоит всего из одной переменной, как в следующем цикле:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>line<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Мы называем первую переменную в списке <i>управляющей переменной</i>. В течение всего цикла ее значение не равно <b>nil</b>, поскольку когда она становится равной <b>nil</b>, цикл завершается.</p>

<p>Первое, что делает цикл <b>for</b>, - это вычисляет значения выражений, идущих после <b>in</b>. Эти выражения должны дать три значения, используемые оператором <b>for</b>: итерирующая функция, неизменяемое состояние и начальное значение управляющей переменной. Как и во множественном присваивании, только последний (или единственный) элемент списка может дать более одного значения, и число этих значений приводится к трем, лишние значения отбрасываются, вместо недостающих добавляются <b>nil</b>'ы. (Когда мы используем простые итераторы, фабрика возвращает только итерирующую функцию, поэтому инвариантное состояние и управляющая переменная получают значение <b>nil</b>.)</p>

<p>После этой инициализации <b>for</b> вызывает итерирующую функцию с двумя аргументами: инвариантным состоянием и управляющей переменной. (С точки зрения оператора <b>for</b>, это инвариантное состояние вообще не имеет никакого смысла. Оператор <b>for</b> только передает значение состояния с шага инициализации вызову итерирующей функции.) Затем <b>for</b> присваивает значения, возвращенные итерирующей функцией, переменным, обьявленным в списке переменных. Если первое значение (присваиваемое управляющей переменной) равно <b>nil</b>, то цикл завершается. Иначе <b>for</b> выполняет свое тело и снова зовет итерирующую функцию, повторяя процесс.</p>

<p>Более точно конструкция вида</p>

<pre class="code"><font color=0000DF>for</font>&nbsp;var_1<font color=FF0000>,</font>&nbsp;<font color=FF0000>...,</font>&nbsp;var_n&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF0000>&lt;</font>explist<font color=FF0000>&gt;</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=FF0000>&lt;</font>block<font color=FF0000>&gt;</font>&nbsp;<font color=0000DF>end</font></pre>

<p>эквивалента следующему коду:</p>

<pre class="code">
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;_f<font color=FF0000>,</font>&nbsp;_s<font color=FF0000>,</font>&nbsp;_var&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>&lt;</font>explist<font color=FF0000>&gt;</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;var_1<font color=FF0000>,</font>&nbsp;<font color=FF0000>...</font>&nbsp;<font color=FF0000>,</font>&nbsp;var_n&nbsp;<font color=FF0000>=</font>&nbsp;_f<font color=FF0000>(</font>_s<font color=FF0000>,</font>&nbsp;_var<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;_var&nbsp;<font color=FF0000>=</font>&nbsp;var_1
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;_var&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&lt;</font>block<font color=FF0000>&gt;</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Поэтому если наша итерирующая функция - это <code>f</code>, неизменяемое состояние <code>s</code> и начальное состояние для управляющей переменной есть <code>a0</code>, то управляющая переменная будет пробегать следующие значения <code>a1 = f(sа0), а2 = f(sa1)</code> и т.д., до тех пор, пока <code>ai</code> не станет равной <b>nil</b>. Если у <b>for</b> есть другие переменные, то они просто получат дополнительные значения, возвращаемые <code>f</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="7.3. Итераторы без состояния"></a>7.3. Итераторы без состояния
</div>

<p>Как подразумевает его название, такой итератор не хранит в себе ка-кого-либо состояния. Поэтому мы можем использовать один и тот же итератор без состояния во многих циклах, избегая тем самым создания новых замыканий.</p>

<p>Как мы уже видели, оператор <b>for</b> вызывает итерирующую функцию с двумя аргументами: неизменяемое состояние и управляющая переменная. Итератор без состояния строит следующий элемент цикла, используя только эти два значения. Типичным примером этого итератора является ipairs, который перебирает все элементы массива:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"one"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"two"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"three"</font><font color=FF0000>}</font>
<font color=0000DF>for</font>&nbsp;i<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>ipairs</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Состояние этого итератора - это таблица, которую мы перебираем (неизменяемое состояние, сохраняющее свое значение на протяжении цикла), и текущий индекс (управляющая переменная). И <code>ipairs</code> (фабрика), и сам итератор очень просты, мы могли бы записать их на Lua следующим образом:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;iter&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;i<font color=FF0000>)</font>
&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;v&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;v&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;i<font color=FF0000>,</font>&nbsp;v
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;<font color=0080C0>ipairs</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;iter<font color=FF0000>,</font>&nbsp;a<font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>end</font>
</pre>

<p>Когда Lua вызывает <code>ipairs(а)</code> для цикла <b>for</b>, она получает три значения: итерирующую функцию <code>iter</code>, а как инвариантное состояние и ноль в качестве начального значения для управляющей переменной. Затем Lua вызывает <code>iter(а,0)</code>, что дает <code>1</code>, <code>а[1]</code> (если только <code>а[1]</code> уже не <b>nil</b>). Lla следующей итерации вызывается <code>iter(а,1)</code>, что возвращает <code>2, а[2]</code>, и т. д. до первого элемента, равного <b>nil</b>.</p>

<p>Функция <code>pairs</code>, которая перебирает все элементы таблицы, похожа, за исключением того, что итерирующая функция - это функция <code>next</code>, которая является стандартной функцией в Lua:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;<font color=0080C0>pairs</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0080C0>next</font><font color=FF0000>,</font>&nbsp;t<font color=FF0000>,</font>&nbsp;<font color=0000DF>nil</font>
<font color=0000DF>end</font>
</pre>

<p>Вызов <code>next(t,k)</code>, где <code>k</code> - это ключ таблицы <code>t</code>, возвращает следующий ключ в таблице в произвольном порядке, а также связанное с этим ключом значение как второе возвращаемое значение. Вызов <code>next(t,nil)</code> возвращает первую пару. Когда больше нет пар, то <code>next</code> возвращает <b>nil</b>.</p>

<p>Некоторые предпочитают явно использовать <code>next</code>, избегая вызова <code>pairs</code>:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;k<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>next</font><font color=FF0000>,</font>&nbsp;t&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>loop&nbsp;body<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Вспомним, что <code>for</code> приводит свой список выражений к трем значениям, в качестве которых здесь выступят <code>next</code>, <code>t</code> и <b>nil</b>; это именно то, что получается при вызове <code>pairs</code>.</p>

<p>Итератор для обхода связного списка является другим интересным примером итератора без состояния. (Как мы уже упомянули, связные списки нечасто встречаются в Lua, но иногда они нам нужны.)</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;getnext&nbsp;<font color=FF0000>(</font>list<font color=FF0000>,</font>&nbsp;node<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;node&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;list
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;node<font color=FF0000>.</font>next
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;traverse&nbsp;<font color=FF0000>(</font>list<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;getnext<font color=FF0000>,</font>&nbsp;list<font color=FF0000>,</font>&nbsp;<font color=0000DF>nil</font>
<font color=0000DF>end</font>
</pre>

<p>Здесь мы используем начало списка как инвариантное состояние (второе значение, возвращаемое <code>traverse</code>) и текущий узел в качестве управляющей переменной. Когда итерирующая функция <code>getnext</code> будет первый раз вызвана, <code>node</code> будет равен <b>nil</b>, и поэтому функция вернет <code>list</code> как первый узел. В последующий вызовах <code>node</code> будет уже не равно <b>nil</b>, и поэтому итератор вернет <code>node.next</code>, как и ожидается. Как обычно, использование этого итератора крайне просто:</p>

<pre class="code">
list&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;list&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>val&nbsp;<font color=FF0000>=</font>&nbsp;line<font color=FF0000>,</font>&nbsp;<font color=0080C0>next</font>&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>}</font>
<font color=0000DF>end</font>

<font color=0000DF>for</font>&nbsp;node&nbsp;<font color=0000DF>in</font>&nbsp;traverse<font color=FF0000>(</font>list<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>node<font color=FF0000>.</font>val<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="7.4. Итераторы со сложным состоянием"></a>7.4. Итераторы со сложным состоянием
</div>

<p>Часто итератору требуется хранить больший обьем состояния, чем помещается в переменные инвариантного состояния и управляющей переменной. Простейшим решением является использование замыканий. Альтернативным решением будет запаковать все, что нужно итератору, в таблицу и использовать эту таблицу как инвариантное состояние для цикла. Используя таблицу, итератор можем хранить так много данных, как ему нужно. Более того, он может менять эти данные так, как он хочет. Хотя состояние - все время одна и та же таблица (поэтому она инварианта), содержимое таблицы может меняться на протяжении цикла. Поскольку такие итераторы хранят все свои данные в состоянии, обычно они игнорируют второй аргумент, предоставляемый обобщенным циклом <b>for</b> (переменная цикла).</p>

<p>В качестве примера такого подхода мы перепишем итератор <code>allwords</code>, который обходит все слова входного файла. На этот раз мы будем хранить его состояние в таблице с двумя полями: <code>line</code> и <code>pos</code>.</p>

<p>Функция, начинающая цикл, довольно проста. Она должна вернуть итерирующую функцию и начальное состояние:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;iterator&nbsp;<font color=008000>--&nbsp;будет&nbsp;определена&nbsp;позже</font>
<font color=0000DF>function</font>&nbsp;allwords&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;state&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(),</font>&nbsp;pos&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>}</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;iterator<font color=FF0000>,</font>&nbsp;state
<font color=0000DF>end</font>
</pre>

<p>Основную работу выполняет функция <code>iterator</code>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;iterator&nbsp;<font color=FF0000>(</font>state<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;state<font color=FF0000>.</font>line&nbsp;<font color=0000DF>do</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;повторяем,&nbsp;пока&nbsp;есть&nbsp;строки</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;ищем&nbsp;следующее&nbsp;слово</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s<font color=FF0000>,</font>&nbsp;e&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>state<font color=FF0000>.</font>line<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%w+"</font><font color=FF0000>,</font>&nbsp;state<font color=FF0000>.</font>pos<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;s&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;нашли&nbsp;слово?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;обновить&nbsp;положение&nbsp;(после&nbsp;текущего&nbsp;слова)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state<font color=FF0000>.</font>pos&nbsp;<font color=FF0000>=</font>&nbsp;e&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.sub</font><font color=FF0000>(</font>state<font color=FF0000>.</font>line<font color=FF0000>,</font>&nbsp;s<font color=FF0000>,</font>&nbsp;e<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;слово&nbsp;не&nbsp;найдено</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state<font color=FF0000>.</font>line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;пробуем&nbsp;следующую&nbsp;строку...</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state<font color=FF0000>.</font>pos&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;...&nbsp;с&nbsp;начала</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;больше&nbsp;строк&nbsp;нет,&nbsp;завершаем&nbsp;цикл</font>
<font color=0000DF>end</font>
</pre>

<p>Всегда, когда это возможно, вам следует пытаться написать итераторы без состояния, такие, которые хранят все свое состояние в переменных цикла <b>for</b>. С ними вы не создаете новых обьектов, когда начинаете цикл. Если эта модель не подходит, то вам следует попробовать замыкания. Кроме того, это более красиво, замыкание обычно является более эффективным в качестве итератора, чем таблица: во-первых, дешевле создать замыкание, чем таблицу; во-вторых, доступ к нелокальным переменным быстрее, чем доступ к полям таблицы. Позже мы увидим еще один способ писать итераторы, с использованием сопрограмм. Это является наиболее мощным решением, но оно несколько дороже.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="7.5. Подлинные итераторы (true iterarators)"></a>7.5. Подлинные итераторы (true iterarators)
</div>

<p>Термин «итератор» несколько неточен, поскольку на самом деле итерирует не итератор, а цикл <b>for</b>. Итераторы только предоставляют последовательные значения для итерирования. Может быть, более удачным термином был бы «генератор», но термин «итератор» уже получил широкое распространение в таких языках, как Java.</p>

<p>Тем не менее существует другой способ построения итераторов, где итераторы действительно осуществляют итерирование. Когда мы используем такие итераторы, мы не пишем цикл. Вместо этого мы просто вызываем итератор с аргументом, описывающим, что итератор должен делать на каждой итерации. Более точно итератор получает в качестве аргумента функцию, которую он вызывает внутри своего цикла.</p>

<p>В качестве примера давайте еще раз перепишем итератор <code>allwords</code> с использованием этого подхода:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;allwords&nbsp;<font color=FF0000>(</font>f<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;word&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>line<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%w+"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f<font color=FF0000>(</font>word<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;вызвать&nbsp;функцию</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Для использования этого итератора мы просто должны предоставить тело цикла как функцию. Если мы просто хотим напечатать каждое слово, то мы используем <code>print</code>:</p>

<pre class="code">allwords<font color=FF0000>(</font><font color=0080C0>print</font><font color=FF0000>)</font></pre>

<p>Часто в качестве тела цикла используется анонимная функция. Например, следующий фрагмент кода считает, сколько раз слово <code>«hello»</code> встречается в файле:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
allwords<font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>w<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;w&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"hello"</font>&nbsp;<font color=0000DF>then</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;count&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>count<font color=FF0000>)</font>
</pre>

<p>Та же самая задача, записанная при помощи итераторов ранее рассмотренного стиля, не сильно отличается:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;allwords<font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;w&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"hello"</font>&nbsp;<font color=0000DF>then</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;count&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>count<font color=FF0000>)</font>
</pre>

<p>Подобные итераторы были очень популярны в старых версиях Lua, когда в языке еще не было оператора <b>for</b>. Как они соотносятся с итераторами ранее рассмотренного стиля? Оба стиля имеют примерно одни и те же накладные расходы: один вызов функции на итерацию. С другой стороны, проще писать итератор с использованием подлинных итераторов (хотя мы можем получить эту же легкость при помощи сопрограмм). С другой стороны ранее рассмотренный стиль более гибкий. Во-первых, он позволяет два и более параллельных итерирования. (Например, рассмотрим случай обхода сразу двух файлов, сравнивая их слово за словом.) Во-вторых, он позволяет использование <b>break</b> и <b>return</b> внутри цикла. С подлинными итераторами <b>return</b> возвращает из анонимной функции, но не из цикла. Поэтому я обычно использую традиционные (то есть рассмотренные ранее) итераторы.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="7. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 7.1.</b><br>
Напишите итератор <code>fromto</code> - такой, что следующие два цикла оказываются эквивалентными:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=0000DF>in</font>&nbsp;fromto<font color=FF0000>(</font>n<font color=FF0000>,</font>&nbsp;m<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>body<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>

<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;n<font color=FF0000>,</font>&nbsp;m
&nbsp;&nbsp;<font color=FF0000>&lt;</font>body<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Можете ли вы реализовать это при помощи итератора без состояния?</p>

<hr color="#99CCFF">

<p><b>Упражнение 7.2.</b><br>
Добавьте параметр шаг к предыдущему упражнению. Можете ли вы по-прежнему реализовать это при помощи итератора без состояния?</p>

<hr color="#99CCFF">

<p><b>Упражнение 7.3.</b><br>
Напишите итератор <code>uniquewords</code>, который возвращает все слова из заданного файла без повторений. (<i>Подсказка</i>: начните с кода <code>allwords</code> на <a href="#листинг 7.1">листинге 7.1</a>; используйте таблицу чтобы хранить все слова, которые вы уже вернули.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 7.4.</b><br>
Напишите итератор, который возвращает все непустые подстроки заданной строки. (Вам понадобится функция <code>string.sub</code>.)</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 8. Компиляция, выполнение и ошибки"></a>Глава 8. Компиляция, выполнение и ошибки
</div>

<p>Хотя мы называем Lua интерпретируемым языком, Lua всегда пред-компилирует исходный код в в промежуточную форму перед его выполнением. (На самом деле многие интерпретируемые языки делают то же самое.) Наличие файла компиляции может звучать странным по отношению к интерпретируемому языку вроде Lua. Однако основной чертой интерпретируемых языков является не то, что они не компилируются, а то, что возможно (и легко) выполнять сгенерированный на лету код. Мы можем сказать, что наличие функции вроде <code>dofile</code> -это то, что позволяет Lua называться интерпретируемым языком.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="8.1. Компиляция"></a>8.1. Компиляция
</div>

<p>Ранее мы ввели <code>dofile</code> как своего рода примитивную операцию для выполнения блоков кода на Lua, но <code>dofile</code> - на самом деле вспомогательная функция: всю тяжелую работу выполняет <code>loadfile</code>. Как и <code>dofile</code>, <code>loadfile</code> загружает блок кода на Lua из файла, но он не выполняет этот блок. Вместо этого он только компилирует этот блок и возвращает откомпилированный блок как функцию. Более того, в отличие от <code>dofile</code>, <code>loadfile</code> не вызывает ошибки, а просто возвращает код ошибки, так что мы можем сами обработать эти ошибки. Мы можем определить <code>dofile</code> следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;<font color=0080C0>dofile</font>&nbsp;<font color=FF0000>(</font>filename<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>loadfile</font><font color=FF0000>(</font>filename<font color=FF0000>))</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;f<font color=FF0000>()</font>
<font color=0000DF>end</font>
</pre>

<p>Обратите внимание на использование функции <code>assert</code> для того, чтобы <i>вызывать ошибки</i> (<i>raise error</i>), если <code>loadfile</code> отрабатывает с ошибкой.</p>

<p>Для простых задач <code>dofile</code> удобна, поскольку выполняет всю работу за один вызов. Однако <code>loadfile</code> более гибкая. В случае ошибки <code>loadfile</code> возвращает <b>nil</b> и сообщение об ошибке, что позволяет нам обработать ошибку удобным способом. Более того, если нам нужно выполнить файл несколько раз, то мы можем один раз вызвать <code>loadfile</code> и несколько раз вызвать возвращенную им функцию. Этот подход гораздо дешевле, чем несколько раз вызывать <code>dofile</code>, поскольку файл компилируется всего один раз.</p>

<p>Функция <code>load</code> похожа на <code>loadfile</code>, за исключением того, что она берет блок кода не из файла, а из строки (В Lua 5.1 функция <code>loadstring</code> выполняет роль <code>load</code>). Например, рассмотрим следующую строку:</p>

<pre class="code">f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>load</font><font color=FF0000>(</font><font color=8888CC>"i&nbsp;=&nbsp;i&nbsp;+&nbsp;1"</font><font color=FF0000>)</font></pre>

<p>После выполнения этого кода <code>f</code> будет функцией, которая выполняет <code>i=i+l</code> при вызове:</p>

<pre class="code">
i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
f<font color=FF0000>();</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;1</font>
f<font color=FF0000>();</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;2</font>
</pre>

<p>Функция <code>load</code> довольно мощная, и мы должны использовать ее с осторожностью. Это также дорогая функция (по сравнению с некоторыми альтернативами) и может привести к коду, который очень тяжело понять. Перед тем как вы ее используете, убедитесь, что нет более простого способа решить задачу.</p>

<p>Если вы хотите быстрый и грязный <code>dostring</code> (то есть загрузить и выполнить блок), вы можете непосредственно использовать результат <code>load</code>:</p>

<pre class="code"><font color=0080C0>load</font><font color=FF0000>(</font>s<font color=FF0000>)()</font></pre>

<p>Однако, если есть хотя бы одна синтаксическая ошибка, то <code>load</code> вернет <b>nil</b> и окончательной ошибкой будет что-то вроде <i>"attempt to call a nil value"</i>. Для более ясной обработки ошибок используйте <code>assert</code>:</p>

<pre class="code"><font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>load</font><font color=FF0000>(</font>s<font color=FF0000>))()</font></pre>

<p>Обычно нет никакого смысла вызывать функцию <code>load</code> для литерала (то есть явно заданной строки в кавычках). Например, следующие две строки примерно эквиваленты:</p>

<pre class="code">
f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>load</font><font color=FF0000>(</font><font color=8888CC>"i&nbsp;=&nbsp;i&nbsp;+&nbsp;1"</font><font color=FF0000>)</font>
f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>end</font>
</pre>

<p>Однако вторая строка гораздо быстрее, поскольку Lua скомпилирует функцию вместе с окружающим ее блоком. В первой строке вызов <code>load</code> включает отдельную компиляцию.</p>

<p>Поскольку <code>load</code> не компилирует с учетом лексической области действия, то рассмотренные две строки могут быть не совсем эквивалентны. Для того чтобы увидеть разницу, давайте слегка изменим пример:</p>

<pre class="code">
i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>32</font>
<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>load</font><font color=FF0000>(</font><font color=8888CC>"i&nbsp;=&nbsp;i&nbsp;+&nbsp;1;&nbsp;print(i)"</font><font color=FF0000>)</font>
g&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>;</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
f<font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;33</font>
g<font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;1</font>
</pre>

<p>Функция <code>g</code> работает с локальной переменной <code>i</code>, как и ожидалось, однако функция <code>f</code> работает с глобальной <code>i</code>, поскольку <code>load</code> всегда компилирует свои блоки в глобальном окружении.</p>

<p>Наиболее типичным использованием <code>load</code> является выполнение внешнего кода, то есть фрагментов кода, приходящих извне вашей программы. Например, вы можете хотеть построить график функции, заданной пользователем; пользователь вводит код функции, а вы затем используете <code>load</code> для того, чтобы выполнить его. Обратите внимание, что <code>load</code> ожидает получить блок, то есть операторы. Если вы хотите вычислить выражение, то вы можете дописать к началу выражения <code>return</code>, что даст вам оператор, возвращающий значение данного выражения. Посмотрим на пример:</p>

<pre class="code">
<font color=0080C0>print</font>&nbsp;<font color=8888CC>"enter&nbsp;your&nbsp;expression:"</font>
<font color=0000DF>local</font>&nbsp;l&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
<font color=0000DF>local</font>&nbsp;func&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>load</font><font color=FF0000>(</font><font color=8888CC>"return&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;l<font color=FF0000>))</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"the&nbsp;value&nbsp;of&nbsp;your&nbsp;expression&nbsp;is&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;func<font color=FF0000>())</font>
</pre>

<p>Поскольку функция, возвращенная <code>load</code>, - это обычная функция, вы можете звать ее много раз:</p>

<pre class="code">
<font color=0080C0>print</font>&nbsp;<font color=8888CC>"enter&nbsp;function&nbsp;to&nbsp;be&nbsp;plotted&nbsp;(with&nbsp;variable&nbsp;'x'):"</font>
<font color=0000DF>local</font>&nbsp;l&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>load</font><font color=FF0000>(</font><font color=8888CC>"return&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;l<font color=FF0000>))</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=008000>--&nbsp;глобальная&nbsp;'х'&nbsp;(чтобы&nbsp;быть&nbsp;видной&nbsp;извне&nbsp;блока)</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.rep</font><font color=FF0000>(</font><font color=8888CC>"*"</font><font color=FF0000>,</font>&nbsp;f<font color=FF0000>()))</font>
<font color=0000DF>end</font>
</pre>

<p>(Функция <code>string.rep</code> повторяет строку заданное число раз.) Мы также можем вызвать функцию <code>load</code>, передав ей в качестве аргумента <i>читающую функцию</i> (<i>reader function</i>). Читающая функция может возвращать блок кода частями; <code>load</code> вызывает эту функцию до тех пора, пока она не вернет <b>nil</b>, обозначающий конец блока. Например, следующий вызов эквивалентен <code>loadfile</code>:</p>

<pre class="code">f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>load</font><font color=FF0000>(</font><font color=FF8000>io.lines</font><font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;<font color=8888CC>"*L"</font><font color=FF0000>))</font></pre>

<p>Как мы увидим в <a href="#Глава 22. Библиотека ввода/вывода">главе 22</a>, вызов <code>io.lines(filename, "*L")</code> возвращает функцию, которая, будучи вызванной, возвращает следующую строку из файла (Опции для <code>io.lines</code> появились только в Lua 5.2). Таким образом, <code>load</code> будет читать блок из файла строка за строкой. Следующий вариант похож, но более эффективен:</p>

<pre class="code">f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>load</font><font color=FF0000>(</font><font color=FF8000>io.lines</font><font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;<font color=AC00A9>1024</font><font color=FF0000>))</font></pre>

<p>Здесь итератор, возвращенный <code>io.lines</code>, читает блоками по 1024 байта.</p>

<p>Lua рассматривает каждый независимый блок как тело анонимной функции с переменным числом аргументов. Например, <code>load("а = 1")</code> возвращает аналог следующей функции:</p>

<pre class="code"><font color=0000DF>function</font>&nbsp;<font color=FF0000>(...)</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>end</font></pre>

<p>Как и любая другая функция, блоки могут определять свои локальные переменные:</p>

<pre class="code">
f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>load</font><font color=FF0000>(</font><font color=8888CC>"local&nbsp;a&nbsp;=&nbsp;10;&nbsp;print(a&nbsp;+&nbsp;20)"</font><font color=FF0000>)</font>
f<font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;30</font>
</pre>

<p>Используя эти возможности, мы можем переписать наш пример с построением графика так, чтобы не пользоваться глобальной переменной <code>х</code>:</p>

<pre class="code">
<font color=0080C0>print</font>&nbsp;<font color=8888CC>"enter&nbsp;function&nbsp;to&nbsp;be&nbsp;plotted&nbsp;(with&nbsp;variable&nbsp;'x'):"</font>
<font color=0000DF>local</font>&nbsp;l&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>load</font><font color=FF0000>(</font><font color=8888CC>"local&nbsp;x&nbsp;=&nbsp;...;&nbsp;return&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;l<font color=FF0000>))</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.rep</font><font color=FF0000>(</font><font color=8888CC>"*"</font><font color=FF0000>,</font>&nbsp;f<font color=FF0000>(</font>i<font color=FF0000>)))</font>
<font color=0000DF>end</font>
</pre>

<p>Мы ставим описание <code>"local x = ..."</code> в начало блока, чтобы определить <code>х</code> как локальную переменную. Когда мы вызываем <code>f</code> с аргументом <code>i</code>, этот аргумент становится значением выражения <code>...</code> .</p>

<p>Функция <code>load</code> никогда не вызывает ошибки, в случае ошибки она просто возвращает <b>nil</b> и сообщение об ошибке:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>load</font><font color=FF0000>(</font><font color=8888CC>"i&nbsp;i"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;nil&nbsp;[string&nbsp;"i&nbsp;i"]:1:&nbsp;'='&nbsp;expected&nbsp;near&nbsp;'i'</font>
</pre>

<p>Более того, у этих функций нет никакого побочного эффекта. Они только компилируют блок во внутреннее представление и возвращают результат как анонимную функцию. Распространенной ошибкой является то, что предполагается, что загрузка блока определяет функции (определенные в этом блоке). В Lua определения функций - это присваивания; и как таковые они происходят во время выполнения, а не во время компиляции. Например, допустим, что у нас есть файл <code>foo.lua</code> со следующим содержимым:</p>

<pre class="code">
<font color=008000>--&nbsp;file&nbsp;'foo.lua'</font>
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>x<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Затем мы выполняем команду</p>

<pre class="code">f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>loadfile</font><font color=FF0000>(</font><font color=8888CC>"foo.lua"</font><font color=FF0000>)</font></pre>

<p>После этой команды <code>foo</code> откомпилирована, но еще не определена. Чтобы определить ее, мы должны выполнить блок:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>foo<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
f<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;определяет&nbsp;'foo'</font>
foo<font color=FF0000>(</font><font color=8888CC>"ok"</font><font color=FF0000>)</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;ok</font>
</pre>

<p>В серьезных программах, которым нужно выполнять внешний код, вы должны обрабатывать все ошибки, возникающие при загрузке блока. Более того, вы можете захотеть запустить новый блок в защищенном окружении, чтобы избежать неприятных побочных эффектов. Мы подробно обсудим окружения в <a href="#Глава 14. Окружение">главе 14</a>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="8.2. Предкомпилированный код"></a>8.2. Предкомпилированный код
</div>

<p>Как я уже упомянул в начале этой главы, Lua предкомпилирует исходный код перед его выполнением. Lua также позволяет распространять код в предкомпилированной форме.</p>

<p>Простейшим путем получения предкомпилированного файла - также называемым в Lua <i>бинарным блоком</i> - является использование программы <code>luac</code>, которая входит в стандартную поставку. Например, следующий вызов создает файл <code>prog.lс</code> с предкомпилированной версией файла <code>prog.lua</code>:</p>

<pre class="code">$ luac -о prog.lc prog.lua</pre>

<p>Интерпретатор может затем выполнить этот файл, как и нормальный код на Lua, работая так же, как и с исходным файлом:</p>

<pre class="code">$ lua prog.lc</pre>

<p>Lua допускает предкомпилированный код практически везде, где он допускает исходный код. В частности, <code>loadfile</code> и <code>load</code> принимают на вход еще и предкомпилированный код.</p>

<p>Мы можем написать простую замену <code>luac</code> непосредственно на Lua:</p>

<pre class="code">
p&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>loadfile</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>])</font>
f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.open</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>],</font>&nbsp;<font color=8888CC>"wb"</font><font color=FF0000>)</font>
f<font color=FF0000>:</font><font color=FF8000>write</font><font color=FF0000>(</font><font color=8000FF>string.dump</font><font color=FF0000>(</font>p<font color=FF0000>))</font>
f<font color=FF0000>:</font><font color=FF8000>close</font><font color=FF0000>()</font>
</pre>

<p>Основная функция здесь - это <code>string.dump</code>: она получает функцию на Lua и возвращает ее предкомпилированный код как строку, правильно оформленную для ее загрузки в Lua.</p>

<p>Программа <code>luac</code> также представляет некоторые интересные опции. В частности, опция <code>-l</code> печатает список всех кодов операций, которые компилятор генерирует для данного блока. В качестве примера <a href="#листинг 8.1">листинг 8.1</a> содержит вывод программы <code>luac</code>, запущенной с опцией <code>-l</code>, для следующего однострочного файла:</p>

<pre class="code">a&nbsp;<font color=FF0000>=</font>&nbsp;x&nbsp;<font color=FF0000>+</font>&nbsp;y&nbsp;<font color=FF0000>-</font>&nbsp;z</pre>

<p>(Мы не будем обсуждать внутренности Lua в этой книге; если вас интересует информация об этих кодах операций, то поиск в Интернете по словам "<i>lua opcode</i>" даст вам достаточно точную информацию.)</p>

<p>Код в предкомпилированной форме не всегда меньше исходного кода, но он загружается быстрее. Еще одним плюсом является то, что это дает вам защиту от случайных изменений в исходниках. Однако, в отличие от исходного кода, злонамеренно измененный бинарный код может привести к падению интерпретатора Lua или даже выполнить предоставленный пользователем машинный код. При запуске обычного кода вам беспокоиться нечего. Однако вам следует избегать запуска ненадежного кода в предкомпилированной форме. У функции <code>load</code> есть специальная опция именно для этой задачи.</p>

<p><a name="листинг 8.1"></a><b class="sect">Листинг 8.1</b>. Пример вывода <code>luac -l</code></p>

<pre class="code">
main &lt;stdin:0,0&gt; (7 instructions, 28 bytes at 0x988cb30)
0+ params, 2 slots, 0 upvalues, 0 locals, 4 constants, 0 functions
1 [1] GETGLOBAL 0 -2 ; x
2 [1] GETGLOBAL 1 -3 ; у
3 [1] ADD 0 0 1
4 [1] GETGLOBAL 1-4 ; z
5 [1] SUB 0 0 1
6 [1] SETGL0BAL 0 -1 ; a
7 [1] RETURN 0 1
</pre>

<p>Кроме обязательного первого аргумента, у <code>load</code> есть еще три необязательных аргумента. Вторым аргументом является имя блока, которое используется только в сообщениях об ошибках. Четвертый аргумент - это окружение, его мы подробно рассмотрим в <a href="#Глава 14. Окружение">главе 14</a>. Третий аргумент -- это именно то, что нас сейчас интересует; он управляет тем, какие типы блоков могут быть загружены. Если этот аргумент присутствует, то он должен быть строкой: строка <code>"t"</code> позволяет загружать лишь текстовые блоки, строка <code>"b"</code> позволяет загружать только бинарные (предкомпилированные) блоки, и строка <code>"bt"</code> (значение аргумента по умолчанию) позволяет загружать блоки обоих типов.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="8.3. Код на С"></a>8.3. Код на С
</div>

<p>В отличие от кода, написанного на Lua, код на С должен быть слинкован с приложением перед его использованием. В ряде популярных операционных систем простейшим путем добиться этого является использование возможности динамической линковки. Однако данная возможность не часть спецификаций ANSI С; поэтому нет переносимого пути для реализации этого.</p>

<p>Обычно Lua не включает возможности, которые не могут быть реализованы в ANSI С. Однако с динамической линковкой ситуация отличается. Мы можем рассматривать ее как основу всех других возможностей: как только она у нас есть, мы сразу можем подгружать любую возможность, которая сейчас не в Lua. Поэтому в данном случае Lua отказывается от правил переносимости и реализует динамическую линковку для ряда платформ. Стандартная реализация предлагает эту возможность для <i>Windows, Mac OS X, Linux, FreeBSD, Solaris</i> и большинства других реализаций <i>UNIX</i>. Перенос этой возможности на другие платформы не должен быть сложным; обратитесь к вашему дистрибутиву. (Для проверки этого выполните print (<code>package.loadlib("a", "b")</code>) из командной строки Lua и посмотрите на результат. Если он сообщает о несуществующем файле, то у вас есть поддержка динамической линковки. В противном случае сообщение об ошибке скажет, что данная возможность не поддерживается или не установлена.)</p>

<p>Lua предоставляет все возможности динамической линковки через одну функцию, <code>package.loadiib</code>. Эта функция получает два строковых аргумента: полный путь к библиотеке и имя функции из этой библиотеки. Поэтому ее типичный вызов выглядит, как показано ниже:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;path&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"/usr/local/lib/lua/5.1/socket.so"</font>
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>package.loadlib</font><font color=FF0000>(</font>path<font color=FF0000>,</font>&nbsp;<font color=8888CC>"luaopen_socket"</font><font color=FF0000>)</font>
</pre>

<p>Функция <code>loadlib</code> загружает указанную библиотеку и подключает ее к Lua. Однако он не вызывает заданную функцию. Вместо этого он возвращает функцию на С как функцию на Lua. В случае ошибки при загрузке библиотеки или нахождении инициализирующей функции <code>loadlib</code> возвращает <b>nil</b> и сообщение об ошибке.</p>

<p>Функция <code>loadlib</code> является очень низкоуровневой. Мы должны передать полный путь к библиотеке и правильное имя функции (включая подчеркивания в начале, добавляемые компилятором). Часто мы загружаем библиотеки на С, используя <code>require</code>. Эта функция ищет библиотеку и использует <code>loadlib</code> для загрузки инициализирующей функции для библиотеки. При вызове эта инициализирующая функция строит и возвращает таблицу с функциями из этой библиотеки, как делает обычная Lua-библиотека. Мы обсудим <code>require</code> в <a href="#15.1. Функция require">разделе 15.1</a> и дополнительную информацию о библиотеках на С в разделе 27.3.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="8.4. Ошибки"></a>8.4. Ошибки
</div>

<p><i>Errare humanum est</i> (Человеку свойственно ошибаться, (лат.)). Поэтому мы должны обрабатывать ошибки так хорошо, как мы можем. Поскольку Lua - это язык для расширения, часто встраиваемый в приложение, мы не можем просто упасть-или завершить работу в случае возникновения ошибки. Вместо этого, когда возникает ошибка, Lua прерывает выполнение текущего блока и возвращает управление в приложение.</p>

<p>Любая неожиданная ситуация, с которой сталкивается Lua, приводит к вызову <i>ошибки</i> (<i>raises an error</i>). Ошибки возникают, когда вы (точнее, ваша программа) не можете сложить значения, которые не являются числами, индексировать не таблицу и т. п. (Вы можете изменить это поведение, используя <i>метатаблицы</i>, как мы увидим позже.) Вы также можете явно вызвать ошибки при помощи вызова функции <code>error</code> сообщением об ошибке в качестве аргумента. Обычно эта функция является правильным способом сообщить об ошибке в вашем коде:</p>

<pre class="code">
<font color=0080C0>print</font>&nbsp;<font color=8888CC>"введите&nbsp;число:"</font>
n&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(</font><font color=8888CC>"*n"</font><font color=FF0000>)</font>
<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;n&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"неверный&nbsp;ввод"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
</pre>

<p>Этот способ вызова <code>error</code> настолько распространен, что для этого в Lua есть встроенная функция <code>assert</code>:</p>

<pre class="code">
<font color=0080C0>print</font>&nbsp;<font color=8888CC>"введите&nbsp;число:"</font>
n&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.read</font><font color=FF0000>(</font><font color=8888CC>"*n"</font><font color=FF0000>),</font>&nbsp;<font color=8888CC>"неверный&nbsp;ввод"</font><font color=FF0000>)</font>
</pre>

<p>Функция <code>assert</code> проверяет, действительно ли ее первый аргумент не ложен, и просто возвращает этот аргумент; если аргумент ложен, то <code>assert</code> вызывает ошибку. Ее второй аргумент, сообщение об ошибке, не обязателен. Однако имейте в виду, что <code>assert</code> - это обычная функция. Как и со всеми функциями, Lua всегда перед ее вызовом вычисляет ее аргументы. Поэтому если вы напишите что-то вроде</p>

<pre class="code">
n&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>tonumber</font><font color=FF0000>(</font>n<font color=FF0000>),</font>&nbsp;<font color=8888CC>"invalid&nbsp;input:&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;n&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;is&nbsp;not&nbsp;a&nbsp;number"</font><font color=FF0000>)</font>
</pre>

<p>то Lua всегда выполнит конкатенацию, даже если <code>n</code> - это число. Поэтому в подобных случаях может быть лучше использовать явный тест.</p>

<p>Когда функция обнаруживает непредвиденную ситуацию (<i>исключение</i>), она может пойти двумя путями: вернуть код ошибки (обычно <b>nil</b>) или вызвать ошибку, используя <code>error</code>. Не существует жестких правил для выбора между этими двумя вариантами, но мы можем предложить общий совет: исключение, которое легко обходится, должно вызывать ошибку; иначе следует вернуть код ошибки.</p>

<p>Например, давайте рассмотрим функцию <code>sin</code>. Как она должна себя вести, если ее аргументом является таблица? Предположим, она возвращает код ошибки. Если нам нужно проверять на ошибки, то мы можем написать что-то вроде</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.sin</font><font color=FF0000>(</font>x<font color=FF0000>)</font>
<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;res&nbsp;<font color=0000DF>then</font>&nbsp;<font color=008000>--&nbsp;ошибка?</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font><font color=0080C0>error</font><font color=FF0000>-</font>handling&nbsp;code<font color=FF0000>&gt;</font>
</pre>

<p>Однако мы можем легко изменить это исключение перед вызовом функции:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;<font color=0080C0>tonumber</font><font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=008000>--&nbsp;х&nbsp;не&nbsp;число?</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font><font color=0080C0>error</font><font color=FF0000>-</font>handling&nbsp;code<font color=FF0000>&gt;</font>
</pre>

<p>Часто мы не проверяем ни аргумент, ни результат вызова <code>sin</code>, если аргумент - не число, то это значит, что что-то не так в нашей программе. В подобной ситуации прекратить вычисления и вызвать ошибку - это простейший и наиболее практичный способ обработки данного исключения.</p>

<p>С другой стороны, давайте рассмотрим функцию <code>io.open</code>, которая открывает файл. Как надо себя вести, если попросили открыть несуществующий файл? В этом случае не существует простого способа проверки на вызов на исключение перед вызовом этой функции. Во многих системах единственным способом проверить, что файл существует, является попробовать открыть его. Поэтому если <code>io.open</code> не может открыть файл по какой-то внешней причине (например, «файл не существует» или «нет прав!»), то она просто возвращает <b>nil</b> вместе с сообщением об ошибке. В этом случае у вас есть шанс обработать ситуацию подходящим образом, например попросив другое имя файла:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;file<font color=FF0000>,</font>&nbsp;msg
<font color=0000DF>repeat</font>
&nbsp;&nbsp;<font color=0080C0>print</font>&nbsp;<font color=8888CC>"enter&nbsp;a&nbsp;file&nbsp;name:"</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;name&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>end</font>&nbsp;<font color=008000>--&nbsp;ничего&nbsp;не&nbsp;введено</font>
&nbsp;&nbsp;file<font color=FF0000>,</font>&nbsp;msg&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.open</font><font color=FF0000>(</font>name<font color=FF0000>,</font>&nbsp;<font color=8888CC>"r"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;file&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>msg<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>until</font>&nbsp;file
</pre>

<p>Если вы не хотите обрабатывать подобную ситуацию, но тем не менее все равно хотите быть в безопасности, то вы можете просто использовать <code>assert</code>:</p>

<pre class="code">file&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font>name<font color=FF0000>,</font>&nbsp;<font color=8888CC>"r"</font><font color=FF0000>))</font></pre>

<p>Это типичная идиома для Lua: если <code>io.open</code> завершится с ошибкой, то <code>assert</code> вызовет ошибку.</p>

<pre class="code">
file&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font><font color=8888CC>"no-file"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"r"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;stdin:1:&nbsp;no-file:&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory</font>
</pre>

<p>Обратите внимание, как сообщение об ошибке, которое является вторым результатом <code>io.open</code>, оказывается вторым аргументом при вызове <code>assert</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="8.5. Обработка ошибок и исключений"></a>8.5. Обработка ошибок и исключений
</div>

<p>Для многих приложений вам не нужно делать какую-либо обработку ошибок в Lua; всю обработку делает само приложение. Вся работа Lua начинается с вызова приложением, обычно заключающимся в выполнении блока. Если возникает ошибка, то этот вызов возвращает код ошибки и приложение может соответствующим образом отреагировать. В случае отдельного интерпретатора его главный цикл просто печатает сообщение об ошибке и продолжает работать дальше.</p>

<p>Однако если вам надо обрабатывать ошибки в Lua, то вы должны использовать функцию <code>pcall(protected call)</code> для инкапсуляции своего кода.</p>

<p>Допустим, вы хотите выполнить фрагмент кода на Lua и поймать любую ошибку, возникающую при его выполнении. Вашим первым шагом будет заключить этот фрагмент кода в функцию; довольно часто для этого используются анонимные функции. Затем вы вызываете эту функцию, используя <code>pcall</code>:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;ok<font color=FF0000>,</font>&nbsp;msg&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>pcall</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;unexpected_condition&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0080C0>error</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>])</font>&nbsp;<font color=008000>--&nbsp;возможна&nbsp;ошибка:&nbsp;'а'&nbsp;может&nbsp;не&nbsp;быть&nbsp;таблицей</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&lt;</font>some&nbsp;code<font color=FF0000>&gt;</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
&nbsp;&nbsp;
<font color=0000DF>if</font>&nbsp;ok&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;не&nbsp;возникло&nbsp;ошибки&nbsp;при&nbsp;выполнении&nbsp;защищенного&nbsp;кода</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>regular&nbsp;code<font color=FF0000>&gt;</font>
<font color=0000DF>else</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;защищенный&nbsp;код&nbsp;вызвал&nbsp;ошибку;&nbsp;обработать&nbsp;ее</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font><font color=0080C0>error</font><font color=FF0000>-</font>handling&nbsp;code<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Вызов <code>pcall</code> вызывает свой первый аргумент в <i>защищенном режиме</i>, так что перехватываются все ошибки во время выполнения функции. Если нет никаких ошибок, то вызов <code>pcall</code> возвращает <b>true</b> и все значения, возвращенные функцией. Иначе он возвращает <b>false</b> и сообщение об ошибке.</p>

<p>Несмотря на свое название, сообщение об ошибке не обязано быть строкой: вызов <code>pcall</code> вернет любое значение Lua, которое вы передали <code>error</code>.</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;status<font color=FF0000>,</font>&nbsp;err&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>pcall</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0080C0>error</font><font color=FF0000>({</font>code<font color=FF0000>=</font><font color=AC00A9>121</font><font color=FF0000>})</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>err<font color=FF0000>.</font>code<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;121</font>
</pre>

<p>Эти механизмы предоставляют все, что вам надо для обработки исключений в Lua. Мы выбрасываем исключение при помощи <code>error</code> и перехватываем его при помощи <code>pcall</code>. Сообщение об ошибке идентифицирует тип ошибки.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="8.6. Сообщения об ошибках и стек вызовов"></a>8.6. Сообщения об ошибках и стек вызовов
</div>

<p>Хотя в качестве сообщения об ошибке мы можем использовать значение любого типа, обычно сообщения об ошибках - это строки, описывающие, что пошло не так. В случае возникновения внутренней ошибки (например, попытка индексировать не таблицу) сообщение об ошибке генерирует Lua; иначе сообщением об ошибке становится значение, переданное функции <code>error</code>. Когда сообщение об ошибке является строкой, то Lua пытается добавить некоторую информацию о том месте, где произошла ошибка:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;status<font color=FF0000>,</font>&nbsp;err&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>pcall</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a"</font><font color=FF0000>+</font><font color=AC00A9>1</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>err<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;stdin:1:&nbsp;attempt&nbsp;to&nbsp;perform&nbsp;arithmetic&nbsp;on&nbsp;a&nbsp;string&nbsp;value</font>
<font color=0000DF>local</font>&nbsp;status<font color=FF0000>,</font>&nbsp;err&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>pcall</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"my&nbsp;error"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>err<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;stdin:1:&nbsp;my&nbsp;error</font>
</pre>

<p>Сообщение об ошибке содержит имя файла(в примере это <code>stdin</code>) и номер строки в нем (в примере это <code>1</code>).</p>

<p>Функция <code>error</code> имеет второй дополнительный параметр, который сообщает <i>уровень</i>, где надо сообщать ошибку; вы используете этот параметр, чтобы обвинить кого-то другого в случае ошибки. Например, вы написали функцию, которая сразу же проверяет, что она была вызвана надлежащим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font>str<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>str<font color=FF0000>)</font>&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"string"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"string&nbsp;expected"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>regular&nbsp;code<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Затем кто-то вызывает вашу функцию с неправильным аргументом:</p>

<pre class="code">foo<font color=FF0000>({</font>x<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>})</font></pre>

<p>В этом случае Lua показывает на вашу функцию - в конце концов, это именно она вызвала <code>error</code>, -- а не настоящего виновника, того, кто вызвал ее с неправильным аргументом. Для того чтобы это исправить, мы можем передать <code>error</code>, что ошибка, о которой вы сообщаете, возникла на уровне <code>2</code> в стеке вызовов (уровень <code>1</code> - это ваша функция):</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font>str<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>str<font color=FF0000>)</font>&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"string"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"string&nbsp;expected"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>regular&nbsp;code<font color=FF0000>&gt;</font>
<font color=0000DF>end</font>
</pre>

<p>Часто при возникновении ошибки мы хотим получить больше отладочной информации, чем просто место, где она возникла. Как минимум мы хотим стек вызовов, приведший к ошибке. Когда <code>pcall</code> возвращает сообщение об ошибке, она разрушает часть стека (часть от нее до момента возникновения ошибки). Соответственно, если мы хотим получить стек вызовов, то мы должны построить его до возврата из <code>pcall</code>. Для этого Lua предоставляет функцию <code>xpcall</code>. Кроме функции, которую нужно вызвать, она получает второй аргумент, функцию обработки ошибки. В случае возникновения ошибки Lua вызывает эту <i>функцию обработки ошибки</i> перед очисткой стека, поэтому она может использовать отладочную библиотеку для получения любой дополнительной информации об ошибке. Двумя наиболее распространенными обработчиками ошибок являются <code>debug.debug</code>, предоставляющий вам командную строку в Lua, чтобы вы могли сами посмотреть, что происходило в момент возникновения ошибки; и <code>debug.traceback</code>, который строит расширенное сообщение об ошибке, включающее в себя стек вызовов (В <a href="#Глава 24. Отладочная библиотека">главе 24</a> мы больше узнаем об этих функциях и об отладочной библиотеке).</p>

<p>Именно последнюю функцию использует самостоятельный интерпретатор для печати сообщений об ошибках.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="8. Упражнения"></a>Упражнения
</div>

<p><a name="упражнение 8.1"></a><b>Упражнение 8.1.</b><br>
Часто бывает нужно добавить код к началу загружаемого блока (Мы уже видели пример в этой главе, когда мы добавляли код к <b>return</b>.) Напишите функцию <code>loadwithprefix</code>, которая работает как <code>load</code>, за исключением того, что она добавляет свой дополнительный аргумент к началу загружаемого блока.</p>

<p>Как и оригинальная функция <code>load</code>, <code>loadwithprefix</code> должна принимать блоки, представленные как строками, так и читающими функциями. Даже в случае, когда оригинальный блок является строкой, <code>loadwithprefix</code> не должна явно конкатенировать переданный аргумент с блоком. Вместо этого она должна вызвать <code>load</code> с соответствующей читающей функцией, которая сперва возвратит переданный аргумент, а потом - блок.</p>

<hr color="#99CCFF">

<p><b>Упражнение 8.2.</b><br>
Напишите функцию <code>multiload</code>, которая обобщает <code>loadwithprefix</code>, получая на вход список читающих функций, как в следующем примере:</p>

<pre class="code">
f&nbsp;<font color=FF0000>=</font>&nbsp;multiload<font color=FF0000>(</font><font color=8888CC>"local&nbsp;x&nbsp;=&nbsp;10;"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>(</font><font color=8888CC>"temp"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"*L"</font><font color=FF0000>),</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8888CC>"&nbsp;print(x)"</font><font color=FF0000>)</font>
</pre>

<p>Для приведенного выше примера <code>multiload</code> должна загрузить блок, эквивалентный конкатенации строки <code>"local..."</code> с содержимым файла <code>temp</code> и строки <code>"print(х)"</code>. Как и функция <code>loadwithprefix</code>, данная функция сама ничего конкатенировать не должна.</p>

<hr color="#99CCFF">

<p><b>Упражнение 8.3.</b><br>
Функция <code>string.rep</code> в <a href="#листинг 8.2">листинге 8.2</a> использует <i>алгоритм двоичного умножения</i>(<i>binary multiplication algorithm</i>) для конкатенации <code>n</code> копий заданной строки <code>s</code>. Для любого фиксированного <code>n</code> мы можем создать специализированную версию <code>string.rep</code>, раскрывая цикл в последовательность команд <code>r=r..s</code> и <code>s=s..s</code>. В качестве примера для <code>n=5</code> мы получаем следующую функцию:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;stringrep_5&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>""</font>
&nbsp;&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;r&nbsp;<font color=FF0000>..</font>&nbsp;s
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;s&nbsp;<font color=FF0000>..</font>&nbsp;s
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;s&nbsp;<font color=FF0000>..</font>&nbsp;s
&nbsp;&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;r&nbsp;<font color=FF0000>..</font>&nbsp;s
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;r
<font color=0000DF>end</font>
</pre>

<p><a name="листинг 8.2"></a><b class="sect">Листинг 8.2</b>. Повторение cтроки</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;stringrep&nbsp;<font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>""</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>&gt;</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;n&nbsp;<font color=FF0000>&gt;</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>%</font>&nbsp;<font color=AC00A9>2</font>&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=0000DF>then</font>&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;r&nbsp;<font color=FF0000>..</font>&nbsp;s&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;s&nbsp;<font color=FF0000>..</font>&nbsp;s
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.floor</font><font color=FF0000>(</font>n&nbsp;<font color=FF0000>/</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;r&nbsp;<font color=FF0000>..</font>&nbsp;s
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;r
<font color=0000DF>end</font>
</pre>

<p>Напишите функцию, которая для заданного <code>n</code> возвращает функцию <code>stringrep_n</code>. Вместо использования замыкания ваша функция должна построить текст функции на Lua с соответствующими командами <code>r=r..s</code> и <code>s=s..s</code> и затем использовать <code>load</code> для получения итоговой функции. Сравните быстродействие функции <code>string.rep</code> и полученной вами функции.</p>

<hr color="#99CCFF">

<p><b>Упражнение 8.4.</b><br>
Можете ли вы найти такое значение для <code>р</code>, что выражение <code>pcall(pcall, f)</code> вернет <b>false</b> как первое значение?</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 9. Сопрограммы"></a>Глава 9. Сопрограммы
</div>

<p><i>Сопрограмма</i> похожа на нить (в смысле многонитевости): это поток выполнения со своим стеком, своими локальными переменными и своим <i>указателем команд</i> (<i>instruction pointer</i>); но он разделяет глобальные переменные и почти все остальное с другими сопрограммами. Основное отличие между нитями и сопрограммами - это то, что программа с несколькими нитями выполняет все эти нити параллельно. Сопрограммы работают совместно: в любой момент времени программа выполняет только одну из своих сопрограмм, и эта выполняемая сопрограмма приостанавливает свое выполнение, только когда явно попросит это.</p>

<p>Сопрограммы - это очень мощное понятие. И поэтому многие из их применений довольно сложны. Не волнуйтесь, если вы не поймете некоторые из примеров из этой главы при первом чтении. Вы можете дочитать до конца книги и вернуться сюда позже. Но, пожалуйста, вернитесь, это будет хорошо проведенное время.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="9.1. Основы сопрограмм"></a>9.1. Основы сопрограмм
</div>

<p>Lua хранит все функции для работы с сопрограммами в таблице <code>coroutine</code>. Функция <code>create</code> создает новые сопрограммы. У нес всего один аргумент - функция, которую сопрограмма будет выполнять. Она возвращает значение типа <code>thread</code>, которое представляет из себя созданную сопрограмму. Часто аргументом <code>create</code> является анонимная функция, как показано ниже:</p>

<pre class="code">
co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"hi"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>co<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;thread:&nbsp;0x8071d98</font>
</pre>

<p>Сопрограмма может быть в одном из четырех состояний: приостановлена (<i>suspended</i>), выполняется (<i>running</i>), уничтожена (<i>dead</i>) и нормальном (<i>normal</i>). Мы можем узнать состояние сопрограммы при помощи функции <code>status</code>:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>coroutine.status</font><font color=FF0000>(</font>co<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;suspended</font></pre>

<p>Когда мы создаем сопрограмму, то она начинает в приостановленном состоянии; сопрограмма не начинает автоматически выполнять свое тело, когда мы ее создаем. Функция <code>coroutine.resume</code> продолжает (начинает) выполнение сопрограммы, меняя ее состояние из приостановленной в выполняемую:</p>

<pre class="code"><font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;hi</font></pre>

<p>В этом первом примере тело сопрограммы просто печатает "<code>hi</code>" и прекращает выполнение, оставляя сопрограмму в уничтоженном состоянии:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>coroutine.status</font><font color=FF0000>(</font>co<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;dead</font></pre>

<p>До сих пор сопрограммы выглядели просто как сложный способ вызова функций. Настоящая сила сопрограмм идет от функции <code>yield</code>, которая позволяет выполняемой сопрограмме приостановить свое выполнение так, что оно может быть продолжено позже. Давайте рассмотрим простой пример:</p>

<pre class="code">
co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"co"</font><font color=FF0000>,</font>&nbsp;i<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
</pre>

<p>Теперь, когда мы продолжаем выполнение этой функции, она начинает свое выполнение и выполняется до первого <code>yield</code>:</p>

<pre class="code"><font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;co&nbsp;1</font></pre>

<p>Если мы сейчас проверим ее статус, то увидим, что данная сопрограмма приостановлена и, следовательно, мы можем снова продолжить ее выполнение:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>coroutine.status</font><font color=FF0000>(</font>co<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;suspended</font></pre>

<p>С точки зрения сопрограммы, вся деятельность, которая происходит, пока сопрограмма приостановлена, происходит внутри вызова <code>yield</code>. Когда мы продолжим выполнение сопрограммы, она возвращается из вызова <code>yield</code> и продолжает свое выполнение до следующего вызова <code>yield</code> или окончания работы сопрограммы:</p>

<pre class="code">
<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;co&nbsp;2</font>
<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;co&nbsp;3</font>
&nbsp;&nbsp;<font color=FF0000>...</font>
<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;co&nbsp;10</font>
<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;ничего&nbsp;не&nbsp;печатает</font>
</pre>

<p>Во время последнего вызова <code>resume</code> цикл завершается и завершается выполнение функции без печати чего-либо. Если мы попытаемся снова продолжить ее выполнение, то <code>resume</code> вернет <b>false</b> и сообщение об ошибке:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;false&nbsp;cannot&nbsp;resume&nbsp;dead&nbsp;coroutine</font>
</pre>

<p>Обратите внимание, что <code>resume</code> выполняет тело сопрограммы в защищенном режиме. Поэтому в случае возникновения какой-либо ошибки при выполнении сопрограммы Lua не будет показывать сообщение об ошибке, а просто вернет управление вызову <code>resume</code>.</p>

<p>Когда сопрограмма продолжает выполнение другой сопрограммы, то он не приостанавливается; в конце концов, мы не можем продолжить ее выполнение. Однако она и не является выполняемой, поскольку выполняемой сопрограммой является другая сопрограмма. Поэтому ее статус называется <i>нормальным</i>.</p>

<p>Полезной возможностью в Lua является то, что пара <code>resume - yield</code> может обмениваться данными. Первый вызов <code>resume</code> (у которого нет ожидающего его вызова <code>yield</code>) передает свои дополнительные аргументы главной функции сопрограммы:</p>

<pre class="code">
co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"co"</font><font color=FF0000>,</font>&nbsp;a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;c&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>3</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;co&nbsp;1&nbsp;2&nbsp;5</font>
</pre>

<p>Вызов resume возвращает после <b>true</b>, сообщающего, что нет ошибок, все аргументы, переданные вызову <code>yield</code>:</p>
<pre class="code">
co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>b<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>(</font>a&nbsp;<font color=FF0000>+</font>&nbsp;b<font color=FF0000>,</font>&nbsp;a&nbsp;<font color=FF0000>-</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;true&nbsp;30&nbsp;10</font>
</pre>

<p>Аналогично <code>yield</code> возвращает все аргументы, переданные в соответствующий вызов <code>resume</code>:</p>

<pre class="code">
co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font>&nbsp;<font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"co1"</font><font color=FF0000>,</font>&nbsp;x<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"co2"</font><font color=FF0000>,</font>&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>())</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>,</font>&nbsp;<font color=8888CC>"hi"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;co1&nbsp;hi</font>
<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;co2&nbsp;4&nbsp;5</font>
</pre>

<p>Наконец, когда сопрограмма завершает свое выполнение, все значения возвращенные ее главной функцией, передаются как результат <code>resume</code>:</p>

<pre class="code">
co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>6</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>7</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;true&nbsp;6&nbsp;7</font>
</pre>

<p>Обычно мы редко используем все эти возможности в одной и той же сопрограмме, но у всех из них есть свое применение.</p>

<p>Для тех, кто уже знает что-то о сопрограммах, важно прояснить некоторые понятия, прежде чем мы пойдем дальше. Lua предлагает то, что называется <i>асимметричными сопрограммами</i>. Это значит, что у нее есть функция для приостановки выполнения сопрограммы и другая функция для продолжения выполнения приостановленной сопрограммы. В некоторых языках есть <i>симметричные сопрограммы</i>, когда есть только одна функция для передачи управления от одной сопрограммы другой.</p>

<p>Некоторые называют асимметричные сопрограммы полусопрограммами (не будучи симметричными, они не являются со-). Однако другие используют тот же термин полусопрограммы для обозначения ограниченной реализации сопрограмм, где сопрограмма может приостановить свое выполнение, только когда она не вызывает ни одну другую функцию, то есть когда у нее пет ожидающих вызовов. Другими словами, только главное тело такой сопрограммы может вызвать <code>yield</code>. Примером подобных полусопрограмм являются <i>генераторы</i> в Python.</p>

<p>В отличие от разницы между симметричными и несимметричными сопрограммами, разница между сопрограммами и генераторами (как реализовано в Python) гораздо глубже; генераторы просто не достаточно мощные, чтобы реализовать некоторые интересные конструкции, которые мы можем сделать с нормальными сопрограммами. Lua предлагает полноценные несимметричные сопрограммы. Те, кто предпочитают симметричные сопрограммы, могут реализовать их на основе асимметричных возможностей Lua. Это не сложно (Фактически каждая передача управления выполняет <code>yield</code>, за которым следует <code>resume</code>.)</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="9.2. Каналы и фильтры"></a>9.2. Каналы и фильтры
</div>

<p>Одним из наиболее важных примеров использования сопрограмм является задача потребителя-производителя (<i>producer-consumer</i>).</p>

<p>Давайте представим, что у нас есть функция, которая постоянно производит значения (например, читает их из файла), и другая функция, которая постоянно потребляет эти значения (например, пишет в другой файл). Обычно эти две функции выглядят следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;producer&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;произвести&nbsp;новое&nbsp;значение</font>
&nbsp;&nbsp;&nbsp;&nbsp;send<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;послать&nbsp;его&nbsp;потребителю</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;consumer&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;receive<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;получить&nbsp;значение&nbsp;от&nbsp;производителя</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>x<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;использовать&nbsp;его</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>(В этой реализации и производитель, и потребитель выполняются вечно. Однако их легко можно изменить для остановки, когда больше нет данных.) Задача здесь заключается в том, чтобы соединить вызовы <code>send</code> и <code>receive</code>. Это типичный пример задачи «у кого главный цикл». И производитель, и потребитель активны, у каждого есть свои главные циклы, и каждый предполагает, что другой - это вызываемый сервис. Для этого конкретного примера молено легко изменить структуру одной из функций, развернув ее цикл и сделав ее пассивной стороной. Однако в реальных случаях подобное изменение может быть далеко не так легко.</p>

<p>Сопрограммы предоставляют идеальный механизм для соединения производителя и потребителя, поскольку пара <code>resume-yield</code> переворачивает обычное соотношение между вызывающим и вызываемым. Когда сопрограмма вызывает <code>yield</code>, она не вызывает новую функцию; вместо этого она возвращает управление из текущего вызова(<code>resume</code>). Аналогично вызов resume не начинает новую функцию, а завершает вызов <code>yield</code>. Это именно то, что нам нужно для соединения <code>send</code> и <code>receive</code> таким образом, что каждый действует так, как будто главным является именно он, а второй является подчиненным. Поэтому <code>receive</code> продолжает выполнение производителя, так что он может произвести новое значение; и <code>send</code> возвращает это значение обратно потребителю:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;receive&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;status<font color=FF0000>,</font>&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>producer<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;value
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;send&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>(</font>x<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Конечно, производитель также должен быть сопрограммой:</p>

<pre class="code">
producer&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font>
<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;произвести&nbsp;новое&nbsp;значение</font>
&nbsp;&nbsp;&nbsp;&nbsp;send<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font><font color=FF0000>)</font>
</pre>

<p>При таком дизайне программа начинает с вызова потребителя. Когда потребителю нужно значение, он возобновляет работу производителя, который выполняется до тех пор, пока у него не будет готового значения, которое он передает потребителю, и не останавливается до тех пор, пока потребитель снова не продолжит его выполнение. Таким образом, мы получаем то, что называется дизайн, <i>управляемый потребителем</i> (<i>consumer-driven</i>). Другим вариантом было бьт написать программу, используя дизайн, <i>управляемый производителем</i>, где потребитель является сопрограммой.</p>

<p>Мы можем расширить этот дизайн при помощи фильтров, которые являются заданиями, находящимися между производителем и потребителем и выполняющими преобразование данных. <i>Фильтр</i> - это производитель и потребитель в одно и то же время, поэтому он продолжает выполнение производителя для получения нового значения и использует <code>yield</code> для передачи этого значения потребителю. В качестве простого примера мы можем добавить к нашему предыдущему коду фильтр, который в начало каждой строки вставляет ее номер. Код приведен в <a href="#листинг 9.1">листинге 9.1</a>. В конце нам просто надо создать компоненты, соединить их и начать выполнение итогового потребителя:</p>

<pre class="code">
p&nbsp;<font color=FF0000>=</font>&nbsp;producer<font color=FF0000>()</font>
f&nbsp;<font color=FF0000>=</font>&nbsp;filter<font color=FF0000>(</font>p<font color=FF0000>)</font>
consumer<font color=FF0000>(</font>f<font color=FF0000>)</font>
</pre>

<p>Или еще проще:</p>

<pre class="code">consumer<font color=FF0000>(</font>filter<font color=FF0000>(</font>producer<font color=FF0000>()))</font></pre>

<p><a name="листинг 9.1"></a><b class="sect">Листинг 9.1</b>. Потребитель и производитель с фильтрами</p>
<pre class="code">
<font color=0000DF>function</font>&nbsp;receive&nbsp;<font color=FF0000>(</font>prod<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;status<font color=FF0000>,</font>&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>prod<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;value
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;send&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>(</font>x<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;producer&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;произвести&nbsp;новое&nbsp;значение</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;filter&nbsp;<font color=FF0000>(</font>prod<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.huge</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;receive<font color=FF0000>(</font>prod<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;получить&nbsp;новое&nbsp;значение</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%5d&nbsp;%s"</font><font color=FF0000>,</font>&nbsp;line<font color=FF0000>,</font>&nbsp;x<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;послать&nbsp;его&nbsp;потребителю</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;consumer&nbsp;<font color=FF0000>(</font>prod<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;receive<font color=FF0000>(</font>prod<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;получить&nbsp;новое&nbsp;значение</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>x<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;использовать&nbsp;новое&nbsp;значение</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p><a name="листинг 9.2"></a><b class="sect">Листинг 9.2</b>. Функция для получения всех перестановок из <code>n</code> элементов <code>а</code></p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;permgen&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;n&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>#</font>a&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;по&nbsp;умолчанию&nbsp;'n'&nbsp;-&nbsp;это&nbsp;размер&nbsp;'а'</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000><=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=008000>--&nbsp;ничего&nbsp;не&nbsp;надо&nbsp;делать?</font>
&nbsp;&nbsp;&nbsp;&nbsp;printResult<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;n&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;поместить&nbsp;i-й&nbsp;элемент&nbsp;в&nbsp;конец</font>
&nbsp;&nbsp;&nbsp;&nbsp;a<font color=FF0000>[</font>n<font color=FF0000>],</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>],</font>&nbsp;a<font color=FF0000>[</font>n<font color=FF0000>]</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создать&nbsp;все&nbsp;перестановки&nbsp;остальных&nbsp;элементов</font>
&nbsp;&nbsp;&nbsp;&nbsp;permgen<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;n&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;восстановить&nbsp;i-й&nbsp;элемент</font>
&nbsp;&nbsp;&nbsp;&nbsp;a<font color=FF0000>[</font>n<font color=FF0000>],</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>],</font>&nbsp;a<font color=FF0000>[</font>n<font color=FF0000>]</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Если вы подумали о каналах (<i>pipe</i>) в UNIX, то вы не одиноки. В конце концов, сопрограммы - это вариант <i>невытесняющей многозадачности</i> (<i>non-preemptive multitasking</i>). С каналами каждая задача выполняется как отдельный процесс; с сопрограммами каждая задача выполняется как отдельная сопрограмма. Каналы предоставляют буфер между пишущим (<i>производителем</i>) и читающим (<i>потребителем</i>), поэтому возможна некоторая свобода в их относительных скоростях. Для канала это важно, поскольку цена переключения между процессами высока. С сопрограммами цена переключения между задачами намного меньше (примерно как вызов функции), поэтому пишущий и читающий могут идти нога в ногу.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="9.3. Сопрограммы как итераторы"></a>9.3. Сопрограммы как итераторы
</div>

<p>Мы можем рассматривать итераторы цикла как отдельный пример производителя-потребителя: итератор производит значения, потребляемые телом цикла. Поэтому является вполне естественным использовать сопрограммы для написания итераторов. Действительно, сопрограммы являются мощным инструментом для этой цели. Опять, ключевой особенностью является их способность перевернуть отношение между вызывающим и вызываемым. С этой особенностью мы можем писать итераторы, не волнуясь хранить состояние между последовательными вызовами итератора.</p>

<p>Для того чтобы проиллюстрировать этот вариант использования, давайте напишем итератор для перебора всех перестановок заданного массива. Написание подобного итератора не так легко, но довольно просто написать рекурсивную функцию, строящую все эти перестановки. Идея проста: по очереди поместить каждый элемент в конец массива и рекурсивно сгенерировать все оставшиеся перестановки. Код приведен в <a href="#листинг 9.2">листинге 9.2</a>. Для того чтобы он работал, мы должны написать соответствующую функцию <code>printResult</code> и вызвать <code>permgen</code> с надлежащими аргументами:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;printResult&nbsp;<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>a&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>],</font>&nbsp;<font color=8888CC>"&nbsp;"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"\n"</font><font color=FF0000>)</font>
<font color=0000DF>end</font>

permgen&nbsp;<font color=FF0000>({</font><font color=AC00A9>1</font><font color=FF0000>,</font><font color=AC00A9>2</font><font color=FF0000>,</font><font color=AC00A9>3</font><font color=FF0000>,</font><font color=AC00A9>4</font><font color=FF0000>})</font>
<font color=008000>--&gt;&nbsp;2&nbsp;3&nbsp;4&nbsp;1</font>
<font color=008000>--&gt;&nbsp;3&nbsp;2&nbsp;4&nbsp;1</font>
<font color=008000>--&gt;&nbsp;3&nbsp;4&nbsp;2&nbsp;1</font>
<font color=FF0000>...</font>
<font color=008000>--&gt;&nbsp;2&nbsp;1&nbsp;3&nbsp;4</font>
<font color=008000>--&gt;&nbsp;1&nbsp;2&nbsp;3&nbsp;4</font>
</pre>

<p>После того как генератор готов, его очень легко преобразовать в итератор. Во-первых, мы заменим <code>printResult</code> на <code>yield</code>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;permgen&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;n&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>#</font>a
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000><=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&lt;</font>как&nbsp;ранее<font color=FF0000>&gt;</font>
</pre>

<p>Затем мы определяем фабрику, которая будет запускать генератор внутри сопрограммы, и создаем итерирующую функцию. Для получения следующей перестановки итератор просто продолжает выполнение сопрограммы:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;permutations&nbsp;<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;permgen<font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;iterator</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;code<font color=FF0000>,</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;res
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>После этого мы легко можем перебирать все перестановки массива при помощи оператора <b>for</b>:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;p&nbsp;<font color=0000DF>in</font>&nbsp;permutations<font color=FF0000>{</font><font color=8888CC>"a"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"b"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"c"</font><font color=FF0000>}</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;printResult<font color=FF0000>(</font>p<font color=FF0000>)</font>
<font color=0000DF>end</font>
<font color=008000>--&gt;&nbsp;b&nbsp;c&nbsp;a</font>
<font color=008000>--&gt;&nbsp;c&nbsp;b&nbsp;a</font>
<font color=008000>--&gt;&nbsp;c&nbsp;a&nbsp;b</font>
<font color=008000>--&gt;&nbsp;a&nbsp;c&nbsp;b</font>
<font color=008000>--&gt;&nbsp;b&nbsp;a&nbsp;c</font>
<font color=008000>--&gt;&nbsp;a&nbsp;b&nbsp;c</font>
</pre>

<p>Функция <code>permutations</code> использует типичный для Lua паттерн, который прячет возобновление сопрограммы внутри функции. Этот паттерн настолько распространен, что Lua предоставляет специальную функцию для него: <code>coroutine.wrap</code>. Как и <code>create</code>, <code>wrap</code> создает новую сопрограмму. В отличие от <code>create</code>, <code>wrap</code> не возвращает саму сопрограмму; вместо этого она возвращает функцию, которая при вызове продолжает выполнение этой сопрограммы. В отличие от <code>resume</code>, она не возвращает код ошибки как первое значение; вместо этого она вызывает ошибку. Используя <code>wrap</code>, мы можем записать <code>permutations</code> следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;permutations&nbsp;<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF8000>coroutine.wrap</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;permgen<font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Обычно использовать <code>coroutine.wrap</code> проще, чем <code>coroutine.create</code>. Она дает нам именно то, что нам нужно от сопрограммы: функцию для продолжения ее выполнения. Однако она менее гибкая. Не существует способа проверить статус сопрограммы, созданной при помощи <code>wrap</code>. Более того, мы не можем проверять на ошибки во время выполнения.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="9.4. Невытесняющая многонитевость"></a>9.4. Невытесняющая многонитевость
</div>

<p>Как мы видели ранее, сопрограммы предоставляют вариант совместной многонитевости. Каждая сопрограмма эквивалентна нити. Пара <code>yield-resume</code> переключает управление от одной нити к другой нити. Однако, в отличие от обычной многонитевости, сопрограмма не являются вытесняющими (<i>preemptive</i>). Пока сопрограммы выполняется, она не может быть остановлена извне. Она прерывает свое выполнение, только когда явно запрашивает это (через вызов <code>yield</code>). Для ряда приложений это не является проблемой, скорее наоборот. Программирование гораздо проще в отсутствии вытесняемости. Вам не нужно беспокоиться об ошибках синхронизации, поскольку вся Синхронизация явная. Вам нужно только убедиться в том, что сопрограмма вызывает <code>yield</code> вне критической области кода.</p>

<p>Однако с невытесняющей многонитевостыо, как только какая-то нить вызывает блокирующую операцию, вся программа блокируется до тех пор, пока эта операция не завершится. Для большинства приложений это недопустимо, что ведет к тому, что многие программисты не рассматривают сопрограммы как альтернативу традиционной многонитевости. Как мы увидим здесь, у этой проблемы есть интересное (и очевидное притом) решение.</p>

<p>Давайте рассмотрим типичную многонитевую задачу: мы хотим скачать несколько файлов через HTTP. Для скачивания нескольких файлов мы сначала должны разобраться, как скачать один файл. В этом примере мы рассмотрим разработанную <i>Диего Нехабом</i> библиотеку <i>LuaSocket</i>. Для того чтобы скачать файл, иадо сперва установить соединение с сайтом, содержащим данный файл, получить файл (блоками) и закрыть соединение. На Lua мы можем написать это следующим образом. Для начала мы загружаем библиотеку <code>LuaSocket</code>:</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;socket&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font>&nbsp;<font color=8888CC>"socket"</font></pre>

<p>Затем мы определяем сайт и файл, который хотим скачать. В этом примере мы скачаем справочное руководство по HTML 3.2 с сайта консорциума <i>World Wide Web</i>:</p>

<pre class="code">
host&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"www.w3.org"</font>
file&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"/TR/REC-html32.html"</font>
</pre>

<p>Затем мы открываем TCP-соединение с портом 80 (стандартный порт для HTTP-соединений) данного сайта:</p>

<pre class="code">c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font>socket<font color=FF0000>.</font>connect<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;<font color=AC00A9>80</font><font color=FF0000>))</font></pre>

<p>Эта операция возвращает обьект соединения, который мы используем для посылки запроса на получение файла:</p>

<pre class="code">c<font color=FF0000>:</font>send<font color=FF0000>(</font><font color=8888CC>"GET&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;file&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;HTTP/1.0\r\n\r\n"</font><font color=FF0000>)</font></pre>

<p>Затем мы читаем файл блоками по 1 Кб, записывая каждый блок в стандартный вывод:</p>

<pre class="code">
<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s<font color=FF0000>,</font>&nbsp;status<font color=FF0000>,</font>&nbsp;partial&nbsp;<font color=FF0000>=</font>&nbsp;c<font color=FF0000>:</font>receive<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>^</font><font color=AC00A9>10</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>s&nbsp;<font color=0000DF>or</font>&nbsp;partial<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;status&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"closed"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Функция <code>receive</code> возвращает или строку, которую прочла, или <b>nil</b> в случае ошибки; в последнем случае она также возвращает код ошибки (<code>status</code>) и что она прочла до ошибки (<code>partial</code>). Когда сайт закрывает соединение, мы печатаем оставшиеся данные и выходим из цикла.</p>

<p>После скачивания файла мы закрываем соединение:</p>

<pre class="code">c<font color=FF0000>:</font><font color=FF8000>close</font><font color=FF0000>()</font></pre>

<p>Теперь, когда мы знаем, как скачать один файл, давайте вернемся к проблеме скачивания нескольких файлов. Простейшим подходом будет скачивать один файл за раз. Однако этот последовательный подход, когда мы начинаем читать файл только после того, как закончим с предыдущим файлом, слишком медленный. При чтении файла по сети программа проводит основную часть времени, ожидая данных. Более точно, она проводит большую часть времени блокированная в вызове <code>receive</code>. Поэтому программа может выполняться значительно быстрее, если будет сразу скачивать все файлы. Тогда, когда у соединения нет готовых данных, программа может читать данные из другого соединения. Ясно, что сопрограммы предоставляют удобный способ для организации этих одновременных скачиваний. Мы создаем новую нить для каждого скачиваемого файла. Когда у нити нет готовых данных, она передает управление диспетчеру, который вызывает другую нить.</p>

<p>Для того чтобы переписать программу с использованием сопрограмм, нам для начала надо переписать скачивающий код как функцию. Результат приведен в <a href="#листинг 9.3">листинге 9.3</a>. Поскольку нам не интересно содержимое файла, функция считает и печатает размер файла вместо записи файла в стандартный вывод (когда у пас несколько нитей читают сразу несколько файлов, на выходе получилась бы полная мешанина).</p>

<p><a name="листинг 9.3"></a><b class="sect">Листинг 9.3</b>. Код для скачивания страницы из сети</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;download&nbsp;<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;file<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font>socket<font color=FF0000>.</font>connect<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;<font color=AC00A9>80</font><font color=FF0000>))</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=008000>--&nbsp;counts&nbsp;number&nbsp;of&nbsp;bytes&nbsp;read</font>
&nbsp;&nbsp;c<font color=FF0000>:</font>send<font color=FF0000>(</font><font color=8888CC>"GET&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;file&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;HTTP/1.0\r\n\r\n"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s<font color=FF0000>,</font>&nbsp;status&nbsp;<font color=FF0000>=</font>&nbsp;receive<font color=FF0000>(</font>c<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;count&nbsp;<font color=FF0000>+</font>&nbsp;<font color=FF0000>#</font>s
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;status&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"closed"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;c<font color=FF0000>:</font><font color=FF8000>close</font><font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>file<font color=FF0000>,</font>&nbsp;count<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>В получившемся коде мы используем вспомогательную функцию(<code>receive</code>) для получения данных из соединения. При последовательном подходе код бы выглядел следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;receive&nbsp;<font color=FF0000>(</font>connection<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s<font color=FF0000>,</font>&nbsp;status<font color=FF0000>,</font>&nbsp;partial&nbsp;<font color=FF0000>=</font>&nbsp;connection<font color=FF0000>:</font>receive<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>^</font><font color=AC00A9>10</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s&nbsp;<font color=0000DF>or</font>&nbsp;partial<font color=FF0000>,</font>&nbsp;status
<font color=0000DF>end</font>
</pre>

<p>Для параллельной реализации эта функция должна получать данные без блокирования. Вместо этого если нет необходимых данных, то она вызывает <code>yield</code>. Новый код выглядит следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;receive&nbsp;<font color=FF0000>(</font>connection<font color=FF0000>)</font>
&nbsp;&nbsp;connection<font color=FF0000>:</font>settimeout<font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;не&nbsp;блокировать</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s<font color=FF0000>,</font>&nbsp;status<font color=FF0000>,</font>&nbsp;partial&nbsp;<font color=FF0000>=</font>&nbsp;connection<font color=FF0000>:</font>receive<font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>^</font><font color=AC00A9>10</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;status&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"timeout"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>(</font>connection<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s&nbsp;<font color=0000DF>or</font>&nbsp;partial<font color=FF0000>,</font>&nbsp;status
<font color=0000DF>end</font>
</pre>

<p>Вызов <code>settimeout(0)</code> делает любую операцию над соединением неблокирующей. Когда статус операции равен "<code>timeout</code>", это значит, что операция завершилась без выполнения запроса. В этом случае нить передает управление другой нити. Отличный от <b>false</b> аргумент, переданный <code>yield</code>, сообщает диспетчеру, что данная нить все еще выполняет свою задачу. Обратите внимание, что даже в случае статуса "<code>timeout</code>" в переменной <code>partial</code> все равно содержатся прочитанные данные.</p>

<p><a href="#листинг 9.4">Листинг 9.4</a>. содержит код диспетчера и дополнительный код. Таблица <code>threads</code> содержит список всех активных нитей для диспетчера. Функция <code>get</code> обеспечивает, что каждый скачиваемый файл скачивается в отдельной нити. Сам диспетчер - фактически это просто цикл, который перебирает все нити, запуская их на выполнение одну за другой. Также он удаляет из списка те нити, которые уже завершили скачивание. Цикл останавливается, когда больше не остается нитей.</p>

<p><a name="листинг 9.4"></a><b class="sect">Листинг 9.4</b>. Диспетчер</p>

<pre class="code">
threads&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;список&nbsp;всех&nbsp;работающих&nbsp;нитей</font>
<font color=0000DF>function</font>&nbsp;get&nbsp;<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;file<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;создать&nbsp;сопрограмму</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;download<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;file<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;вставить&nbsp;ее&nbsp;в&nbsp;список</font>
&nbsp;&nbsp;<font color=8000FF>table.insert</font><font color=FF0000>(</font>threads<font color=FF0000>,</font>&nbsp;co<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;dispatch&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;threads<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;больше&nbsp;нет&nbsp;нитей?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;threads<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>&nbsp;<font color=008000>--&nbsp;список&nbsp;пуст?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;перезапустить&nbsp;цикл</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;status<font color=FF0000>,</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>threads<font color=FF0000>[</font>i<font color=FF0000>])</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;res&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;нить&nbsp;завершила&nbsp;скачивание?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8000FF>table.remove</font><font color=FF0000>(</font>threads<font color=FF0000>,</font>&nbsp;i<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;переходим&nbsp;к&nbsp;следующей&nbsp;нити</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Наконец, главная процедура создает требуемые нити и вызывает диспетчер. Например, чтобы загрузить четыре документа с сайта <i>W3C</i>, главная программа может выглядеть, как показано ниже:</p>

<pre class="code">
host&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"www.w3.org"</font>
get<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;<font color=8888CC>"/TR/html401/html40.txt"</font><font color=FF0000>)</font>
get<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;<font color=8888CC>"/TR/2002/REC-xhtml1-20020801/xhtml1.pdf"</font><font color=FF0000>)</font>
get<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;<font color=8888CC>"/TR/REC-html32.html"</font><font color=FF0000>)</font>
get<font color=FF0000>(</font>host<font color=FF0000>,</font>&nbsp;<font color=8888CC>"/TR/2000/REC-DOM-Level-2-Core-20001113/DOM2-Core.txt"</font><font color=FF0000>)</font>

dispatch<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;main&nbsp;loop</font>
</pre>

<p>Ha моем компьютере скачивание этих четырех файлов с использованием сопрограмм занимает 6 секунд. С последовательным скачиванием это занимает больше, чем вдвое (15 секунд).</p>

<p>Несмотря на данную оптимизацию, эта последняя реализация еще далека от оптимальной. Все работает хорошо до тех пор, пока хотя бы у одной нити есть что читать. Однако когда ни у одной нити нет готовых для чтения данных, диспетчер постоянно переключается с нити на нить только для того, чтобы убедиться в том, что нет готовых данных. В результате эта реализация занимает почти в 30 раз больше времени CPU, чем последовательная версия.</p>

<p>Для того чтобы избежать подобной ситуации, мы можем использовать функцию <code>select</code> из библиотеки <i>LuaSocket</i>: она позволяет заблокировать программу, находящуюся в ожидании, пока изменится статус в группе соединений. Изменения в реализации незначительны: нам нужно изменить только диспетчер, как показано в <a href="#листинг 9.5">листинге 9.5</a>. В цикле новый диспетчер собирает в таблице <code>timedout</code> соединения, для которых нет готовых данных (Помните, что <code>receive</code> передает подобные соединения функции <code>yield</code>, таким образом снова запуская их). Если ни у одного соединения нет готовых данных, то диспетчер вызывает <code>select</code> для ожидания того, когда хотя бы у одного из этих соединений изменится статус. Эта окончательная реализация работает так же быстро, как и предыдущая. Однако она использует лишь немногим более времени CPU, чем последовательная реализация.</p>

<p><a name="листинг 9.5"></a><b class="sect">Листинг 9.5</b>. Диспетчер, использующий <code>select</code></p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;dispatch&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;timedout&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;threads<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;больше&nbsp;нитей&nbsp;нет?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;threads<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;начать&nbsp;цикл&nbsp;сначала</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timedout&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;status<font color=FF0000>,</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>threads<font color=FF0000>[</font>i<font color=FF0000>])</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;res&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;нить&nbsp;закончила&nbsp;свою&nbsp;работу?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8000FF>table.remove</font><font color=FF0000>(</font>threads<font color=FF0000>,</font>&nbsp;i<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;вышло&nbsp;время&nbsp;ожидания</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timedout<font color=FF0000>[#</font>timedout&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;res
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=FF0000>#</font>timedout&nbsp;<font color=FF0000>==</font>&nbsp;<font color=FF0000>#</font>threads&nbsp;<font color=0000DF>then</font>&nbsp;<font color=008000>--&nbsp;все&nbsp;нити&nbsp;блокированы?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket<font color=FF0000>.</font>select<font color=FF0000>(</font>timedout<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="9. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 9.1.</b><br>
Используйте сопрограммы для того, чтобы преобразовать <a href="#упражнение 5.4">упражнение 5.4</a> в генератор для комбинаций, который может быть использован следующим образом:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;c&nbsp;<font color=0000DF>in</font>&nbsp;combinations<font color=FF0000>({</font><font color=8888CC>"a"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"b"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"c"</font><font color=FF0000>},</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;printResult<font color=FF0000>(</font>c<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<hr color="#99CCFF">

<p><b>Упражнение 9.2.</b><br>
Реализуйте и запустите код из предыдущего раздела (невытесняющая многонитевость).</p>

<hr color="#99CCFF">

<p><b>Упражнение 9.3.</b><br>
Реализуйте функцию <code>transfer</code> на Lua. Если подумать о том, что вызовы <code>resume-yeild</code> аналогичны вызову функции и возврату из нее, то эта функция будет как <code>goto</code>: она прерывает текущую сопрограмму и возобновляет любую другую сопрограмму, переданную как аргумент (<i>Подсказка</i>: используйте аналог процедуры <code>dispatch</code> для управления вашими сопрограммами. Тогда <code>transfer</code> передаст управление диспетчеру, сообщая о том, какую следующую сопрограмму нужно запустить, и диспетчер вызовет для нее <code>resume</code>).</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 10. Законченные примеры"></a>Глава 10. Законченные примеры
</div>

<p>Заканчивая введение в язык, мы покажем три простые, но законченные программы. Первая программа решает задачу о восьми королевах. Вторая программа печатает самые часто встречающиеся слова в тексте. Последний пример - это реализация цепи Маркова, описанная Керниганом и Пайком в их книге «<i>The Practice of Programming</i>» (Addison-Wesley, 1999).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="10.1. Задача о восьми королевах"></a>10.1. Задача о восьми королевах
</div>

<p>Наш первый пример - это очень простая программа, которая решает <i>задачу о восьми королева</i>х: нужно так расставить восемь королев на шахматной доске, чтобы ни одна из королев не была под боем.</p>

<p>Первым шагом решения данной задачи нужно заметить, что у каждого решения должно быть ровно по одной королеве в каждой строке. Таким образом, мы можем представить решение как массив из восьми чисел, по одному для каждой строки; каждое число сообщает нам, в каком столбце расположена королева в соответствующей строке. Например, массив <code>{3,7,2,1,8,6,5,4}</code> обозначает, что одна королева находится в строке <code>1</code> в столбце <code>3</code>, другая - в строке <code>2</code> в столбце <code>7</code> и т. д. (Обратите внимание, что это не является допустимым решением; например, королева в строке <code>3</code> в столбце <code>2</code> нападает на королеву в строке <code>4</code> в столбце <code>1</code>). Также обратите внимание, что любое решение должно быть перестановкой чисел от <code>1</code> до <code>8</code>, так как решение должно содержать по одной королеве в каждом столбце.</p>

<p>Полная программа приведена в <a href="#10.1 XXXXX">листинге 10.1</a>. Первая функция - это <code>isplaceok</code>, которая проверяет, что заданная позиция на доске не попадает под бой ранее размещенных королев. Помня, что не может быть двух королев на одной строке, эта функция проверяет, что нет двух королев на одном столбце или одной диагонали с заданным положением.</p>

<p><a name="листинг 10.1"></a><b class="sect">Листинг 10.1</b>. Программа для восьми королев</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;N&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>8</font>&nbsp;<font color=008000>--&nbsp;размер&nbsp;доски</font>

<font color=008000>--&nbsp;проверяет,&nbsp;что&nbsp;положение(п,с)&nbsp;не&nbsp;находится&nbsp;под&nbsp;боем</font>
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;isplaceok&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;n<font color=FF0000>,</font>&nbsp;c<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;n&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>do</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;для&nbsp;каждой&nbsp;ранее&nbsp;размещенной&nbsp;королевы</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;c<font color=FF0000>)</font>&nbsp;<font color=0000DF>or</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;тот&nbsp;же&nbsp;столбец?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>-</font>&nbsp;i&nbsp;<font color=FF0000>==</font>&nbsp;c&nbsp;<font color=FF0000>-</font>&nbsp;n<font color=FF0000>)</font>&nbsp;<font color=0000DF>or</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;та&nbsp;же&nbsp;диагональ?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>+</font>&nbsp;i&nbsp;<font color=FF0000>==</font>&nbsp;c&nbsp;<font color=FF0000>+</font>&nbsp;n<font color=FF0000>)</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=008000>--&nbsp;та&nbsp;же&nbsp;диагональ?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>false</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;положение&nbsp;под&nbsp;боем</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=008000>--&nbsp;не&nbsp;под&nbsp;боем</font>
<font color=0000DF>end</font>

<font color=008000>--&nbsp;напечатать&nbsp;доску</font>
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;printsolution&nbsp;<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;N&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;j&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;N&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;j&nbsp;<font color=0000DF>and</font>&nbsp;<font color=8888CC>"X"</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=8888CC>"-"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"\n"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"\n"</font><font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=008000>--&nbsp;добавить&nbsp;к&nbsp;доске&nbsp;'а'&nbsp;всех&nbsp;королев&nbsp;от&nbsp;'п'&nbsp;до&nbsp;'N'</font>
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;addqueen&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>&gt;</font>&nbsp;N&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;все&nbsp;королевы&nbsp;были&nbsp;размещены?</font>
&nbsp;&nbsp;&nbsp;&nbsp;printsolution<font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;попытаться&nbsp;разместить&nbsp;n-ую&nbsp;королеву</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;N&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;isplaceok<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;n<font color=FF0000>,</font>&nbsp;c<font color=FF0000>)</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<font color=FF0000>[</font>n<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;поместить&nbsp;n-ую&nbsp;королеву&nbsp;в&nbsp;столбец&nbsp;'с'</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addqueen<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;n&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

<font color=008000>--&nbsp;запустить&nbsp;программу</font>
addqueen<font color=FF0000>({},</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>
</pre>

<p>Далее у нас идет функция <code>printsolution</code>, которая печатает шахматную доску. Она просто обходит всю доску, печатая '<code>X</code>' в местах с королевой и '<code>-</code>' во всех остальных местах. Каждый результат выглядит, как показано ниже:</p>

<pre class="code">
X - - - - - - -
- - - - X - - -
- - - - - - - X
- - - - - X - -
- - X - - - - -
- - - - - - X -
- - - X - - - -
</pre>

<p>Последняя функция <code>addqueen</code> является сердцем программы. Сначала она проверяет, является ли решение законченным, и если да, то печатает это решение. В противном случае она перебирает все столбцы; для каждого незанятого столбца программа помещает туда королеву и рекурсивно пытается разместить оставшихся королев.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="10.2. Самые часто встречающиеся слова"></a>10.2. Самые часто встречающиеся слова
</div>

<p>Наш следующий пример - это простая программа, которая читает текст и печатает самые часто встречающиеся слова из этого текста.</p>

<p>Главная структура данных данной программы - это просто таблица, которая сопоставляет каждому слову его частоту. С использованием этой структуры данных у программы есть три основные задачи:</p>

<ul>
  <li>Прочесть текст, посчитав число вхождений каждого слова.</li>
  <li>Отсортировать список слов по убыванию частоты встречаемости каждого слова.</li>
  <li>Напечатать первые n элементов из отсортированного списка.</li>
</ul>

<p>Для чтения текста мы можем использовать итератор <code>allwords</code>, который мы разобрали в <a href="#7.1. Итераторы и замыкания">разделе 7.1</a>. Для каждого слова, которое мы читаем, мы увеличиваем соответствующий счетчик:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;counter&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;allwords&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;counter<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>counter<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>end</font>
</pre>

<p>Следующая задача - это отсортировать список слов. Однако, как внимательный читатель мог заметить, у нас нет списка слов! Однако его легко создать, используя слова, которые являются ключами в таблице <code>counter</code>:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;words&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>counter<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;words<font color=FF0000>[#</font>words&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;w
<font color=0000DF>end</font>&nbsp;
</pre>

<p><a name="листинг 10.2"></a><b class="sect">Листинг 10.2</b>. Программа для печати самых часто встречающихся слов</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;allwords&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;auxwords&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;word&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>line<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%w+"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>(</font>word<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF8000>coroutine.wrap</font><font color=FF0000>(</font>auxwords<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>local</font>&nbsp;counter&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;allwords<font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;counter<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>counter<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>end</font>

<font color=0000DF>local</font>&nbsp;words&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>counter<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;words<font color=FF0000>[#</font>words&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;w
<font color=0000DF>end</font>

<font color=8000FF>table.sort</font><font color=FF0000>(</font>words<font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>w1<font color=FF0000>,</font>&nbsp;w2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;counter<font color=FF0000>[</font>w1<font color=FF0000>]</font>&nbsp;<font color=FF0000>&gt;</font>&nbsp;counter<font color=FF0000>[</font>w2<font color=FF0000>]</font>&nbsp;<font color=0000DF>or</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter<font color=FF0000>[</font>w1<font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;counter<font color=FF0000>[</font>w2<font color=FF0000>]</font>&nbsp;<font color=0000DF>and</font>&nbsp;w1&nbsp;<font color=FF0000>&lt;</font>&nbsp;w2
<font color=0000DF>end</font><font color=FF0000>)</font>

<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>(</font><font color=0080C0>tonumber</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>])</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>words<font color=FF0000>[</font>i<font color=FF0000>],</font>&nbsp;counter<font color=FF0000>[</font>words<font color=FF0000>[</font>i<font color=FF0000>]])</font>
<font color=0000DF>end</font>
</pre>

<p>Теперь, когда у нас есть список, мы можем отсортировать его при помощи функции <code>table.sort</code>, которую мы обсуждали в <a href="#Глава 6. Ещё о функциях">главе 6</a> :</p>

<pre class="code">
<font color=8000FF>table.sort</font><font color=FF0000>(</font>words<font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>w1<font color=FF0000>,</font>&nbsp;w2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;counter<font color=FF0000>[</font>w1<font color=FF0000>]</font>&nbsp;<font color=FF0000>&gt;</font>&nbsp;counter<font color=FF0000>[</font>w2<font color=FF0000>]</font>&nbsp;<font color=0000DF>or</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter<font color=FF0000>[</font>w1<font color=FF0000>]</font>&nbsp;<font color=FF0000>==</font>&nbsp;counter<font color=FF0000>[</font>w2<font color=FF0000>]</font>&nbsp;<font color=0000DF>and</font>&nbsp;w1&nbsp;<font color=FF0000>&lt;</font>&nbsp;w2
<font color=0000DF>end</font><font color=FF0000>)</font>
</pre>

<p>Полная программа приведена в <a href="#листинг 10.2">листинге 10.2</a>. Обратите внимание на использование сопрограмм в итераторе <code>auxwords</code>. В последнем цикле, печатающем результат, программа считает, что ее первый аргумент - это число слов, которое нужно напечатать, и использует значение <code>10</code>, если аргументов передано не было.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="10.3. Цепь Маркова"></a>10.3. Цепь Маркова
</div>

<p>Наш последний пример - это реализация цепи <i>Маркова</i>. Программа генерирует псевдослучайный текст на основании того, какие слова могут следовать за последовательностью из <code>n</code> предыдущих слов в тексте. Для этой реализации мы будем считать, что <code>n</code> равно <code>2</code>.</p>

<p>Первая часть читает основной текст и строит таблицу, которая для каждых двух слов дает список всех слов, которые могут за ними следовать в основном тексте. После построения таблицы программа использует ее для построения случайного текста, где каждое слово следует за двумя предыдущими с той же вероятностью, что и в базовом тексте. Как результат мы получаем текст, который случаен, но не совсем. Например, применив его к английскому тексту данной книги, мы получим тексты вроде «<i>Constructors can also traverse a table constructor, then the parentheses in the following line does the whole file in a field n to store the contents of each function, but to show its only argument. If you want to find the maximum element in an array can return both the maximum value and continues showing the prompt and running the code. The following words are reserved and cannot be used to convert between degrees and radians</i>».</p>

<p>Мы будем кодировать каждый префикс, соединяя два слова при помощи пробела:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;prefix&nbsp;<font color=FF0000>(</font>w1<font color=FF0000>,</font>&nbsp;w2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;w1&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;w2
<font color=0000DF>end</font>
</pre>

<p>Мы будем использовать строку <code>NOWORD("\n")</code> для инициализации префиксных слов и обозначения конца текста. Например, для текста «<i>the more we try the more we do</i>» таблица следующих далее слов будет выглядеть, как показано ниже:</p>

<pre class="code">
<font color=FF0000>{</font>&nbsp;<font color=FF0000>[</font><font color=8888CC>"\n&nbsp;\n"</font><font color=FF0000>]</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"the"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"\n&nbsp;the"</font><font color=FF0000>]</font>&nbsp;&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"more"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"the&nbsp;more"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"we"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"we"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"more&nbsp;we"</font><font color=FF0000>]</font>&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"try"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"do"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"we&nbsp;try"</font><font color=FF0000>]</font>&nbsp;&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"the"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"try&nbsp;the"</font><font color=FF0000>]</font>&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"more"</font><font color=FF0000>},</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"we&nbsp;do"</font><font color=FF0000>]</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"\n"</font><font color=FF0000>},</font>
<font color=FF0000>}</font>
</pre>

<p>Программа хранит свою таблицу в переменной <code>statetab</code>. Для того чтобы вставить в таблицу новое слово, мы будем использовать следующую функцию:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;insert&nbsp;<font color=FF0000>(</font>index<font color=FF0000>,</font>&nbsp;value<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;list&nbsp;<font color=FF0000>=</font>&nbsp;statetab<font color=FF0000>[</font>index<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;list&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;statetab<font color=FF0000>[</font>index<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>value<font color=FF0000>}</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;list<font color=FF0000>[#</font>list&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;value
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Она сначала проверяет, что у данного префикса уже есть список; если нет, то создает новый список с переданным словом. Иначе она вставляет переданное слово в конец существующего списка.</p>

<p>Для построения таблицы <code>statetab</code> мы будем использовать две переменные <code>wl</code> и <code>w2</code>, содержащие два последних прочитанных слова. Для каждого нового прочитанного слова мы добавляем его к списку, связанному с <code>wl-w2</code>, и затем обновляем значения <code>wl</code> и <code>w2</code>.</p>

<p>После построения таблицы программа начинает строить текст, состоящий из <code>MAXGEN</code> слов. Для начала она задает значения переменным <code>wl</code> и <code>w2</code>. Затем для каждого префикса она случайно выбирает следующее слово из списка допустимых слов, печатает это слово и обновляет значения <code>wl</code> и <code>w2</code>. <a href="#листинг 10.3">Листинги 10.3</a> и <a href="#листинг 10.4">10.4</a> содержат полную программу. В отличие от нашего предыдущего примера с наиболее часто встречающимися словами, здесь мы используем реализацию <code>allwords</code>, основанную на замыканиях.</p>

<p><a name="листинг 10.3"></a><b class="sect">Листинг 10.3</b>. Дополнительные определения для программы с цепью Маркова</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;allwords&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;текущая&nbsp;строка</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;pos&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;текущая&nbsp;положение&nbsp;в&nbsp;строке</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;итерирующая&nbsp;функция</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;line&nbsp;<font color=0000DF>do</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;повторять&nbsp;пока&nbsp;остались&nbsp;строки</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s<font color=FF0000>,</font>&nbsp;e&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>line<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%w+"</font><font color=FF0000>,</font>&nbsp;pos<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;s&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;нашли&nbsp;слово?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;<font color=FF0000>=</font>&nbsp;e&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;обновить&nbsp;положение</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.sub</font><font color=FF0000>(</font>line<font color=FF0000>,</font>&nbsp;s<font color=FF0000>,</font>&nbsp;e<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;вернуть&nbsp;слово</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;слово&nbsp;не&nbsp;найдено;&nbsp;попробуем&nbsp;след.&nbsp;строку</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;начать&nbsp;с&nbsp;начала&nbsp;строки</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;больше&nbsp;строк&nbsp;нет,&nbsp;конец&nbsp;обхода</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;prefix&nbsp;<font color=FF0000>(</font>w1<font color=FF0000>,</font>&nbsp;w2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;w1&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;w2
<font color=0000DF>end</font>

<font color=0000DF>local</font>&nbsp;statetab&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>

<font color=0000DF>function</font>&nbsp;insert&nbsp;<font color=FF0000>(</font>index<font color=FF0000>,</font>&nbsp;value<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;list&nbsp;<font color=FF0000>=</font>&nbsp;statetab<font color=FF0000>[</font>index<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;list&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;statetab<font color=FF0000>[</font>index<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>value<font color=FF0000>}</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;list<font color=FF0000>[#</font>list&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;value
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p><a name="листинг 10.4"></a><b class="sect">Листинг 10.4</b>. Программа для цепи Маркова</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;N&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>2</font>
<font color=0000DF>local</font>&nbsp;MAXGEN&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10000</font>
<font color=0000DF>local</font>&nbsp;NOWORD&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"\n"</font>

<font color=008000>--&nbsp;построить&nbsp;таблицу</font>
<font color=0000DF>local</font>&nbsp;w1<font color=FF0000>,</font>&nbsp;w2&nbsp;<font color=FF0000>=</font>&nbsp;NOWORD<font color=FF0000>,</font>&nbsp;NOWORD
<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;allwords<font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;insert<font color=FF0000>(</font>prefix<font color=FF0000>(</font>w1<font color=FF0000>,</font>&nbsp;w2<font color=FF0000>),</font>&nbsp;w<font color=FF0000>)</font>
&nbsp;&nbsp;w1&nbsp;<font color=FF0000>=</font>&nbsp;w2<font color=FF0000>;</font>&nbsp;w2&nbsp;<font color=FF0000>=</font>&nbsp;w<font color=FF0000>;</font>
<font color=0000DF>end</font>
insert<font color=FF0000>(</font>prefix<font color=FF0000>(</font>w1<font color=FF0000>,</font>&nbsp;w2<font color=FF0000>),</font>&nbsp;NOWORD<font color=FF0000>)</font>

<font color=008000>--&nbsp;сгенерировать&nbsp;текст</font>
w1&nbsp;<font color=FF0000>=</font>&nbsp;NOWORD<font color=FF0000>;</font>&nbsp;w2&nbsp;<font color=FF0000>=</font>&nbsp;NOWORD&nbsp;<font color=008000>--&nbsp;инициализировать</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;MAXGEN&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;list&nbsp;<font color=FF0000>=</font>&nbsp;statetab<font color=FF0000>[</font>prefix<font color=FF0000>(</font>w1<font color=FF0000>,</font>&nbsp;w2<font color=FF0000>)]</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;выбрать&nbsp;случайное&nbsp;слово&nbsp;из&nbsp;списка</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;r&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.random</font><font color=FF0000>(#</font>list<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;nextword&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>[</font>r<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;nextword&nbsp;<font color=FF0000>==</font>&nbsp;NOWORD&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>nextword<font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;"</font><font color=FF0000>)</font>
&nbsp;&nbsp;w1&nbsp;<font color=FF0000>=</font>&nbsp;w2<font color=FF0000>;</font>&nbsp;w2&nbsp;<font color=FF0000>=</font>&nbsp;nextword
<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="10. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 10.1.</b><br>
Измените программу с восьми королевами, чтобы она останавливалась после печати первого решения.</p>

<hr color="#99CCFF">

<p><b>Упражнение 10.2.</b><br>
Альтернативной реализацией задачи о восьми королевах может быть построение всех перестановок чисел от <code>1</code> до <code>8</code> и проверка, какие из них допустимы. Измените программу для использования этого подхода. Как отличается быстродействие новой программы но сравнению со старой? (<i>Подсказка</i>: сравните полное число перестановок с числом раз, когда исходная программа вызывает функцию <code>isplaceok</code>.)</p>

<hr color="#99CCFF">

<p><a name="упражнение 10.3"></a><b>Упражнение 10.3.</b><br>
Когда мы применяем программу определения самых часто встречаемых слов, то обычно самыми часто встречаемыми словами оказываются короткие неинтересные слова вроде артиклей и предлогов. Измените программу так, чтобы она пропускала слова, состоящие из менее чем четырех букв.</p>

<hr color="#99CCFF">

<p><b>Упражнение 10.4.</b><br>
Обобщите алгоритм цепи Маркова так, чтобы можно было использовать любой размер в качестве длины префикса.</p>

<!-- ================================================================================ -->
<div class="part">
 ЧАСТЬ II. Таблицы и обьекты
</div>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 11. Структуры данных"></a>Глава 11. Структуры данных
</div>

<p>Таблицы в Lua -- это не просто структура данных, - это основная и единственная структура данных. Все структуры, которые предлагают другие языки, - массивы, записи, списки, очереди, множества - могут быть представлены в Lua при помощи таблиц. Более того, таблицы в Lua эффективно реализуют все эти структуры.</p>

<p>В традиционных языках, таких как <i>С</i> и <i>Pascal</i>, мы реализуем большинство структур данных при помощи массивов и списков (где списки = записи + указатели). Хотя мы можем реализовать массивы и списки при помощи таблиц в Lua(и иногда мы это делаем), таблицы гораздо более мощные, чем массивы и списки; многие алгоритмы с использованием таблиц становятся почти тривиальными. Например, мы редко используем поиск в Lua, поскольку таблицы предоставляют прямой доступ к значениям различных типов.</p>

<p>Требуется время, чтобы попять, как эффективно использовать таблицы в Lua. В этой главе я покажу, как реализовать типичные структуры данных при помощи таблиц, и приведу примеры их использования. Мы начнем с массивов и списков не потому, что они понадобятся нам для других структур, но поскольку большинство программистов уже знакомы с ними. Мы уже видели основу этого материала в предыдущих главах, но я также повторю его здесь.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="11.1. Массивы"></a>11.1. Массивы
</div>

<p>Мы реализуем массивы в Lua, просто индексируя таблицы целыми числами. Таким образом, массивы не имеют фиксированного размера и растут по необходимости. Обычно при инициализации массива мы неявно задаем его размер. Например, после выполнения следующего кода любая попытка обратиться к полю вне диапазона <code>1-1000</code> вернет <b>nil</b> вместо <code>0</code>:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;новый&nbsp;массив</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1000</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>end</font>
</pre>

<p>Оператор длины('<code>#</code>') использует это для определения длины массива:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(#</font>a<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;1000</font></pre>

<p>Вы можете начать массив с нуля или любого другого значения:</p>

<pre class="code">
<font color=008000>--&nbsp;создаем&nbsp;массив&nbsp;с&nbsp;индексами&nbsp;от&nbsp;-5&nbsp;до&nbsp;5</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>5</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>5</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>end</font>
</pre>

<p>Однако обычно в Lua принято начинать массивы с индекса <code>1</code>. Библиотеки Lua следуют этому соглашению; так же как и оператор длины. Если ваши массивы не начинаются с <code>1</code>, то вы не сможете использовать эти возможности языка.</p>

<p>Мы можем использовать конструктор для создания и инициализации массива одним выражением:</p>

<pre class="code">squares&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>9</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>16</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>25</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>36</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>49</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>64</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>81</font><font color=FF0000>}</font></pre>

<p>Подобные конструкторы могут быть настолько большими, насколько это нужно(по крайней мере, до нескольких миллионов элементов).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="11.2. Матрицы и многомерные массивы"></a>11.2. Матрицы и многомерные массивы
</div>

<p>Есть два основных способа представления матриц в Lua. Первый -это использовать массив массивов, то есть таблицу, каждый элемент которой является другой таблицей. Например, можно создать матрицу из пулей размером <code>М</code> на <code>N</code> при помощи следующего кода:</p>

<pre class="code">
mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;создать&nbsp;матрицу</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;N&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;mt<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;создать&nbsp;строку</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;j&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;M&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;mt<font color=FF0000>[</font>i<font color=FF0000>][</font>j<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Поскольку таблицы являются обьектами в Lua, для создания матрицы нужно явно создавать каждую строку. С одной стороны, это более громоздко, чем просто обьявить матрицу, как это делается в языках С и Pascal. С другой - это дает больше гибкости. Например, вы можете создать треугольную матрицу, изменив цикл <code>for j=l,M do...end</code> в предыдущем фрагменте кода на <code>for j=l, i do...end</code>. С этим кодом треугольная матрица будет использовать только половину памяти по сравнению с исходным примером.</p>

<p>Второй способ представления матриц в Lua заключается в обьединении двух индексов в один. Если оба индекса являются целыми числами, то вы можете просто умножить первый на соответствующую константу и добавить второй индекс. С этим подходом следующий код создаст нашу матрицу из нулей размером <code>М</code> на <code>N</code>:</p>

<pre class="code">
mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;создать&nbsp;матрицу</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;N&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;j&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;M&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;mt<font color=FF0000>[(</font>i&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)*</font>M&nbsp;<font color=FF0000>+</font>&nbsp;j<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Если индексы являются строками, то вы можете создать один индекс, просто соединив эти строки с некоторым символом между ними. Например, вы можете создать матрицу <code>m</code> со строковыми индексами <code>s</code> и <code>t</code> при помощи следующего кода <code>m[s..":".. t]</code>, при условии, что и <code>s</code>, и <code>t</code> не содержат двоеточия; в противном случае пары вроде <code>("а: ", "Ь")</code> и <code>("а", " :Ь")</code> обе дадут один и тот же индекс <code>"а::Ь"</code>. Когда сомневаетесь, то вы можете использовать управляющий символ вроде <code>'\0'</code> для разделения индексов.</p>

<p>Довольно часто приложения используют разреженную матрицу, то есть матрицу, где большинство элементов - либо <code>0</code>, либо <b>nil</b>. Например, вы можете представить граф при помощи его матрицы связности, в которой значение в позиции <code>m</code>, <code>n</code> равно <code>х</code>, если между узлами <code>m</code> и <code>n</code> есть соединение ценой <code>х</code>. Когда эти узлы не соединены, то значение в позиции <code>m</code>, <code>n</code> равно <b>nil</b>. Для того чтобы представить граф с десятью тысячами узлов, где каждый узел имеет около пяти соседей, вам нужна матрица со ста миллионами возможных элементов, но только пятьдесят тысяч из них будут не равны <b>nil</b> (пять ненулевых столбцов для каждой строки, соответствующих пяти соседям). Многие книги по структурам данных детально обсуждают, как можно реализовать подобные разреженные матрицы, не тратя на них 400 Мб памяти, но вам редко понадобятся подобные приемы при программировании на Lua. С нашим первым представлением (таблица таблиц) вам понадобятся десять тысяч таблиц, каждая из которых содержит около пяти элементов, то есть всего около пятидесяти тысяч значений. При втором представлении у нас будет одна таблица с пятьюдесятью тысячами элементов. Какое бы представление вы не использовали, вам понадобится память только для элементов, отличных от <b>nil</b>.</p>

<p>При работе с разреженными матрицами мы не можем использовать оператор длины из-за дырок (значений <b>nil</b>) между элементами. Однако это не большая потеря; даже если бы мы могли его использовать, то делать этого не стоило бы. Для большинства операций было крайне неэффективно перебирать все эти пустые элементы. Вместо этого мы можем использовать <code>pairs</code> для обхода только элементов, отличных от <b>nil</b>. Например, для того чтобы умножить строку на константу, мы можем использовать следующий код:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;mult&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;rowindex<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;row&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font>rowindex<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>row<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;row<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;v&nbsp;<font color=FF0000>*</font>&nbsp;k
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Обратите внимание, однако, что ключи не имеют какого-то определенного порядка в таблице, поэтому итерирование при помощи <code>pairs</code> не гарантирует, что мы посетим все столбцы по возрастанию. Для некоторых задач (например, нашего предыдущего примера) это не проблема. Для других целей вы можете использовать отличные представления, например связанные списки.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="11.3. Связанные списки"></a>11.3. Связанные списки
</div>

<p>Поскольку таблицы являются динамическими сущностями, то реализовать связанные списки в Lua довольно легко. Каждый узел представлен таблицей, и ссылки являются просто полями таблицы, которые содержат ссылки на другие таблицы. Например, давайте реализуем простейший список, где каждый узел содержит два поля, <code>next</code> и <code>value</code>. Корнем списка является обычная переменная:</p>

<pre class="code">list&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font></pre>

<p>Для того чтобы вставить элемент со значением <code>v</code> в начало списка, мы делаем:</p>

<pre class="code">list&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=0080C0>next</font>&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>,</font>&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;v<font color=FF0000>}</font></pre>

<p>Для обхода списка мы можем написать:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;l&nbsp;<font color=FF0000>=</font>&nbsp;list
<font color=0000DF>while</font>&nbsp;l&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>visit&nbsp;l<font color=FF0000>.</font>value<font color=FF0000>&gt;</font>
&nbsp;&nbsp;l&nbsp;<font color=FF0000>=</font>&nbsp;l<font color=FF0000>.</font>next
<font color=0000DF>end</font>
</pre>

<p>Другие варианты списков, например двунаправленные или круговые списки, также легко реализуются. Однако подобные структуры вам редко понадобятся в Lua, поскольку обычно есть более простой способ представления ваших данных без использования связанных списков. Например, мы можем представить стек как (неограниченный) массив.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="11.4. Очереди и двойные очереди"></a>11.4. Очереди и двойные очереди
</div>

<p>Простейшим способом реализации очередей в Lua является использование функций <code>insert</code> и <code>remove</code> из библиотеки <code>table</code>. Эти функции вставляют и удаляют элементы из произвольной позиции массива, передвигая остальные элементы массива. Однако подобные перемещения могут быть дорогими для больших структур. Более эффективная реализация использует две индекса, один для первого элемента и один для последнего:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;ListNew&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>{</font>first&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;last&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>1</font><font color=FF0000>}</font>
<font color=0000DF>end</font>
</pre>

<p>Для того чтобы не загрязнять глобальное пространство имен, мы определим все операции по работе со списком внутри таблицы, которую мы назовем <code>list</code> (таким образом, мы создадим <i>модуль</i>). Тогда мы можем переписать наш последний пример следующим образом:</p>

<pre class="code">
List&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>function</font>&nbsp;List<font color=FF0000>.</font>new&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>{</font>first&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;last&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>1</font><font color=FF0000>}</font>
<font color=0000DF>end</font>
</pre>

<p>Теперь мы можем вставлять и удалять элементы с любого конца за постоянное время:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;List<font color=FF0000>.</font>pushfirst&nbsp;<font color=FF0000>(</font>list<font color=FF0000>,</font>&nbsp;value<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;first&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>.</font>first&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;list<font color=FF0000>.</font>first&nbsp;<font color=FF0000>=</font>&nbsp;first
&nbsp;&nbsp;list<font color=FF0000>[</font>first<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;value
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;List<font color=FF0000>.</font>pushlast&nbsp;<font color=FF0000>(</font>list<font color=FF0000>,</font>&nbsp;value<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;last&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>.</font>last&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;list<font color=FF0000>.</font>last&nbsp;<font color=FF0000>=</font>&nbsp;last
&nbsp;&nbsp;list<font color=FF0000>[</font>last<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;value
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;List<font color=FF0000>.</font>popfirst&nbsp;<font color=FF0000>(</font>list<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;first&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>.</font>first
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;first&nbsp;<font color=FF0000>&gt;</font>&nbsp;list<font color=FF0000>.</font>last&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"list&nbsp;is&nbsp;empty"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>[</font>first<font color=FF0000>]</font>
&nbsp;&nbsp;list<font color=FF0000>[</font>first<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=008000>--&nbsp;позволим&nbsp;сборщику&nbsp;мусора&nbsp;его&nbsp;удалить</font>
&nbsp;&nbsp;list<font color=FF0000>.</font>first&nbsp;<font color=FF0000>=</font>&nbsp;first&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;value
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;List<font color=FF0000>.</font>poplast&nbsp;<font color=FF0000>(</font>list<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;last&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>.</font>last
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;list<font color=FF0000>.</font>first&nbsp;<font color=FF0000>&gt;</font>&nbsp;last&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"list&nbsp;is&nbsp;empty"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>[</font>last<font color=FF0000>]</font>
&nbsp;&nbsp;list<font color=FF0000>[</font>last<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=008000>--&nbsp;позволим&nbsp;сборщику&nbsp;мусора&nbsp;его&nbsp;удалить</font>
&nbsp;&nbsp;list<font color=FF0000>.</font>last&nbsp;<font color=FF0000>=</font>&nbsp;last&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;value
<font color=0000DF>end</font>
</pre>

<p>Если вы будете использовать эту структуру классическим способом, вызывая только <code>pushlast</code> и <code>popfirst</code>, то и <code>first</code>, и <code>last</code> будут постоянно расти. Однако так как мы представляем массивы в Lua при помощи таблиц, вы спокойно можете индексировать их с <code>1</code> до <code>20</code> или с <code>16 777 216</code> до <code>16 777 236</code>. Поскольку Lua использует числа с двойной точностью для представления чисел, ваша программа можем работать на протяжении двухсот лет, делая по миллиону вставок в секунду, прежде чем возникнет проблема с переполнением.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="11.5. Множества и наборы"></a>11.5. Множества и наборы
</div>

<p>Предположим, вы хотите перебрать все идентификаторы, используемые в программе; каким-то образом вам нужно отфильтровывать зарезервированные слова. Некоторые программисты на С могут попытаться использовать для представления множества зарезервированных слов массив строк и затем для проверки того, является ли заданное слово зарезервированным, осуществлять поиск в этом массиве. Для ускорения поиска вы можете даже использовать бинарное дерево для представления множества.</p>

<p>В Lua эффективным и простым способом представления множеств будет использовать элементы как <i>индексы</i> в таблице. Тогда вместо поиска, содержит ли таблица заданное слово, можно просто попро-бовать проиндексировать таблицу этим словом и посмотреть, равен ли полученный результат <b>nil</b>. Для примера мы можем использовать следующий код:</p>

<pre class="code">
reserved&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"while"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=8888CC>"end"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font><font color=FF0000>,</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"function"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>[</font><font color=8888CC>"local"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font><font color=FF0000>,</font>
<font color=FF0000>}</font>

<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;allwords<font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;reserved<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>&lt;</font><font color=0000DF>do</font>&nbsp;something&nbsp;with&nbsp;’w’<font color=FF0000>&gt;</font>&nbsp;<font color=008000>--&nbsp;'w'&nbsp;незарезервированное&nbsp;слово</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>(Поскольку эти слова зарезервированы в Lua, то мы не можем использовать их в качестве идентификаторов; например, мы не можем записать <code>while = true</code>. Вместо этого мы пишем <code>["while"] = true</code>.)</p>

<p>Вы можете также использовать более ясную инициализацию при помощи дополнительной функции, которая строит множество:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;Set&nbsp;<font color=FF0000>(</font>list<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;set&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;_<font color=FF0000>,</font>&nbsp;l&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>ipairs</font><font color=FF0000>(</font>list<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;set<font color=FF0000>[</font>l<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;set
<font color=0000DF>end</font>

reserved&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>{</font><font color=8888CC>"while"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"end"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"function"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"local"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>}</font>
</pre>

<p>Наборы, также называемые <i>мультимножествами</i>, отличаются от обычных множеств тем, что каждый элемент может встречаться несколько раз. Простое представление наборов в Lua похоже на предыдущее представление для множеств, но с каждым ключом связан соответствующий счетчик. Для того чтобы вставить элемент, мы увеличиваем его счетчик:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;insert&nbsp;<font color=FF0000>(</font>bag<font color=FF0000>,</font>&nbsp;element<font color=FF0000>)</font>
&nbsp;&nbsp;bag<font color=FF0000>[</font>element<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>bag<font color=FF0000>[</font>element<font color=FF0000>]</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>end</font>
</pre>

<p>Для удаления элемента мы уменьшаем его счетчик:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;remove&nbsp;<font color=FF0000>(</font>bag<font color=FF0000>,</font>&nbsp;element<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;bag<font color=FF0000>[</font>element<font color=FF0000>]</font>
&nbsp;&nbsp;bag<font color=FF0000>[</font>element<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>count&nbsp;<font color=0000DF>and</font>&nbsp;count&nbsp;<font color=FF0000>&gt;</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>and</font>&nbsp;count&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=0000DF>nil</font>
<font color=0000DF>end</font>
</pre>

<p>Мы храним счетчик, только если он уже существует и не равен нулю.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="11.6. Строчные буферы"></a>11.6. Строчные буферы
</div>

<p>Пусть вы работаете с текстом и читаете файл строка за строкой. Тогда ваш код может выглядеть следующим образом:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;buff&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>""</font>
<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;buff&nbsp;<font color=FF0000>=</font>&nbsp;buff&nbsp;<font color=FF0000>..</font>&nbsp;line&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"\n"</font>
<font color=0000DF>end</font>
</pre>

<p>Несмотря на его безобидный вид, этот код может сильно ударить по быстродействию для больших файлов: например, чтение файла в 1 Мб занимает 1,5 минуты на моем старом компьютере (это одноядерный 32-битный Pentium 3 ГГц. Все быстродействие для этой книги измерялось на этом компьютере).</p>

<p>Почему это так? Чтобы понять, что происходит, представим, что мы находимся внутри цикла; каждая строка состоит из 20 байтов, и мы уже прочли 2500 строк, поэтому <code>buff</code> - это 50 Кб строка. Когда Lua соединяет <code>buff..line.."\n"</code>; она выделяет новую строку в 50 020 байт и копирует 50 000 байт из <code>buff</code> в эту новую строку. Таким образом для каждой новой строки Lua перемещает в памяти примерно 50 Кб, и этот размер только растет. Более точно этот алгоритм имеет квадратичную сложность. После прочтения 100 новых строк (всего 2 Кб) Lua уже переместил более 2 Мб памяти. Когда Lua завершит чтение 350 Кб, уже будет перемещено в памяти более 50 Гб(эта проблема свойственна не только Lua: другие языки, где строки неизменяемы, также сталкиваются с подобной проблемой, наиболее известным примером такого языка является Java).</p>

<p>Прежде чем мы продолжим, необходимо заметить, что, несмотря на все сказанное, это не типичная проблема. Для маленьких строк приведенный выше цикл отлично работает. Для чтения всего файла Lua предоставляет <code>io.read("*а")</code>, данный вызов читает сразу весь файл. Однако иногда мы сталкиваемся с этой проблемой. Для борьбы с подобной проблемой Java использует структуру <code>stringBuffer</code>. В Lua в качестве строкового буфера мы можем использовать таблицу. Ключом к этому подходу является функция <code>table.concat</code>, которая возвращает результат конкатенации всех строк из заданного списка. При помощи <code>concat</code> мы можем переписать наш предыдущий код следующим образом:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;t<font color=FF0000>[#</font>t&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;line&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"\n"</font>
<font color=0000DF>end</font>
<font color=0000DF>local</font>&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>table.concat</font><font color=FF0000>(</font>t<font color=FF0000>)</font>
</pre>

<p>Этот алгоритм требует менее 0,5 секунды для чтения того же самого файла, который требовал почти минуту с ранее использованным кодом (Несмотря на это, для чтения всего файла лучше использовать <code>io.read</code> с опцией <code>"*а"</code>.)</p>

<p>Мы можем сделать даже лучше. Функция <code>concat</code> берет на вход второй необязательный аргумент, который является разделителем, который будет вставляться между строками. Используя этот сепаратор, мы можем избавиться от необходимости вставлять каждый раз символ <code>'\n'</code>:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;t<font color=FF0000>[#</font>t&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;line
<font color=0000DF>end</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>table.concat</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"\n"</font>
</pre>

<p>Функция <code>concat</code> вставляет разделитель между строками, по нам все равно нужно добавить один последний символ <code>'\n'</code>. Эта последняя операция конкатенации копирует получаемую строку, что может потребовать заметного времени. Не существует способа заставить <code>concat</code> вставить дополнительный разделитель, но мы можем легко добиться этого, просто добавив в <code>t</code> пустую строку:</p>

<pre class="code">
t<font color=FF0000>[#</font>t&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>""</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>table.concat</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
</pre>

<p>Дополнительный символ <code>'\n'</code>, который <code>concat</code> добавит перед последней строкой, -- это то, что нам нужно.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="11.7. Графы"></a>11.7. Графы
</div>

<p>Как и любой разумный язык, Lua предлагает различные реализации для графов, каждый из которых лучше подходит для своего типа алгоритмов. Здесь мы рассмотрим простую обьектно-ориентированную реализацию, в которой мы будем представлять узлы как обьекты (точнее, таблицы, конечно) и дуги как ссылки между узлами.</p>

<p>Мы будем представлять каждый узел как таблицу с двумя полями: <code>name</code>, являющийся именем узла, и <code>adj</code>, являющийся множеством узлов, соединенных с данным. Поскольку мы будем читать граф из текстового файла, нам будет нужен способ найти узел по его имени. Для этого мы будем использовать дополнительную таблицу. Функция <code>паme2node</code>, получив имя узла, будет возвращать данный узел:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;name2node&nbsp;<font color=FF0000>(</font>graph<font color=FF0000>,</font>&nbsp;name<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;node&nbsp;<font color=FF0000>=</font>&nbsp;graph<font color=FF0000>[</font>name<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;node&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;узла&nbsp;еще&nbsp;нет,&nbsp;создать&nbsp;новый</font>
&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>name&nbsp;<font color=FF0000>=</font>&nbsp;name<font color=FF0000>,</font>&nbsp;adj&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}}</font>
&nbsp;&nbsp;&nbsp;&nbsp;graph<font color=FF0000>[</font>name<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;node
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;node
<font color=0000DF>end</font>
</pre>

<p><a href="#листинг 11.1">Листинг 11.1</a> содержит функцию, которая будет строить граф. Она читает файл, где каждая строка содержит имена двух узлов, обозначая что есть дуга, ведущая от первого узла ко второму. Для каждой строки она использует функцию <code>string.match</code>, для того чтобы разбить строку на два имени, далее находит соответствующие узлы (создавая их при необходимости) и соединяет их.</p>

<p><a name="листинг 11.1"></a><b class="sect">Листинг 11.1</b>. Чтение графа из файла</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;readgraph&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;graph&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;разбить&nbsp;строку&nbsp;на&nbsp;два&nbsp;имени</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;namefrom<font color=FF0000>,</font>&nbsp;nameto&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.match</font><font color=FF0000>(</font>line<font color=FF0000>,</font>&nbsp;<font color=8888CC>"(%S+)%s+(%S+)"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;find&nbsp;corresponding&nbsp;nodes</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;from&nbsp;<font color=FF0000>=</font>&nbsp;name2node<font color=FF0000>(</font>graph<font color=FF0000>,</font>&nbsp;namefrom<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;to&nbsp;<font color=FF0000>=</font>&nbsp;name2node<font color=FF0000>(</font>graph<font color=FF0000>,</font>&nbsp;nameto<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;добавить&nbsp;'to'&nbsp;к&nbsp;списку&nbsp;связей&nbsp;узла&nbsp;'from'</font>
&nbsp;&nbsp;&nbsp;&nbsp;from<font color=FF0000>.</font>adj<font color=FF0000>[</font>to<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;graph
<font color=0000DF>end</font>
</pre>

<p><a href="#листинг 11.2">Листинг 11.2</a> иллюстрирует алгоритм, использующий подобные графы. Функция <code>findpath</code> ищет путь между двумя узлами, используя обход в глубину. Ее первый параметр - это текущий узел; второй задает желаемый узел; третий параметр хранит путь от начала к текущему узлу; последний параметр - это множество всех уже посещенных узлов (чтобы избежать циклов). Обратите внимание, как алгоритм напрямую работает с узлами, избегая использования их имен. Например, <code>visited</code> - это множество узлов, а не имен узлов. Аналогично <code>path</code> - это список узлов.</p>

<p><a name="листинг 11.2"></a><b class="sect">Листинг 11.2</b>. Нахождение пути между двумя узлами</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;findpath&nbsp;<font color=FF0000>(</font>curr<font color=FF0000>,</font>&nbsp;to<font color=FF0000>,</font>&nbsp;path<font color=FF0000>,</font>&nbsp;visited<font color=FF0000>)</font>
&nbsp;&nbsp;path&nbsp;<font color=FF0000>=</font>&nbsp;path&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;visited&nbsp;<font color=FF0000>=</font>&nbsp;visited&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;visited<font color=FF0000>[</font>curr<font color=FF0000>]</font>&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;<font color=008000>--&nbsp;узел&nbsp;уже&nbsp;посещен?</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;здесь&nbsp;пути&nbsp;нет</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;visited<font color=FF0000>[</font>curr<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;пометим&nbsp;узел&nbsp;как&nbsp;посещенный</font>
&nbsp;&nbsp;path<font color=FF0000>[#</font>path&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;curr&nbsp;<font color=008000>--&nbsp;добавим&nbsp;к&nbsp;пути</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;curr&nbsp;<font color=FF0000>==</font>&nbsp;to&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;цель?</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;path
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;попробуем&nbsp;все&nbsp;соседние&nbsp;узлы</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;node&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>curr<font color=FF0000>.</font>adj<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;p&nbsp;<font color=FF0000>=</font>&nbsp;findpath<font color=FF0000>(</font>node<font color=FF0000>,</font>&nbsp;to<font color=FF0000>,</font>&nbsp;path<font color=FF0000>,</font>&nbsp;visited<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;p&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;p&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;path<font color=FF0000>[#</font>path<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;удалить&nbsp;узел&nbsp;из&nbsp;пути</font>
<font color=0000DF>end</font>
</pre>

<p>Для проверки этого кода мы добавим функцию, которая печатает путь, и дополнительный код, чтобы это все заработало:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;printpath&nbsp;<font color=FF0000>(</font>path<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>path&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>path<font color=FF0000>[</font>i<font color=FF0000>].</font>name<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

g&nbsp;<font color=FF0000>=</font>&nbsp;readgraph<font color=FF0000>()</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;name2node<font color=FF0000>(</font>g<font color=FF0000>,</font>&nbsp;<font color=8888CC>"a"</font><font color=FF0000>)</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;name2node<font color=FF0000>(</font>g<font color=FF0000>,</font>&nbsp;<font color=8888CC>"b"</font><font color=FF0000>)</font>
p&nbsp;<font color=FF0000>=</font>&nbsp;findpath<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
<font color=0000DF>if</font>&nbsp;p&nbsp;<font color=0000DF>then</font>&nbsp;printpath<font color=FF0000>(</font>p<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="11. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 11.1.</b><br>
Измените реализацию очереди так, чтобы оба индекса были бы равны нулю, если очередь пуста.</p>

<hr color="#99CCFF">

<p><b>Упражнение 11.2.</b><br>
Повторите <a href="#упражнение 10.3">упражнение 10.3</a>, только, вместо того чтобы использовать длину как критерий для отбрасывания слова, теперь программа должна прочесть из специального файла список слов, которые нужно пропускать.</p>

<hr color="#99CCFF">

<p><b>Упражнение 11.3.</b><br>
Измените структуру графа так, чтобы она содержала метку для каждой дуги. Каждая дуга также должна быть представлена при помощи обьекта с двумя полями: меткой и узлов, на который она показывает. Вместо множества соседних узлов каждый узел должен содержать список дуг, исходящих из данного узла.</p>

<p>Измените функцию <code>readgraph</code> так, чтобы она из каждой строки файла читала два имени узлов и метку (считая, что метка это число).</p>

<hr color="#99CCFF">

<p><b>Упражнение 11.4.</b><br>
Используйте представление графа из предыдущего упражнения, где метка каждой дуги представляет собой расстояние между соединяемыми ей узлами. Напишите функцию, которая находит кратчайший путь между двумя узлами (<i>Подсказка</i>: Используйте алгоритм Дейкстры).</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 12. Файлы данных и персистентность"></a>Глава 12. Файлы данных и персистентность
</div>

<p>При работе с файлами с данными обычно гораздо проще писать файлы, чем их читать. Когда мы пишем в файл, мы полностью контролируем все, что происходит. С другой стороны, когда мы читаем из файла, то мы не знаем, чего ждать. Помимо всех типов данных, который корректный файл с данными может содержать, программа также должна разумно обрабатывать и плохие файлы. Поэтому написание корректно работающих процедур для чтения данных всегда сложно.</p>

<p>В этой главе мы увидим, как можно использовать Lua для того, чтобы устранить весь код по чтению данных из наших программ, просто записывая данные в подходящем формате.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="12.1. Файлы с данными"></a>12.1. Файлы с данными
</div>

<p>Конструкторы таблиц представляют интересную альтернативу форматам данных. При помощи небольшой дополнительной работы при записи данных чтение становится тривиальным. Подход заключается в том, чтобы писать наш файл с данными как программу на Lua, которая при выполнении создает необходимые данные.</p>

<p>Как обычно, для того чтобы было ясно, давайте рассмотрим пример. Если наш файл с данными находится в определенном формате, например <i>CSV</i> или <i>XML</i>, то наш выбор крайне мал. Однако если мы хотим создать файл для нашего собственного использования, то мы в качестве нашего формата можем использовать конструкторы Lua. В этом формате мы представляем каждую запись как конструктор Lua. Вместо записи в наш файл чего-то вроде</p>

<pre class="code">
Donald Е. Knuth,Literate Programming,CSLI,1992
Jon Bentley,More Programming Pearls,Addison-Wesley,1990
</pre>

<p>мы пишем:</p>

<pre class="code">
Entry<font color=FF0000>{</font><font color=8888CC>"Donald&nbsp;E.&nbsp;Knuth"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8888CC>"Literate&nbsp;Programming"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8888CC>"CSLI"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=AC00A9>1992</font><font color=FF0000>}</font>
Entry<font color=FF0000>{</font><font color=8888CC>"Jon&nbsp;Bentley"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8888CC>"More&nbsp;Programming&nbsp;Pearls"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8888CC>"Addison-Wesley"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=AC00A9>1990</font><font color=FF0000>}</font>
</pre>

<p>Вспомним, что <code>Entry{code}</code> - это то же самое что и <code>Entry({code})</code>, то есть вызов функции <code>Entry</code> с таблицей в качестве единственного аргумента. Поэтому приведенный выше фрагмент данных - это на самом деле программа на Lua. Для того чтобы прочесть такой файл, нам просто нужно выполнить его с надлежащим образом определенной функцией <code>Entry</code>. Например, следующая программа считает число записей в файле:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>function</font>&nbsp;Entry&nbsp;<font color=FF0000>()</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;count&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>end</font>
<font color=0080C0>dofile</font><font color=FF0000>(</font><font color=8888CC>"data"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"number&nbsp;of&nbsp;entries:&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;count<font color=FF0000>)</font>
</pre>

<p>Следующая программа строит множество всех имен авторов, найденных в файле, и печатает их (не обязательно в том же порядке, в котором они встретились в файле):</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;authors&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;множество&nbsp;авторов</font>
<font color=0000DF>function</font>&nbsp;Entry&nbsp;<font color=FF0000>(</font>b<font color=FF0000>)</font>&nbsp;authors<font color=FF0000>[</font>b<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>end</font>
<font color=0080C0>dofile</font><font color=FF0000>(</font><font color=8888CC>"data"</font><font color=FF0000>)</font>
<font color=0000DF>for</font>&nbsp;name&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>authors<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>name<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
</pre>

<p>Обратите внимание на подход, использованный в этих фрагментах кода: функция <code>Entry</code> выступает в роли функции обратного вызова (<i>callback</i>), которая вызывается во время выполнения <code>dofile</code> для каждой записи в файле.</p>

<p>Когда нас не волнует размер файла, мы можем в качестве нашего представления использовать пары имя-значение (Если этот формат напоминает вам <i>BibTeX</i>, то это не случайность. Формат BibTeX был одним из источников, определившим вид конструкторов в Lua):</p>

<pre class="code">
Entry<font color=FF0000>{</font>
&nbsp;&nbsp;author&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Donald&nbsp;E.&nbsp;Knuth"</font><font color=FF0000>,</font>
&nbsp;&nbsp;title&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Literate&nbsp;Programming"</font><font color=FF0000>,</font>
&nbsp;&nbsp;publisher&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"CSLI"</font><font color=FF0000>,</font>
&nbsp;&nbsp;year&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1992</font>
<font color=FF0000>}</font>

Entry<font color=FF0000>{</font>
&nbsp;&nbsp;author&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Jon&nbsp;Bentley"</font><font color=FF0000>,</font>
&nbsp;&nbsp;title&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"More&nbsp;Programming&nbsp;Pearls"</font><font color=FF0000>,</font>
&nbsp;&nbsp;year&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1990</font><font color=FF0000>,</font>
&nbsp;&nbsp;publisher&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Addison-Wesley"</font><font color=FF0000>,</font>
<font color=FF0000>}</font>
</pre>

<p>Этот формат - это то, что мы называем <i>самоописывающий формат</i> данных, поскольку каждый фрагмент данных содержит краткое описание его значения. Самоописывающие данные более читаемы (как минимум людьми), чем <i>CSV</i> или другой компактный формат; их легко редактировать при необходимости; и они позволяют нам вносить небольшие изменения в базовый формат без необходимости изменять файлы с данными. Например, если мы добавим новое поле, то нам нужно только изменить читающую программу, предоставив значение по умолчанию, когда поле не указано.</p>

<p>При помощи формата имя-значение наша программа для составления списка авторов становится, как показано ниже:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;authors&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;множество&nbsp;для&nbsp;имен&nbsp;авторов</font>
<font color=0000DF>function</font>&nbsp;Entry&nbsp;<font color=FF0000>(</font>b<font color=FF0000>)</font>&nbsp;authors<font color=FF0000>[</font>b<font color=FF0000>.</font>author<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>end</font>
<font color=0080C0>dofile</font><font color=FF0000>(</font><font color=8888CC>"data"</font><font color=FF0000>)</font>
<font color=0000DF>for</font>&nbsp;name&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>authors<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>name<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
</pre>

<p>Теперь порядок полей не важен. Даже если у некоторых записей нет автора, то нам понадобится только изменить функцию <code>Entry</code>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;Entry&nbsp;<font color=FF0000>(</font>b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;b<font color=FF0000>.</font>author&nbsp;<font color=0000DF>then</font>&nbsp;authors<font color=FF0000>[</font>b<font color=FF0000>.</font>author<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Lua не только быстро выполняется, но и быстро компилируется. Например, приведенная выше программа для составления списка авторов обрабатывает 1 Мб данных за одну десятую секунды (Для моего старого компьютера). И это не случайно. Описание данных было одним из главных приложений Lua с момента создания, и мы уделяем много внимания тому, чтобы ее компилятор быстро работал для больших программ.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="12.2. Сериализация"></a>12.2. Сериализация
</div>

<p>Часто нам нужно сериализовать какие-то данные, то есть перевести данные в поток байтов или символов, который мы можем записать в файл или послать по сети. Мы можем представлять сериализованные данные как код на Lua таким образом, что при выполнении этого кода он восстанавливает сохраненные значения для выполняющей его программы.</p>

<p>Обычно если мы хотим восстановить значение глобальной переменной, то наш блок кода будет чем-то вроде <code>varname = exp</code>, где <code>ехр</code> - это код на Lua для получения значения. С <code>varname</code> все просто, поэтому давайте посмотрим, как написать код, который создает значение. Для числового значения задача проста:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;serialize&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"number"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=FF0000>&lt;</font>other&nbsp;cases<font color=FF0000>&gt;</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>При записи числа в десятичном виде есть риск потерять точность. В Lua 5.2 можно использовать шестнадцатеричный формат, для того чтобы избежать подобной проблемы:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"number"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%a"</font><font color=FF0000>,</font>&nbsp;o<font color=FF0000>))</font>
</pre>

<p>При использовании этого формата ("<code>%а</code>") прочитанное значение будет состоять из точно тех же самых битов, что и исходное.</p>

<p>Для строки наивным подходом было бы что-то вроде следующего:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"string"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"'"</font><font color=FF0000>,</font>&nbsp;o<font color=FF0000>,</font>&nbsp;<font color=8888CC>"'"</font><font color=FF0000>)</font>
</pre>

<p>Однако если строка содержит специальные символы (такие как кавычки или <code>'\n'</code>), то получившийся код уже не будет программой на Lua.</p>

<p>Вам может показаться, что эту проблему можно решить, изменив тип кавычек:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"string"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"[["</font><font color=FF0000>,</font>&nbsp;o<font color=FF0000>,</font>&nbsp;<font color=8888CC>"]]"</font><font color=FF0000>)</font>
</pre>

<p>Однако будьте осторожны. Если вы попытаетесь сохранить что-то вроде <code>"]].. os.execute('rm *')..[["</code> (например, передав данную строку в качестве адреса), то получившийся блок кода будет:</p>

<pre class="code">varname&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>[[&nbsp;]]</font><font color=FF0000>..</font><font color=FF8000>os.execute</font><font color=FF0000>(</font><font color=8888CC>'rm&nbsp;*'</font><font color=FF0000>)..</font><font color=8888CC>[[&nbsp;]]</font></pre>

<p>В результате вы получите неприятный сюрприз при попытке прочесть такие «данные».</p>

<p>Простейшим способом записать строку безопасно будет использование опции <code>"%q"</code> из функции <code>string.format</code>. Она окружает строку двойными кавычками и безопасным образом представляет двойные кавычки и некоторые другие символы внутри строки:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>'a&nbsp;"problematic"&nbsp;\\string'</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%q"</font><font color=FF0000>,</font>&nbsp;a<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;"a&nbsp;\"problematic\"&nbsp;\\string"</font>
</pre>

<p>Используя эту возможность, наша функция <code>serialize</code> может выглядеть следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;serialize&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"number"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"string"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%q"</font><font color=FF0000>,</font>&nbsp;o<font color=FF0000>))</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=FF0000>&lt;</font>other&nbsp;cases<font color=FF0000>&gt;</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Начиная с версии 5.1 Lua предлагает другой способ записи строк безопасным образом, при помощи записи <code>[=[...]=]</code> для длинных строк. Однако этот способ записи в основном предназначен для написанного пользователем кода, когда мы никоим образом не хотим менять строку символов. В коде, генерируемом автоматически, легче использовать <code>"%q"</code> из <code>string.format</code>.</p>

<p>Если же вы тем не менее хотите использовать подобную запись для автоматически генерируемого кода, то вам нужно обратить внимание на некоторые детали. Первой является то, что вам нужно подобрать правильное количество знаков равенства. Хорошим вариантом является число больше, чем встречается в исходной строке. Поскольку строки, содержащие большое количество знаков равенства, не являются редкостью (например, комментарии, разделяющие блоки кода), то мы можем ограничиться рассмотрением последовательностей знаков равенства, заключенных между квадратными скобками; другие последовательности не могут привести к ошибочному маркеру конца строки. Второй деталью является то, что Lua всегда игнорирует символ <code>'\n'</code> в начале длинной строки; простейшим способом борьбы с этим является добавление символа <code>'\n'</code>, который будет отброшен.</p>

<p><a name="листинг 12.1"></a><b class="sect">Листинг 12.1</b>. Вывод произвольной строки символов</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;quote&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;найти&nbsp;максимальную&nbsp;длину&nbsp;последовательности&nbsp;знаков&nbsp;равенства</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"]=*]"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.max</font><font color=FF0000>(</font>n<font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>w&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;-2&nbsp;to&nbsp;remove&nbsp;the&nbsp;']'s</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;создать&nbsp;строку&nbsp;с&nbsp;'n'+l&nbsp;знаком&nbsp;равенства</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;eq&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.rep</font><font color=FF0000>(</font><font color=8888CC>"="</font><font color=FF0000>,</font>&nbsp;n&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;построить&nbsp;итоговую&nbsp;строку</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"&nbsp;[%s[\n%s]%s]&nbsp;"</font><font color=FF0000>,</font>&nbsp;eq<font color=FF0000>,</font>&nbsp;s<font color=FF0000>,</font>&nbsp;eq<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Функция <code>quote</code> из <a href="#листинг 12.1">листинга 12.1</a> является результатом наших предыдущих замечаний. Она получает на вход произвольную строку и возвращает отформатированную строку как длинную строку. Вызов <code>string.gmatch</code> создает итератор для перебора всех последовательностей вида <code>']=*]'</code>(то есть закрывающей квадратной скобки, за которой следуют ноль или больше знаков равенства, за которыми следует еще одна закрывающая квадратная скобка) в строке (Мы обсудим шаблоны строк в <a href="#Глава 21. Библиотека для работы со строками">главе 21</a>). Для каждого вхождения обновляется значение <code>n</code>, равное максимальному числу уже встреченных знаков равенства. После цикла мы используем функцию <code>string.rep</code>, для того чтобы повторить знак равенства <code>n+1</code> раз, то есть на один больше, чем максимальное количество, встреченное в строке. Наконец, функция <code>string.format</code> заключает <code>s</code> между парами квадратных скобок с надлежащим числом знаков равенства и добавляет дополнительные пробелы вокруг строки и символ <code>'\п'</code> в начале строки.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="12.2. Сохранение таблиц без циклов"></a>Сохранение таблиц без циклов
</div>

<p>Нашей следующей(и более сложной) задачей является сохранение таблиц. Существует несколько способов сохранения их в соответствии с тем, какие ограничения мы накладываем на структуру таблицы. Нет одного алгоритма, который бы подходил для всех случаев. Простые таблицы не только требуют более простых алгоритмов, но и получающиеся при этом файлы могут быть визуально приятней.</p>

<p><a name="листинг 12.2"></a><b class="sect">Листинг 12.2</b>. Сериализация таблиц без циклов</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;serialize&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"number"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"string"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%q"</font><font color=FF0000>,</font>&nbsp;o<font color=FF0000>))</font>
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"table"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"{\n"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;k<font color=FF0000>,</font>v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"&nbsp;"</font><font color=FF0000>,</font>&nbsp;k<font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;=&nbsp;"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serialize<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>",\n"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"}\n"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"cannot&nbsp;serialize&nbsp;a&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>))</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Наша следующая попытка представлена в <a href="#листинг 12.2">листинге 12.2</a>. Несмотря на свою простоту, эта функция выполняет вполне приличную работу. Она даже обрабатывает вложенные таблицы (то есть таблицы внутри других таблиц) до тех пор, пока структура таблицы является деревом (то есть нет общих подтаблиц и циклов). Небольшим визуальным улучшением будет добавление пробелов для индентации вложенных таблиц (см. <a href="#упражнение 12.1">упражнение 12.1</a>).</p>

<p>Предыдущая функция предполагает, что все ключи в таблице являются валидными идентификаторами. Если в таблице есть числовые ключи или строки, которые не являются идентификаторами в Lua, то у нас проблема. Простым путем ее разрешения является использование следующего кода для записи каждого ключа:</p>

<pre class="code"><font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"&nbsp;["</font><font color=FF0000>);</font>&nbsp;serialize<font color=FF0000>(</font>k<font color=FF0000>);</font>&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"]&nbsp;=&nbsp;"</font><font color=FF0000>)</font></pre>

<p>С этим улучшением мы увеличили надежность нашей функции за счет визуальной наглядности получающегося файла. Рассмотрим следующий вызов:</p>

<pre class="code">serialize<font color=FF0000>{</font>a<font color=FF0000>=</font><font color=AC00A9>12</font><font color=FF0000>,</font>&nbsp;b<font color=FF0000>=</font><font color=8888CC>'Lua'</font><font color=FF0000>,</font>&nbsp;key<font color=FF0000>=</font><font color=8888CC>'another&nbsp;"one"'</font><font color=FF0000>}</font></pre>

<p>Результатом этого вызова при использовании первой версии функции <code>serialize</code> будет следующий код:</p>

<pre class="code">
<font color=FF0000>{</font>
&nbsp;&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>12</font><font color=FF0000>,</font>
&nbsp;&nbsp;b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Lua"</font><font color=FF0000>,</font>
&nbsp;&nbsp;key&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"another&nbsp;\"one\""</font><font color=FF0000>,</font>
<font color=FF0000>}</font>
</pre>

<p>Сравните с результатом использования второй версии:</p>

<pre class="code">
<font color=FF0000>{</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"a"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>12</font><font color=FF0000>,</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"b"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Lua"</font><font color=FF0000>,</font>
&nbsp;&nbsp;<font color=FF0000>[</font><font color=8888CC>"key"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"another&nbsp;\"one\""</font><font color=FF0000>,</font>
<font color=FF0000>}</font>
</pre>

<p>Мы можем получить и надежность, и красивый вид, проверяя в каждом случае, нужны ли квадратные скобки; опять мы оставим это улучшение в качестве упражнения.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="12.2. Сохранение таблиц с циклами"></a>Сохранение таблиц с циклами
</div>

<p>Для обработки таблиц в общем случае (то есть с циклами и общими подтаблицами) нам потребуется другой подход. Конструкторы не могут представлять подобные таблицы, поэтому мы их и не будем использовать. Для представления циклов нам нужны имена, поэтому наша следующая функция в качестве аргументов получит значение для сохранения и имя. Более того, мы должны отслеживать имена уже сохраненных таблиц, для того чтобы переиспользовать их, когда мы обнаруживаем цикл. Для этого мы будем использовать дополнительную таблицу. Эта таблица будет использовать таблицы в качестве индексов и их имена в качестве хранимых значений.</p>


<p>Итоговый код показан в <a href="#листинг 12.3">листинге 12.3</a>. Мы пока придерживаемся ограничения, что таблицы, которые мы хотим сохранять, содержат лишь числа и строки в качестве ключей. Функция <code>basicSerialize</code> сериализует эти базовые типы. Следующая функция, <code>save</code>, выполняет всю тяжелую работу. Параметр <code>saved</code> - это таблица, которая отслеживает уже сохраненные таблицы. Например, если мы построим таблицу следующим образом:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>2</font><font color=FF0000>;</font>&nbsp;<font color=FF0000>{</font><font color=AC00A9>3</font><font color=FF0000>,</font><font color=AC00A9>4</font><font color=FF0000>,</font><font color=AC00A9>5</font><font color=FF0000>}}</font>
a<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;a&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;цикл</font>
a<font color=FF0000>.</font>z&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=008000>--&nbsp;общая&nbsp;подтаблица</font>
</pre>

<p>то вызов <code>save("a", a)</code> сохранит ее следующим образом:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>][</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>3</font>
a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>][</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>4</font>
a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>][</font><font color=AC00A9>3</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>5</font>

a<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;a
a<font color=FF0000>[</font><font color=8888CC>"y"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>2</font>
a<font color=FF0000>[</font><font color=8888CC>"x"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
a<font color=FF0000>[</font><font color=8888CC>"z"</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>
</pre>

<p>Порядок этих присваиваний может меняться, так как он зависит от обхода таблицы. Тем не менее алгоритм гарантирует, что любой элемент, необходитмый для построения таблицы уже определен.</p>

<p>Если мы хотим сохранить несколько значений с общими частями, то мы можем вызвать функцию <code>save</code> в той же самой таблице <code>saved</code>. Например, рассмотрим следующие две таблицы:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{{</font><font color=8888CC>"one"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"two"</font><font color=FF0000>},</font>&nbsp;<font color=AC00A9>3</font><font color=FF0000>}</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>k&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]}</font>
</pre>

<p><a name="листинг 12.3"></a><b class="sect">Листинг 12.3</b>. Сохранение таблиц с циклами</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;basicSerialize&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"number"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=008000>--&nbsp;предположим,&nbsp;что&nbsp;это&nbsp;строка</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%q"</font><font color=FF0000>,</font>&nbsp;o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;save&nbsp;<font color=FF0000>(</font>name<font color=FF0000>,</font>&nbsp;value<font color=FF0000>,</font>&nbsp;saved<font color=FF0000>)</font>
&nbsp;&nbsp;saved&nbsp;<font color=FF0000>=</font>&nbsp;saved&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>{}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;начальное&nbsp;значение</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>name<font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;=&nbsp;"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>value<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"number"</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>value<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"string"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>basicSerialize<font color=FF0000>(</font>value<font color=FF0000>),</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>value<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"table"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;saved<font color=FF0000>[</font>value<font color=FF0000>]</font>&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;значение&nbsp;уже&nbsp;сохранено?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>saved<font color=FF0000>[</font>value<font color=FF0000>],</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;используем&nbsp;его&nbsp;имя</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saved<font color=FF0000>[</font>value<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;сохранить&nbsp;имя&nbsp;для&nbsp;следующего&nbsp;раза</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"{}\n"</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создать&nbsp;новую&nbsp;таблицу</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;k<font color=FF0000>,</font>v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>value<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;сохранить&nbsp;ее&nbsp;поля</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;<font color=FF0000>=</font>&nbsp;basicSerialize<font color=FF0000>(</font>k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;fname&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%s[%s]"</font><font color=FF0000>,</font>&nbsp;name<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;save<font color=FF0000>(</font>fname<font color=FF0000>,</font>&nbsp;v<font color=FF0000>,</font>&nbsp;saved<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"cannot&nbsp;save&nbsp;a&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>value<font color=FF0000>))</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Если мы сохраним их независимо, то у результата не будет общих частей:</p>

<pre class="code">
save<font color=FF0000>(</font><font color=8888CC>"a"</font><font color=FF0000>,</font>&nbsp;a<font color=FF0000>)</font>
save<font color=FF0000>(</font><font color=8888CC>"b"</font><font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
<font color=008000>--&gt;&nbsp;a&nbsp;=&nbsp;{}</font>
<font color=008000>--&gt;&nbsp;a[1]&nbsp;=&nbsp;{}</font>
<font color=008000>--&gt;&nbsp;a[1][1]&nbsp;=&nbsp;"one"</font>
<font color=008000>--&gt;&nbsp;a[1][2]&nbsp;=&nbsp;"two"</font>
<font color=008000>--&gt;&nbsp;a[2]&nbsp;=&nbsp;3</font>
<font color=008000>--&gt;&nbsp;b&nbsp;=&nbsp;{}</font>
<font color=008000>--&gt;&nbsp;b["k"]&nbsp;=&nbsp;{}</font>
<font color=008000>--&gt;&nbsp;b["k"][1]&nbsp;=&nbsp;"one"</font>
<font color=008000>--&gt;&nbsp;b["k"][2]&nbsp;=&nbsp;"two"</font>
</pre>

<p>Однако если мы используем ту же самую таблицу <code>saved</code> для обоих вызовов <code>save</code>, то в получившемся результате будут общие части:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
save<font color=FF0000>(</font><font color=8888CC>"a"</font><font color=FF0000>,</font>&nbsp;a<font color=FF0000>,</font>&nbsp;t<font color=FF0000>)</font>
save<font color=FF0000>(</font><font color=8888CC>"b"</font><font color=FF0000>,</font>&nbsp;b<font color=FF0000>,</font>&nbsp;t<font color=FF0000>)</font>
<font color=008000>--&gt;&nbsp;a&nbsp;=&nbsp;{}</font>
<font color=008000>--&gt;&nbsp;a[1]&nbsp;=&nbsp;{}</font>
<font color=008000>--&gt;&nbsp;a[1][1]&nbsp;=&nbsp;"one"</font>
<font color=008000>--&gt;&nbsp;a[1][2]&nbsp;=&nbsp;"two"</font>
<font color=008000>--&gt;&nbsp;a[2]&nbsp;=&nbsp;3</font>
<font color=008000>--&gt;&nbsp;b&nbsp;=&nbsp;{}</font>
<font color=008000>--&gt;&nbsp;b["k"]&nbsp;=&nbsp;a[1]</font>
</pre>

<p>Как обычно, в Lua существует несколько других вариантов. Среди них мы можем сохранить значение без выдачи ему глобального имени (например, блок строит локальное значение и возвращает его), мы можем обрабатывать функции (путем построения дополнительной таблицы, связывающей каждую функцию с ее именем) и т. д. Lua дает вам силу - вы строите механизмы.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="12. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 12.1.</b></b>
Измените код из <a href="#листинг 12.2">листинга 12.2</a>, чтобы он выравнивал вложенные таблицы.
(<i>Подсказка</i>: добавьте дополнительный параметр функции <code>serialize</code>, содержащий строку выравнивания.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 12.2.</b></b>
Измените код из <a href="#листинг 12.2">листинга 12.2</a> так, чтобы он использовал синтаксис <code>["key"]=value</code> так, как предложено в <a href="#12.1. Файлы с данными">разделе 12.1</a>.</p>

<hr color="#99CCFF">

<p><b>Упражнение 12.3.</b></b>
Измените код предыдущего упражнения так, чтобы он использовал синтаксис <code>["key"]=value</code>, только когда это необходимо.</p>

<hr color="#99CCFF">

<p><b>Упражнение 12.4.</b></b>
Измените код предыдущего упражнения так, чтобы он использовал конструкторы всегда, когда это возможно. Например, он должен представить таблицу <code>{14,15,19}</code> как <code>{14,15,19}</code>, а не как <code>{[1]=14,[2]=15,[3]=19}</code> (<i>Подсказка</i>: начните с сохранения значений ключей <code>1, 2,...,</code> пока они не равны <b>nil</b>. Обратите внимание на то, что не нужно их снова сохранять при обходе остальной части таблицы.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 12.5.</b></b>
Подход, заключающийся в отказе от использования конструкторов, при сохранении таблиц с циклами, слишком радикальный. Можно сохранить таблицу в более приятном виде, используя конструкторы в общем случае и затем используя присваивания только для обработки общих таблиц и циклов.</p>

<p>Заново реализуйте функцию <code>save</code> с использованием этого подхода. Добавьте к ней все, что вы уже реализовали в предыдущих упражнениях.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 13. Метатаблицы и метаметоды"></a>Глава 13. Метатаблицы и метаметоды
</div>

<p>Обычно для каждого значения в Lua есть вполне предсказуемый набор операций. Мы можем складывать числа, соединять строки, вставлять пары ключ-значение в таблицы и т. п. Однако мы не можем складывать таблицы, не можем сравнивать функции и не можем вызвать строку. Если только мы не используем метатаблицы.</p>

<p>Метатаблицы позволяют изменить поведение значения в случае, когда мы сталкиваемся с неожиданной операцией. Например, при помощи метатаблиц мы можем определить, как Lua должн вычислить выражение <code>а+b</code>, где <code>а</code> и <code>b</code> - это таблицы. Когда Lua пытается сложить две таблицы, то он проверяет, есть ли хотя бы в одной из них метатаблица и содержит ли эта метатаблица поле <code>_add</code>. Если Lua находит это поле, то он вызывает соответствующее значение - так называемый <i>метаметод</i>, который должен быть функцией, - для вычисления суммы.</p>

<p>Каждое значение в Lua может иметь связанную с ним метатаблицу. Таблицы и значения типа <code>userdata</code> хранят индивидуальные значения для каждого экземпляра; значения остальных типов используют одну общую таблицу на каждый тип. Lua всегда создает новые таблицы без метатаблиц:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font>t<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
</pre>

<p>Мы можем использовать функцию <code>setmetatable</code>, для того чтобы задать или изменить метатаблицу для любой таблицы:</p>

<pre class="code">
t1&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;t1<font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;t1<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;true</font>
</pre>

<p>Непосредственно из Lua мы можем устанавливать метатаблицы только для таблиц; для работы с метатаблицами значений других типов мы должны использовать код на С (Главной причиной для такого ограничения служит желание ограничить слишком частое использование метатаблиц. Опыт с предыдущими версиями Lua показал, что подобные глобальные изменения часто ведут к непереиспользуемому коду). Мы позже увидим в <a href="#Глава 21. Библиотека для работы со строками">главе 21</a>, что библиотека для работы со строками устанавливает метатаблицы для строк. Все остальные типы по умолчанию не имеют метатаблиц:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font><font color=8888CC>"hi"</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;table:&nbsp;0x80772e0</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font><font color=8888CC>"xuxu"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;table:&nbsp;0x80772e0</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font><font color=AC00A9>10</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font><font color=0080C0>print</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
</pre>

<p>Любая таблица может быть метатаблицей любого значения; группа связанных между собой таблиц может разделять общую метатаблицу, которая задает их общее поведение; таблица может быть метатаблицей сама для себя так, что она описывает свое собственное поведение.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="13.1. Арифметические метаметоды"></a>13.1. Арифметические метаметоды
</div>

<p>В этом разделе мы рассмотрим простой пример для того, чтобы обьяснить, как использовать метатаблицы. Пусть мы используем таблицы для представления множеств с функциями для вычисления обьединения, пересечения и т. д., как показано в <a href="#листинг 13.1">листинге 13.1</a>. Для того чтобы не засорять глобальное пространство имен, мы будем хранить эти функции в таблице <code>Set</code>.</p>

<p><a name="листинг 13.1"></a><b class="sect">Листинг 13.1</b>. Простая реализация множеств</p>

<pre class="code">
Set&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=008000>--&nbsp;создать&nbsp;новое&nbsp;множество,&nbsp;взяв&nbsp;значения&nbsp;из&nbsp;заданного&nbsp;списка</font>
<font color=0000DF>function</font>&nbsp;Set<font color=FF0000>.</font>new&nbsp;<font color=FF0000>(</font>l<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;set&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;_<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>ipairs</font><font color=FF0000>(</font>l<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;set<font color=FF0000>[</font>v<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;set
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;Set<font color=FF0000>.</font>union&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;k&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;res<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;k&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>b<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;res<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;res
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;Set<font color=FF0000>.</font>intersection&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;k&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;res<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;b<font color=FF0000>[</font>k<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;res
<font color=0000DF>end</font>

<font color=008000>--&nbsp;представить&nbsp;множество&nbsp;как&nbsp;строку</font>
<font color=0000DF>function</font>&nbsp;Set<font color=FF0000>.</font>tostring&nbsp;<font color=FF0000>(</font>set<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;l&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;список,&nbsp;куда&nbsp;будут&nbsp;помещены&nbsp;все&nbsp;элементы</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;e&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>set<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;l<font color=FF0000>[#</font>l&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;e
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8888CC>"{"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8000FF>table.concat</font><font color=FF0000>(</font>l<font color=FF0000>,</font>&nbsp;<font color=8888CC>",&nbsp;"</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"}"</font>
<font color=0000DF>end</font>

<font color=008000>--&nbsp;напечатать&nbsp;множество</font>
<font color=0000DF>function</font>&nbsp;Set<font color=FF0000>.</font>print&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>Set<font color=FF0000>.</font>tostring<font color=FF0000>(</font>s<font color=FF0000>))</font>
<font color=0000DF>end</font>
</pre>

<p>Теперь мы будем использовать оператор сложения('<code>+</code>') для вычисления обьединения двух множеств. Для этого мы сделаем так, что все таблицы, представляющие множества, будут иметь одну общую метатаблицу. Эта метатаблица определит, как таблицы должны реагировать на оператор сложения. Нашим первым шагом будет создание обычной таблицы, которую мы будем использовать как метатаблицу для множеств:</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;метатаблица&nbsp;для&nbsp;множеств</font></pre>

<p>Следующим шагом будет изменение функции, создающей множества <code>Set.new</code>. В новой версии этой функции будет одна дополнительная строка, которая для создаваемых таблиц устанавливает <code>mt</code> как метатаблицу:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;Set<font color=FF0000>.</font>new&nbsp;<font color=FF0000>(</font>l<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;2nd&nbsp;version</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;set&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>set<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;_<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>ipairs</font><font color=FF0000>(</font>l<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;set<font color=FF0000>[</font>v<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;set
<font color=0000DF>end</font>
</pre>

<p>После этого каждое множество, которое мы создадим при помощи <code>Set.new</code>, будет иметь одну и ту же метатаблицу:</p>

<pre class="code">
s1&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>30</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>50</font><font color=FF0000>}</font>
s2&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{</font><font color=AC00A9>30</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font>s1<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;table:&nbsp;00672B60</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font>s2<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;table:&nbsp;00672B60</font>
</pre>

<p>Наконец, мы добавим к метатаблице метаметод, поле <code>_add</code>, которое определяет, как нужно выполнять сложение:</p>

<pre class="code">mt<font color=FF0000>.</font>__add&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>union</pre>

<p>После этого всегда, когда Lua будет пытаться сложить два множества, она будет вызывать функцию <code>Set.union</code>, передавая оба операнда в качестве аргументов.</p>

<p>С метаметодом мы можем использовать оператор сложения для выполнения обьединения множеств:</p>

<pre class="code">
s3&nbsp;<font color=FF0000>=</font>&nbsp;s1&nbsp;<font color=FF0000>+</font>&nbsp;s2
Set<font color=FF0000>.</font>print<font color=FF0000>(</font>s3<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;{1,&nbsp;10,&nbsp;20,&nbsp;30,&nbsp;50}</font>
</pre>

<p>Аналогично мы можем определить оператор умножения для выполнения пересечения множеств:</p>

<pre class="code">
mt<font color=FF0000>.</font>__mul&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>intersection
Set<font color=FF0000>.</font>print<font color=FF0000>((</font>s1&nbsp;<font color=FF0000>+</font>&nbsp;s2<font color=FF0000>)*</font>s1<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;{10,&nbsp;20,&nbsp;30,&nbsp;50}</font>
</pre>

<p>Для каждого арифметического оператора существует соответствующее имя поля в метатаблице. Кроме <code> __add</code> и <code> __mul</code>, также есть <code> __sub</code> (для вычитания), <code> __div</code> (для деления), <code> __unm</code> (для отрицания), <code> __mod</code> (для взятия остатка от деления) и <code> __pow</code> (для возведения в степень). Мы также можем определить поле <code> __concat</code> для задания оператора конкатенации.</p>

<p>Когда мы складываем два множества, то вопрос о том, какую метатаблицу взять, не возникает. Однако мы можем записать выражение, в котором участвуют два значения с разными метатаблицами, например как показано ниже:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{</font><font color=AC00A9>1</font><font color=FF0000>,</font><font color=AC00A9>2</font><font color=FF0000>,</font><font color=AC00A9>3</font><font color=FF0000>}</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;s&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>8</font>
</pre>

<p>При поиске метаметода Lua выполняет следующие шаги: если у первого значения есть метатаблица с полем <code> __add</code>, то Lua использует соответствующее значение в качестве метаметода независимо от второго значения; иначе если второе значение имеет метатаблицу с полем <code> __add</code>, то Lua использует это значение в качестве метаметода; в противном случае возникает ошибка. Таким образом, в последнем примере будет вызван <code>Set.union</code>, так же как и для выражений <code>10+s</code> и <code>"hello"+s</code>.</p>

<p>Lua не беспокоится по поводу смешивания типов, однако это важно для нашего приложения. Например, если мы выполним <code>s=s+8</code>, то мы получим ошибку внутри <code>Set.union</code>:</p>

<pre class="code">bad argument #1 to 'pairs'(table expected, got number)</pre>

<p>Если мы хотим получать более точные сообщения об ошибках, то мы должны явно проверять типы операндов перед выполнением операции:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;Set<font color=FF0000>.</font>union&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>getmetatable</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=FF0000>~=</font>&nbsp;mt&nbsp;<font color=0000DF>or</font>&nbsp;<font color=0080C0>getmetatable</font><font color=FF0000>(</font>b<font color=FF0000>)</font>&nbsp;<font color=FF0000>~=</font>&nbsp;mt&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"attempt&nbsp;to&nbsp;'add'&nbsp;a&nbsp;set&nbsp;with&nbsp;a&nbsp;non-set&nbsp;value"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>as&nbsp;before<font color=FF0000>&gt;</font>
</pre>

<p>Помните, что второй аргумент функции <code>error</code> (<code>2</code> в нашем случае) направляет сообщение об ошибке туда, где данная операция была вызвана.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="13.2. Метаметоды сравнения"></a>13.2. Метаметоды сравнения
</div>

<p>Метатаблицы также позволяют придать смысл операторам сравнения при помощи метаметодов <code> __eq</code> (равно), <code> __lt</code> (меньше, чем) и <code> __lе</code> (меньше илиравно, чем). Нет специальных метаметодов для трех оставшихся операций сравнения: Lua переводит <code>а~=ь</code> в <code>not(а==Ь)</code>, <code>а&gt;b</code> в <code>b&lt;а</code> и <code>а&gt;=b</code> в <code>b&lt;=а</code>.</p>

<p>До версии 4.0 Lua переводил все операции упорядочивания в одну, переводя <code>а&lt;=b</code> в <code>not(b&lt;a)</code>. Однако такой перевод некорректен, когда мы имеем дело с <i>частичным упорядочиванием</i>, то есть когда не все элементы нашего типа надлежащим образом упорядочены. Например, числа с плавающей точкой не являются полностью упорядоченными на большинстве компьютеров из-за значения NaN (<i>Not a Number</i>). В соответствии со стандартом IEEE 754 NaN представляет неопределенные значения, например 0/0. Согласно стандарту, любое сравнение, включающее в себя NaN, должно быть ложным. Это значит, что <code>NaN&lt;=x</code> всегда ложно, но и <code>x&lt;NaN</code> также ложно. Из этого следует, что перевод <code>а&lt;=b</code> в <code>not(b&lt;a)</code> неверен в этом случае.</p>

<p>В нашем примере с множествами мы имеем дело с похожей проблемой. Очевидным(и полезным) значением для <code>&lt;=</code> для множеств является вхождение множества: <code>а&lt;=b</code> означает, что <code>а</code> - это подмножество <code>b</code>. С этим значением опять возможно, что <code>а&lt;=b</code> и <code>b&lt;а</code> ложны; таким образом, нам нужны отдельные реализации для <code> __1е</code> (меньше или равно) и <code> __lt</code> (меньше, чем):</p>

<pre class="code">
mt<font color=FF0000>.</font>__le&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;set&nbsp;containment</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;k&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;b<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>false</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>true</font>
<font color=0000DF>end</font>

mt<font color=FF0000>.</font>__lt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;a&nbsp;<font color=FF0000><=</font>&nbsp;b&nbsp;<font color=0000DF>and</font>&nbsp;<font color=0000DF>not</font>&nbsp;<font color=FF0000>(</font>b&nbsp;<font color=FF0000><=</font>&nbsp;a<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Наконец, мы можем определить равенство множеств через вложение множеств:</p>

<pre class="code">
mt<font color=FF0000>.</font>__eq&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;a&nbsp;<font color=FF0000><=</font>&nbsp;b&nbsp;<font color=0000DF>and</font>&nbsp;b&nbsp;<font color=FF0000><=</font>&nbsp;a
<font color=0000DF>end</font>
</pre>

<p>После этих определений мы готовы сравнивать множества:</p>

<pre class="code">
s1&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>}</font>
s2&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{</font><font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s1&nbsp;<font color=FF0000><=</font>&nbsp;s2<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s1&nbsp;<font color=FF0000>&lt;</font>&nbsp;s2<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s1&nbsp;<font color=FF0000>>=</font>&nbsp;s1<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;true</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s1&nbsp;<font color=FF0000>&gt;</font>&nbsp;s1<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;false</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s1&nbsp;<font color=FF0000>==</font>&nbsp;s2&nbsp;<font color=FF0000>*</font>&nbsp;s1<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;true</font>
</pre>

<p>Для типов, у которых есть полное упорядочение, мы можем не определять метаметод <code> __1е</code>. При его отсутствии Lua использует <code> __lt</code>.</p>

<p>Сравнение на равенство также обладает некоторыми ограничениями. Если у двух обьектов разные базовые типы или метаметоды, то операция сравнения на равенство вернет <b>false</b>, далее не вызывая мета-методов. Таким образом множество всегда будет отличаться от числа, независимо от того, что возвращает метаметод.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="13.3. Библиотечные метаметоды"></a>13.3. Библиотечные метаметоды
</div>

<p>До сих пор мы видели метаметоды, определенные в самой Lua. Виртуальная машина сама проверяет, содержат ли значения, соединенные операцией, метатаблицы с соответствующими метаметодами. Однако поскольку метатаблицы являются обычными таблицами, то их может использовать любой. Поэтому часто библиотеки определяют свои собственные поля в метатаблицах.</p>

<p>Функция <code>tostring</code> является типичным примером. Как мы видели ранее, <code>tostring</code> представляет таблицы довольно простым образом:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>({})</font>&nbsp;<font color=008000>--&gt;&nbsp;table:&nbsp;0x8062ac0</font></pre>

<p>Функция <code>print</code> всегда вызывает <code>tostring</code> для форматирования вывода. Однако при форматировании произвольного значения <code>tostring</code> сначала проверяет, есть ли у значения метаметод <code> __tostring</code>. Если такой метаметод есть, то <code>tostring</code> вызывает его, передавая ему обьект в качестве аргумента. То, что вернет этот метаметод, и будет результатом <code>tostring</code>.

<p>В нашем примере с множествами мы уже определили функцию для представления множества как строки. Поэтому нам нужно только выставить поле <code> __tostring</code> в метатаблице:</p>

<pre class="code">mt<font color=FF0000>.</font>__tostring&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>tostring</pre>

<p>После этого, когда бы мы не вызвали <code>print</code> с множеством в качестве аргумента, <code>print</code> вызовет <code>tostring</code>, которая, в свою очередь, вызовет <code>Set.tostring</code>:</p>

<pre class="code">
s1&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s1<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;{4,&nbsp;5,&nbsp;10}</font>
</pre>

<p>Функции <code>setmetatable</code> и <code>getmetatable</code> также используют мета-поле, в данном случае для защиты метатаблицы. Предположим, что вы хотите защитить ваши множества так, что пользователи не смогут ни увидеть, ни изменить их метатаблицы. Если задать поле <code> __metatable</code> в метатаблице, то <code>getmetatable</code> вернет значение этого поля, а вызов <code>setmetatable</code> приведет к возникновению ошибки:</p>

<pre class="code">
mt<font color=FF0000>.</font>__metatable&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"not&nbsp;your&nbsp;business"</font>
s1&nbsp;<font color=FF0000>=</font>&nbsp;Set<font color=FF0000>.</font>new<font color=FF0000>{}</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>getmetatable</font><font color=FF0000>(</font>s1<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;not&nbsp;your&nbsp;business</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>s1<font color=FF0000>,</font>&nbsp;<font color=FF0000>{})</font>
&nbsp;&nbsp;stdin<font color=FF0000>:</font><font color=AC00A9>1</font><font color=FF0000>:</font>&nbsp;cannot&nbsp;change&nbsp;protected&nbsp;metatable
</pre>

<p>В Lua 5.2 <code>pairs</code> и <code>ipairs</code> также обладают метатаблицами, поэтому таблица может изменить способ своего обхода(или добавить обход для обьектов, не являющихся таблицами).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="13.4. Метаметоды для доступа к таблице"></a>13.4. Метаметоды для доступа к таблице
</div>

<p>Метаметоды для арифметических операций и операций сравнения определяют поведение для ситуаций, которые иначе приводили бы к возникновению ошибок. Они не изменяют обычного поведения языка. Но Lua также предоставляет способ для того, чтобы изменить поведение таблиц в двух обычных случаях, чтения и изменения несуществующего поля в таблице.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="13.4. Метаметод __index"></a>Метаметод __index
</div>

<p>Я ранее уже сказал, что когда мы обращаемся к отсутствующему полю в таблице, то результатом является <b>nil</b>. Это так, но это не вся правда. На самом деле подобное обращение приводит к тому, что интерпретатор ищет метаметод <code> __index</code>: если такого метода нет, что обычно и бывает, то возвращается <b>nil</b>; иначе результат предоставляет данный метаметод.</p>

<p>Стандартным примером здесь является наследование. Пусть мы хотим создать несколько таблиц, описывающих окна. Каждая таблица должна задать различные параметры окна, такие как положение, размер, цветовая схема и т. п. Для всех этих параметров есть значения по умолчанию и поэтому мы хотим строить окна, задавая только те значения, которые отличаются от значений по умолчанию. Первым вариантом является конструктор, заполняющий отсутствующие поля. Вторым вариантом является организовать окна таким образом, чтобы они наследовали любое отсутствующее поле от базового прототипа. Для начала мы обьявим прототип и конструктор, который создает новые окна, обладающие общей метатаблицей:</p>

<pre class="code">
<font color=008000>--&nbsp;создать&nbsp;прототип&nbsp;со&nbsp;значениями&nbsp;по&nbsp;умолчанию</font>
prototype&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;y&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;width&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>100</font><font color=FF0000>,</font>&nbsp;height&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>100</font><font color=FF0000>}</font>
mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;create&nbsp;a&nbsp;metatable</font>
<font color=008000>--&nbsp;обьявить&nbsp;функцию-конструктор</font>
<font color=0000DF>function</font>&nbsp;new&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>o<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;o
<font color=0000DF>end</font>
</pre>

<p>Теперь мы определим метаметод <code> __index</code>:</p>

<pre class="code">
mt<font color=FF0000>.</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>_<font color=FF0000>,</font>&nbsp;key<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;prototype<font color=FF0000>[</font>key<font color=FF0000>]</font>
<font color=0000DF>end</font>
</pre>

<p>После этого мы создадим новое окно и обратимся к отсутствующему полю:</p>

<pre class="code">
w&nbsp;<font color=FF0000>=</font>&nbsp;new<font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>20</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>w<font color=FF0000>.</font>width<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;100</font>
</pre>

<p>Lua определяет, что у <code>w</code> нет требуемого поля, но есть метатабли-ца с полем <code>__index</code>. Поэтому Lua вызывает этот метаметод с аргументами <code>w</code> (таблица) и "<code>width</code>" (отсутствующее поле). Метаметод обращается с этим полем к прототипу и возвращает полученное значение.</p>

<p>Использование метаметода <code> __index</code> для наследования в Lua так распространено, что Lua предоставляет упрощенный вариант.</p>

<p>Несмотря на название <i>метод</i>, метаметод <code>__index</code> не обязан быть функцией: например, он может быть таблицей. Когда он является функцией, то Lua вызывает его, передавая таблицу и отсутствующий ключ как аргументы, как мы уже видели. Когда это таблица, то Lua просто выполняет обращение к этой таблице. Поэтому в нашем предыдущем примере мы могли просто определить <code>__index</code> следующим образом:</p>

<pre class="code">mt<font color=FF0000>.</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;prototype</pre>

<p>Теперь, когда Lua будет искать метаметод <code>__index</code>, то он найдет значение <code>prototype</code>, которое является таблицей. Соответственно, Lua выполняет обращение к этой таблице, то есть осуществляет аналог <code>prototype["width"]</code>. Это обращение и дает требуемый результат.</p>

<p>Использование таблицы в качестве метаметода <code>__index</code> даст простой и быстрый способ реализации обычного (не множественного) наследования. Функция является более дорогостоящим вариантом, но и предоставляет при этом больше гибкости: мы можем реализовать множественное наследование, кэширование и многое другое. Мы обсудим эти формы наследования в <a href="#Глава 16. Обьектно-ориентированное программирование">главе 16</a>.</p>

<p>Когда мы хотим обратиться к таблице без вызова метаметода <code>__index</code>, то мы используем функцию <code>rawget</code>. Вызов <code>rawget(t,i)</code> осуществляет непосредственное обращение к таблице <code>t</code>, то есть обращение без использования метатаблиц. Выполнение непосредственного обращения не ускорит ваш код (цена вызова функции уничтожит все, что можно выиграть), но иногда он оказывается необходимым, как мы увидим позже.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="13.4. Метаметод __newindex"></a>Метаметод __newindex
</div>

<p>Метаметод <code>__newindex</code> является аналогом метаметода <code>__index</code>, но только он работает для записи значений в таблицу. Когда вы присваиваете значение отсутствующему полю в таблице, то интерпретатор ищет метаметод <code>__newindex</code>: если он есть, то интерпретатор вызывает его вместо выполнения присваивания. Подобно <code>__index</code>, если метаметод является таблицей, то интерпретатор выполняет присваивание для этой таблицы вместо исходной. Более того, есть функция, выполняющая непосредственный доступ, минуя метаметоды: <code>rawset(t, k, v)</code> записывает значение <code>v</code> по ключу <code>к</code> в таблицу <code>t</code>, не вызывая никаких метаметодов.</p>

<p>Совместное использование метаметодов <code>__index</code> и  <code>__newindex</code> позволяет реализовать в Lua различные довольно мощные конструкции, такие как таблицы, доступные только для чтения, таблицы со значениями по умолчанию и наследование для обьектно-ориентированного программирования. В этой главе мы увидим некоторые из таких применений. Обьектно-ориентированному программированию отведена отдельная глава.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="13.4. Таблицы со значениями по умолчанию"></a>Таблицы со значениями по умолчанию
</div>

<p>Значение по умолчанию для любого поля в обычной таблице - это <b>nil</b>. Легко изменить это поведение при помощи метатаблиц:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;setDefault&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;d<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>return</font>&nbsp;d&nbsp;<font color=0000DF>end</font><font color=FF0000>}</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
<font color=0000DF>end</font>

tab&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x<font color=FF0000>=</font><font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;y<font color=FF0000>=</font><font color=AC00A9>20</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>tab<font color=FF0000>.</font>x<font color=FF0000>,</font>&nbsp;tab<font color=FF0000>.</font>z<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;nil</font>
setDefault<font color=FF0000>(</font>tab<font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>tab<font color=FF0000>.</font>x<font color=FF0000>,</font>&nbsp;tab<font color=FF0000>.</font>z<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;0</font>
</pre>

<p>После вызова <code>setDefault</code> любой вызов к отсутствующему полю в <code>tab</code> вызовет его метаметод <code>__index</code>, который вернет ноль (значение <code>d</code> для этого метаметода).</p>

<p>Функция <code>setDeafult</code> создает новое замыкание и новую метатаблицу для каждой таблицы, которой нужно значение по умолчанию. Это может оказаться дорогостоящим, если у нас много таблиц, которым нужны значения по умолчанию. У метатаблицы значение по умолчанию <code>d</code> «зашито» в ее метаметод, поэтому мы не можем использовать одну и ту же метатаблицу для всех таблиц. Для того чтобы можно было использовать одну и ту же метатаблицу для таблиц с разными значениями по умолчанию, мы можем запоминать значение по умолчанию в самой таблице, используя для этого специальное поле. Если не думать о возможных конфликтах по именам, то мы можем использовать ключ вроде "<code>___</code>" для нашего поля:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;t<font color=FF0000>.</font>___&nbsp;<font color=0000DF>end</font><font color=FF0000>}</font>
<font color=0000DF>function</font>&nbsp;setDefault&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;d<font color=FF0000>)</font>
&nbsp;&nbsp;t<font color=FF0000>.</font>___&nbsp;<font color=FF0000>=</font>&nbsp;d
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Обратите внимание, что теперь мы создаем таблицу <code>mt</code> только один раз, вне функции <code>setDefault</code>.</p>

<p>Если мы хотим гарантировать уникальность ключа, то это довольно легко обеспечить. Все, что нам нужно, - это создать новую таблицу и использовать ее в качестве ключа:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;key&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;unique&nbsp;key</font>
<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;t<font color=FF0000>[</font>key<font color=FF0000>]</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>}</font>
<font color=0000DF>function</font>&nbsp;setDefault&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;d<font color=FF0000>)</font>
&nbsp;&nbsp;t<font color=FF0000>[</font>key<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;d
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Другим способом связывания значения по умолчанию с каждой таблицей является использование отдельной таблицы, где ключами являются сами таблицы, а значениями - значения по умолчанию. Однако для корректной реализации такого подхода нам нужен специальный тип таблиц, называемых <i>слабыми таблицами</i> (<i>weak table</i>), поэтому мы здесь не будем использовать данный подход; мы вернемся к этому в <a href="#Глава 17. Слабые таблицы и финализаторы">главе 17</a>.</p>

<p>Другим вариантом является запоминать метатаблицы, за счет чего мы можем переиспользовать метатаблицы, соответствующие одному и тому же значению по умолчанию. Однако это также требует использования слабых таблиц, поэтому нам придется подождать до <a href="#Глава 17. Слабые таблицы и финализаторы">главы 17</a>.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="13.4. Отслеживание доступа к таблице"></a>Отслеживание доступа к таблице
</div>

<p>И <code>__index</code>, и <code>__newindex</code> работают только в случае, когда в таблице нет соответствующего значения. Поэтому единственный способ отслеживать весь доступ к таблице - это держать ее пустой. Таким образом, если мы хотим отслеживать весь доступ к таблице, то нам нужно создать специальную <i>proxy-таблицу</i> для исходной таблицы. Она будет пустой с соответствующими метаметодами <code>__index</code> и <code>__newindex</code> для отслеживания доступа к таблице, которые будут перенаправлять доступ к исходной таблице. Пусть <code>t</code> - это исходная таблица, доступ к которой мы хотим отслеживать. Тогда мы можем использовать следующий код:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;исходная&nbsp;таблица&nbsp;создана&nbsp;где-то</font>

<font color=008000>--&nbsp;создадим&nbsp;закрытый&nbsp;доступ&nbsp;к&nbsp;ней</font>
<font color=0000DF>local</font>&nbsp;_t&nbsp;<font color=FF0000>=</font>&nbsp;t

<font color=008000>--&nbsp;создадим&nbsp;proxy</font>
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>

<font color=008000>--&nbsp;создадим&nbsp;метатаблицу</font>
<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"*access&nbsp;to&nbsp;element&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font>k<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;_t<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=008000>--&nbsp;доступ&nbsp;к&nbsp;исходной&nbsp;таблице</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>
&nbsp;&nbsp;
&nbsp;&nbsp;__newindex&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"*update&nbsp;of&nbsp;element&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font>k<font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;to&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font>v<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;_t<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;изменение&nbsp;исходной&nbsp;таблицы</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=FF0000>}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
</pre>

<p>Этот код отслеживает каждый доступ к <code>t</code>:</p>

<pre class="code">
t<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"hello"</font>&nbsp;<font color=008000>--&nbsp;update&nbsp;of&nbsp;element&nbsp;2&nbsp;to&nbsp;hello</font>
<font color=0080C0>print</font><font color=FF0000>(</font>t<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>])</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;access&nbsp;to&nbsp;element&nbsp;2</font>
<font color=008000>--&gt;&nbsp;hello</font>
</pre>

<p>Если мы хотим иметь возможность обходить такую таблицу, то нам нужно создать в proxy-таблице метаметод <code>__pairs</code>:</p>

<pre class="code">
mt<font color=FF0000>.</font>__pairs&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>_<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0080C0>next</font><font color=FF0000>(</font>_t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Также можно создать что-то похожее для <code>__ipairs</code>.</p>

<p>Если мы хотим отслеживать доступ к нескольким таблицам, тонам не нужно для каждой из них создавать отдельную метатаблицу. Вместо этого мы можем как-нибудь связать <i>рrоху</i>-таблицу с исходной и использовать одну общую метатаблицу для всех proxy-таблиц. Это похоже на задачу связывания таблицы со значением по умолчанию, которые мы рассматривали ранее. Например, можно хранить исходную таблицу в специальном поле <i>proxy</i>-таблицы, используя для этого специальный ключ. В результате мы приходим к следующему коду:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;создать&nbsp;уникальный&nbsp;ключ</font>
<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создать&nbsp;метатаблицу</font>
&nbsp;&nbsp;__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"*access&nbsp;to&nbsp;element&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font>k<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;t<font color=FF0000>[</font>index<font color=FF0000>][</font>k<font color=FF0000>]</font>&nbsp;<font color=008000>--&nbsp;обращение&nbsp;к&nbsp;исходной&nbsp;таблице</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>
&nbsp;&nbsp;__newindex&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"*update&nbsp;of&nbsp;element&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font>k<font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"&nbsp;to&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font>v<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;t<font color=FF0000>[</font>index<font color=FF0000>][</font>k<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;изменение&nbsp;исходной&nbsp;таблицы</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>
&nbsp;&nbsp;__pairs&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0080C0>next</font><font color=FF0000>(</font>t<font color=FF0000>[</font>index<font color=FF0000>],</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>&nbsp;t
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=FF0000>}</font>
<font color=0000DF>function</font>&nbsp;track&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;proxy&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;proxy<font color=FF0000>[</font>index<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;t
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>proxy<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;proxy
<font color=0000DF>end</font>
</pre>

<p>Теперь, когда мы хотим отслеживать таблицу <code>t</code>, все что нам нужно, - это выполнить <code>t=track(t)</code>.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="13.4. Таблицы, доступные только для чтения"></a>Таблицы, доступные только для чтения
</div>

<p>Легко использовать понятие <i>proxy</i>-таблиц для создания таблиц с доступом только на чтение. Все, что нам нужно, - это вызвать ошибку каждый раз, когда мы ловим попытку изменить таблицу. Для метаметода <code>__index</code> мы можем использовать саму исходную таблицу вместо функции, так как нам не нужно отслеживать все чтения из нее; быстрее и эффективнее перенаправлять такие запросы сразу к исходной таблице. Это потребует, однако, новой метатаблицы для каждой <i>proxy</i>-таблицы с полем <code>__index</code>, указывающим на исходную таблицу:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;readOnly&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;proxy&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>&nbsp;<font color=008000>--&nbsp;создать&nbsp;метатаблицу</font>
&nbsp;&nbsp;&nbsp;&nbsp;__index&nbsp;<font color=FF0000>=</font>&nbsp;t<font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;__newindex&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"attempt&nbsp;to&nbsp;update&nbsp;a&nbsp;read-only&nbsp;table"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF0000>}</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>proxy<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;proxy
<font color=0000DF>end</font>
</pre>

<p>В качестве примера таблицы, доступной только на чтение, мы можем создать таблицу названий дней недели:</p>

<pre class="code">
days&nbsp;<font color=FF0000>=</font>&nbsp;readOnly<font color=FF0000>{</font><font color=8888CC>"Sunday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Monday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Tuesday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Wednesday"</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=8888CC>"Thursday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Friday"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Saturday"</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>days<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>])</font>&nbsp;<font color=008000>--&gt;&nbsp;Sunday</font>
days<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Noday"</font>
<font color=008000>--&gt;&nbsp;stdin:1:&nbsp;attempt&nbsp;to&nbsp;update&nbsp;a&nbsp;read-only&nbsp;table</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="13. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 13.1.</b><br>
Определите метаметод <code>__sub</code>, который возвращает разницу двух множеств (Множество <code>а-b</code> - это множество всех элементов из <code>а</code>, которые не содержатся в <code>b</code>.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 13.2.</b><br>
Определите метаметод <code>__len</code> так, что <code>#s</code> возвращает число элементов в <code>s</code>.</p>

<hr color="#99CCFF">

<p><b>Упражнение 13.3.</b><br>
Дополните реализацию <i>proxy</i>-таблиц в <a href="#13.4. Метаметоды для доступа к таблице">разделе 13.4</a> метаметодом <code>__ipairs</code>.</p>

<hr color="#99CCFF">

<p><b>Упражнение 13.4.</b><br>
Другим способом реализации таблиц, доступных только для чтения, является использование функции в качестве метаметода <code>__index</code>. Этот подход делает доступ к таблице более дорогим, но создание таких таблиц более дешевом, так как все таблицы, доступные только для чтения, могут иметь одну общую метатаблицу. Перепишите функцию <code>readonly</code> с использованием данного подхода.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 14. Окружение"></a>Глава 14. Окружение
</div>

<p>Lua хранит все свои глобальные переменные в обычной таблице, называемой <i>глобальным окружением</i> (<i>global environment</i>) (Точнее, Lua хранит свои «глобальные» переменные в нескольких окружениях, но мы для простоты будем это вначале игнорировать.) Одним из преимуществ этого подхода является то, что он упрощает внутреннюю реализацию Lua, поскольку нет необходимости в специальной структуре данных для хранения глобальных переменных. Другим преимуществом является то, что мы можем работать с этой таблицей так же, как и с любой другой таблицей. Для упрощения такой работы Lua хранит само окружение в глобальной переменной <code>_G</code>. (Да, <code>_G._G</code> равно <code>_G</code>.) Например, следующий код печатает имена всех глобальных переменных, определенных в глобальном окружении:</p>

<pre class="code"><font color=0000DF>for</font>&nbsp;n&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>n<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font></pre>

<p>В этой главе мы увидим несколько полезных методов для работы с окружением.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="14.1. Глобальные переменные с динамическими именами"></a>14.1. Глобальные переменные с динамическими именами
</div>

<p>Обычно присваивания достаточно для доступа к и установки значения глобальной переменной. Однако часто нам бывает нужен вариант метапрограммирования, когда мы хотим работать с глобальной переменной, имя которой содержится в другой переменной или вычисляется в ходе работы. Чтобы получить значение такой переменной, многие программисты пытаются использовать что-то вроде следующего фрагмента кода:</p>

<pre class="code">value&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>loadstring</font><font color=FF0000>(</font><font color=8888CC>"return&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;varname<font color=FF0000>)()</font></pre>

<p>Если varname равно <code>x</code>, то в результате конкатенации мы получим <code>"return х"</code>, что при выполнении даст нам желаемый результат. Однако этот код включает в себя создание и компиляцию нового блока кода, что является дорогостоящим. Вы можете добиться того же самого при помощи следующего кода, который более чем на порядок более эффективен, чем ранее рассмотренный код:</p>

<pre class="code">value&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>[</font>varname<font color=FF0000>]</font></pre>

<p>Поскольку окружение - это обычная таблица, то вы можете просто обращаться к нему по ключу (имени переменной). Похожим образом молено также присвоить значение переменной, имя которой вычисляется динамически, при помощи кода <code>_G[varname]=value</code>. Однако будьте осторожны: некоторые программисты так радуются подобной возможности, что заканчивают написанием кода вроде <code>_G["а"] =_G["var1"]</code>, что является просто сложным вариантом <code>a = var1</code>.</p>

<p>Обобщением предыдущей задачи является использование имен полей в динамических именах, например <code>"io.read"</code> или <code>"a.b.c.d"</code>. Однако если мы напишем <code>_G["io.read"]</code>, то мы точно не получим поле <code>read</code> из таблицы <code>io</code>. Но мы можем написать функцию <code>getfield</code>, такую что <code>getfield("io.read")</code> вернет ожидаемое значение. Эта функция представляет из себя цикл, который начинается с <code>_G</code> и дальше последовательно перебирает поля:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;getfield&nbsp;<font color=FF0000>(</font>f<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;v&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font>&nbsp;<font color=008000>--&nbsp;начать&nbsp;с&nbsp;таблицы&nbsp;глобальный&nbsp;переменных</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>f<font color=FF0000>,</font>&nbsp;<font color=8888CC>"[%w_]+"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;<font color=FF0000>=</font>&nbsp;v<font color=FF0000>[</font>w<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;v
<font color=0000DF>end</font>
</pre>

<p>Мы используем функцию <code>gmatch</code> из библиотеки <code>string</code> для того, чтобы обойти все слова в <code>f</code> (слово - это последовательность букв, цифр и знака подчеркивания).</p>

<p>Соответствующая функция для установки значений полей является более сложной. Присваивание вроде <code>а.b.с.d=v</code> эквивалентно следующему коду:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;temp&nbsp;<font color=FF0000>=</font>&nbsp;a<font color=FF0000>.</font>b<font color=FF0000>.</font>c
temp<font color=FF0000>.</font>d&nbsp;<font color=FF0000>=</font>&nbsp;v
</pre>

<p>To есть мы должны извлечь имя без последней компоненты и затем отдельно обработать последнюю компоненту. Функция <code>setfield</code> выполняет это и также создает вспомогательные таблицы в пути, если они не существуют:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;setfield&nbsp;<font color=FF0000>(</font>f<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;начинаем&nbsp;с&nbsp;таблицы&nbsp;глобальных&nbsp;переменных</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;w<font color=FF0000>,</font>&nbsp;d&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>f<font color=FF0000>,</font>&nbsp;<font color=8888CC>"([%w_]+)(%.?)"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;d&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"."</font>&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;не&nbsp;последнее&nbsp;имя?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;t<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;создает&nbsp;таблицу,&nbsp;если&nbsp;ее&nbsp;нет</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;<font color=FF0000>=</font>&nbsp;t<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;получаем&nbsp;таблицу</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;последнее&nbsp;имя</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t<font color=FF0000>[</font>w<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;выполняем&nbsp;присваивание</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>В переменной <code>w</code> запоминается имя поля, и, возможно, следующая за ним точка запоминается в переменной <code>d</code> (Мы рассмотрим использование шаблонов в <a href="#Глава 21. Библиотека для работы со строками">главе 21</a>). Если за именем не следует точка, то это последнее имя.</p>

<p>Используя ранее рассмотренные функции, следующий код создает глобальную таблицу <code>t</code>, таблицу <code>t.х</code> и затем присваивает <code>10 t.х.у</code>:</p>

<pre class="code">
setfield<font color=FF0000>(</font><font color=8888CC>"t.x.y"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>t<font color=FF0000>.</font>x<font color=FF0000>.</font>y<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10</font>
<font color=0080C0>print</font><font color=FF0000>(</font>getfield<font color=FF0000>(</font><font color=8888CC>"t.x.y"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;10</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="14.2. Описания глобальных переменных"></a>14.2. Описания глобальных переменных
</div>

<p>В Lua глобальным переменным не нужны описания. Хотя это и удобно для небольших программ, в больших программах всего одна опечатка может привести к трудно обнаруживаемым ошибкам. Однако при желании мы можем изменить это поведение. Поскольку Lua хранит глобальные переменные в обычной таблице, то мы можем использовать метатаблицы для изменения поведения при обращении к глобальным переменным.</p>

<p>Первый подход просто отслеживает любые обращения к отсутствующим ключам в глобальной таблице:</p>

<pre class="code">
<font color=0080C0>setmetatable</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;__newindex&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>_<font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"attempt&nbsp;to&nbsp;write&nbsp;to&nbsp;undeclared&nbsp;variable&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;n<font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>
&nbsp;&nbsp;__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>_<font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"attempt&nbsp;to&nbsp;read&nbsp;undeclared&nbsp;variable&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;n<font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>
<font color=FF0000>})</font>
</pre>

<p>После выполнения этого кода любая попытка обратиться к несуществующей глобальной переменной приведет к возникновению ошибки:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>
<font color=008000>--&gt;&nbsp;stdin:1:&nbsp;attempt&nbsp;to&nbsp;read&nbsp;undeclared&nbsp;variable&nbsp;a</font>
</pre>

<p>Однако как мы будем обьявлять глобальные переменные? Одним вариантом является использование <code>rawset</code>, который не использует метаметоды:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;declare&nbsp;<font color=FF0000>(</font>name<font color=FF0000>,</font>&nbsp;initval<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0080C0>rawset</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>,</font>&nbsp;name<font color=FF0000>,</font>&nbsp;initval&nbsp;<font color=0000DF>or</font>&nbsp;<font color=0000DF>false</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>(Конструкция or <b>false</b> нужна затем, чтобы глобальная переменная получила значение, отличное от <b>nil</b>.)</p>

<p>Более простым вариантом является ограничить присваивания новым глобальным переменным только внутри функций, позволяя присваивания на внешнем уровне блока.</p>

<p>Для проверки того, что присваивание происходит в главном блоке, нам нужно использовать отладочную библиотеку. Вызов <code>debug.getinfo(2, "S")</code> возвращает таблицу, у которой поле <code>what</code> говорит о том, является ли функция, вызвавшая метаметод, главным блоком, обычной функцией или С-функцией (Мы обсудим <code>debug.getinfo</code> более подробно в <a href="#Глава 24. Отладочная библиотека">главе 24</a>.) Используя эту функцию, мы можем переписать метаметод <code>__newindex</code> следующим образом:</p>

<pre class="code">
__newindex&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;n<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;w&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getinfo</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"S"</font><font color=FF0000>).</font>what
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;w&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"main"</font>&nbsp;<font color=0000DF>and</font>&nbsp;w&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"C"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"attempt&nbsp;to&nbsp;write&nbsp;to&nbsp;undeclared&nbsp;variable&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;n<font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0080C0>rawset</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;n<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Эта новая версия также допускает присваивания в С-коде, так как обычно в этом коде авторы знают, что они делают.</p>

<p>Для проверки того, что такая переменная существует, мы не можем просто сравнить ее с <code>nil</code>, поскольку если она <b>nil</b>, то обращение приведет к ошибке. Вместо этого мы используем функцию <code>rawget</code>, которая не использует метаметод:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;<font color=0080C0>rawget</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>,</font>&nbsp;var<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;'var'&nbsp;is&nbsp;undeclared</font>
&nbsp;&nbsp;<font color=FF0000>...</font>
<font color=0000DF>end</font>
</pre>

<p>Сейчас наш подход не допускает глобальных переменных со значением <b>nil</b>, поскольку они автоматически будут считаться необьявленными. Но это легко исправить. Все, что нам нужно, - это дополнительная таблица, содержащая имена описанных переменных. При вызове метаметода он по этой таблице проверяет, описана ли эта переменная. Похожий код приведен в <a href="#листинг 14.1">листинге 14.1</a>. Теперь даже присваивания <code>x=nil</code> достаточно, чтобы обьявить глобальную переменную.</p>

<p>Цена обоих решений крайне незначительна. При первом решении, при нормальной работе метаметод вообще не вызывается. При втором решении метаметоды могут быть вызваны, когда программа обращается к переменной, значение которой равно <b>nil</b>.</p>

<p>Стандартная поставка Lua содержит модуль <code>strict.lua</code>, который реализует проверку обращений к глобальным переменным, аналогичную рассмотренному нами коду. Хорошей привычкой является использовать его при написании кода на Lua.</p>

<p><a name="листинг 14.1"></a><b class="sect">Листинг 14.1</b>. Проверка описаний глобальных переменных</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;declaredNames&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>

<font color=0080C0>setmetatable</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;__newindex&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;n<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;declaredNames<font color=FF0000>[</font>n<font color=FF0000>]</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;w&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getinfo</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"S"</font><font color=FF0000>).</font>what
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;w&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"main"</font>&nbsp;<font color=0000DF>and</font>&nbsp;w&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"C"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"attempt&nbsp;to&nbsp;write&nbsp;to&nbsp;undeclared&nbsp;variable&nbsp;"</font><font color=FF0000>..</font>n<font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;declaredNames<font color=FF0000>[</font>n<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>rawset</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;n<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;do&nbsp;the&nbsp;actual&nbsp;set</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>
&nbsp;&nbsp;
&nbsp;&nbsp;__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>_<font color=FF0000>,</font>&nbsp;n<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;declaredNames<font color=FF0000>[</font>n<font color=FF0000>]</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"attempt&nbsp;to&nbsp;read&nbsp;undeclared&nbsp;variable&nbsp;"</font><font color=FF0000>..</font>n<font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>nil</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>,</font>
<font color=FF0000>})</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="14.3. Неглобальные окружения"></a>14.3. Неглобальные окружения
</div>

<p>Одной из проблем окружения является то, что оно глобальное. Любое его изменение влияет на все части вашей программы. Например, когда вы устанавливаете метатаблицу для управления глобальным доступом, вся ваша программа должна следовать соответствующей политике. Если вы хотите использовать библиотеку, которая использует глобальные переменные без их обьявления, то вам не повезло.</p>

<p>В Lua глобальные переменные не обязаны быть действительно глобальными. Мы можем даже сказать, что в Lua нет глобальных переменных. Это может звучать странно, поскольку с самого начала книги мы использовали глобальные переменные. Очевидно, что Lua очень старается создать иллюзию наличия глобальных переменных. Давайте посмотрим, как Lua создает эту иллюзию (Обратитте внимание, что этот механизм был одной их тех частей Lua, которые поменялись с версии 5.1 до версии 5.2. Следующее обсуждение относится только к Lua 5.2 и очень мало применимо к предыдущим версиям).</p>

<p>Начнем с понятия свободных имен. <i>Свободное имя</i> -- это имя не привязано к явному описанию, то есть не встречается внутри области действия локальной переменной (или переменной цикла <b>for</b>, или параметра) с этим именем. Например, оба имени <code>var1</code> и <code>var2</code> - это свободные имена в следующем блоке:</p>

<pre class="code">var1&nbsp;<font color=FF0000>=</font>&nbsp;var2&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>3</font></pre>

<p>В отличие от того, что было сказано ранее, свободное имя не относится к глобальной переменной (по крайней мере, не непосредственно). Вместо этого Lua переводит любое свободное имя var в <code>_ENV.var</code>. Поэтому предыдущий блок эквивалентен следующему:</p>

<pre class="code"><font color=0080C0>_ENV</font><font color=FF0000>.</font>var1&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_ENV</font><font color=FF0000>.</font>var2&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>3</font></pre>

<p>Но что такое эта новая переменная <code>_ENV</code> ? Она не может быть глобальной переменной, иначе мы снова возвращаемся к исходной проблеме. Компилятор снова жульничает. Я уже говорил, что Lua рассматривает каждый блок как анонимную функцию. На самом деле Lua компилирует наш исходный блок в следующий код:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>&lt;</font>some&nbsp;value<font color=FF0000>&gt;</font>
<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(...)</font>
&nbsp;&nbsp;<font color=0080C0>_ENV</font><font color=FF0000>.</font>var1&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_ENV</font><font color=FF0000>.</font>var2&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>3</font>
<font color=0000DF>end</font>
</pre>

<p>To есть Lua компилирует любой блок кода в присутствии предопределенного значения с именем <code>_ENV</code>.</p>

<p>Обычно когда мы загружаем блок кода, то функция <code>load</code> инициализирует это предопределенное значение ссылкой на глобальное окружение. Поэтому наш исходный блок становится эквивалентным следующему блоку:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>&lt;</font>the&nbsp;global&nbsp;environment<font color=FF0000>&gt;</font>
<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(...)</font>
&nbsp;&nbsp;<font color=0080C0>_ENV</font><font color=FF0000>.</font>var1&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_ENV</font><font color=FF0000>.</font>var2&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>3</font>
<font color=0000DF>end</font>
</pre>

<p>Результатом всех этих присваиваний является то, что поле <code>var1</code> из глобального окружения получает значение поля <code>var2</code> плюс <code>3</code>.</p>

<p>На первый взгляд это может показаться несколько запутанным способом работать с глобальным окружением. Я не буду утверждать, что это простейший способ, но он достигает гибкости, которую трудно получить более простой реализацией.</p>

<p>Прежде чем мы продолжим, давайте сформулируем, как Lua 5.2 работает с глобальными переменными:</p>
<ul>
  <li>Lua компилирует любой блок с использованием значения <code>_ENV</code>.</li>
  <li>Компилятор переводит любое свободное имя <code>var</code> в <code>_ENV.var</code>.</li>
  <li>Функция <code>load</code> (или <code>loadfile</code>) инициализирует значение <code>_ENV</code> ссылкой на глобальное окружение.</li>
</ul>

<p>В конце концов, все не так уж и сложно.</p>

<p>Некоторых это смущает, поскольку они пытаются найти какую-то магию, стоящую за этими правилами. Нет тут никакой магии. В частности, первые два правила полностью делаются компилятором. За исключением того, что величина <code>_ENV</code> известна компилятору, она является обычной переменной. За исключением компиляции, <code>_ENV</code> не имеет какого-то специального смысла в Lua (Если быть честными до конца, то Lua использует это имя для сообщений об ошибках, поскольку она возвращает ошибку, включающую переменную <code>_ENV.x</code> как ошибку с переменной <code>global х</code>.). Аналогично перевод из <code>var</code> в <code>_ENV.var</code> - это просто синтаксическая замена без скрытого смысла. В частности, после этого перевода <code>_ENV</code> будет относиться к той переменной <code>_ENV</code>, которая видна в данном фрагменте кода, исходя из правил видимости.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="14.4. Использование _ENV"></a>14.4. Использование _ENV
</div>

<p>В этом разделе мы рассмотрим некоторые пути использования той гибкости, которая привносится переменной <code>_ENV</code>. Имейте в виду, что каждый из этих примеров должен быть запущен как отдельный, самостоятельный блок кода. Если вы будете вводить строка за строкой в интерпретаторе, то каждая строка становится отдельным блоком и получает свою переменную <code>_ENV</code>. Для выполнения фрагмента кода как отдельного блока вам нужно либо запустить его как файл, либо в интерактивном режиме поместить внутрь пары <b>do-end</b>.</p>

<p>Поскольку <code>_ENV</code> - это обычная переменная, то мы можем присваивать ей и читать ее так же, как и любую другою переменную. Присваивание <code>_ENV = nil</code> запретит любой доступ к глобальным переменным на протяжении оставшейся части блока. Это может быть полезным для контроля того, какие переменные ваш код использует:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>,</font>&nbsp;sin&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.sin</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=AC00A9>13</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;13</font>
<font color=0080C0>print</font><font color=FF0000>(</font>sin<font color=FF0000>(</font><font color=AC00A9>13</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0.42016703682664</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>math.cos</font><font color=FF0000>(</font><font color=AC00A9>13</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&nbsp;error!</font>
</pre>

<p>Любое присваивание свободному имени приведет к аналогичной ошибке. Мы можем явно обращаться к <code>_ENV</code> для того, чтобы обойти локальные переменные:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>13</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;global</font>
<font color=0000DF>local</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>12</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;12&nbsp;(local)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>_ENV</font><font color=FF0000>.</font>a<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;13&nbsp;(global)</font>
</pre>

<p>Конечно, главным использованием <code>_ENV</code> является изменение окружения, используемого фрагментом кода. Как только вы изменили ваше окружение, все обращения к глобальным переменным будут использовать новую таблицу:</p>

<pre class="code">
<font color=008000>--&nbsp;изменить&nbsp;текущее&nbsp;окружение&nbsp;на&nbsp;пустую&nbsp;таблицу</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=008000>--&nbsp;создать&nbsp;поле&nbsp;в&nbsp;_ENV</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;stdin:4:&nbsp;attempt&nbsp;to&nbsp;call&nbsp;global&nbsp;'print'&nbsp;(a&nbsp;nil&nbsp;value)</font>
</pre>

<p>Если новое окружение пусто, то вы теряете доступ ко всем глобальным переменным, включая <code>print</code>. Поэтому вам сперва нужно заполнить его некоторыми полезными значениями, например старым окружением:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>15</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;глобальную&nbsp;переменную</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>g&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>}</font>&nbsp;<font color=008000>--&nbsp;изменяем&nbsp;текущее&nbsp;окружение</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;поле&nbsp;в&nbsp;_ENV</font>
g<font color=FF0000>.</font>print<font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;1</font>
g<font color=FF0000>.</font>print<font color=FF0000>(</font>g<font color=FF0000>.</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;15</font>
</pre>

<p>Теперь, когда вы обращаетесь к «глобальной» <code>g</code>, вы получаете старое окружение, в котором есть функция <code>print</code>.</p>

<p>Мы можем переписать предыдущий пример, используя имя <code>_G</code> вместо <code>g</code>:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>15</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;глобальную&nbsp;переменную</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=0080C0>_G</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>}</font>&nbsp;<font color=008000>--&nbsp;изменяем&nbsp;текущее&nbsp;окружение</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;поле&nbsp;в&nbsp;_ENV</font>
<font color=0080C0>_G</font><font color=FF0000>.</font>print<font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;1</font>
<font color=0080C0>_G</font><font color=FF0000>.</font>print<font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>.</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;15</font>
</pre>

<p>Для Lua имя <code>_G</code> - это такое же имя, как и все остальные. Его отличительной чертой является только то, что когда Lua создает глобальную таблицу, то она присваивает ее переменной с именем <code>_G</code>. Для Lua не важно текущее значение этой переменной. Но обычно принято использовать одно и то же имя, когда мы обращаемся к глобальной переменной, как мы это делали в переписанном примере.</p>

<p>Другой способ заполнить ваше новое окружение - это наследование:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
<font color=0000DF>local</font>&nbsp;newgt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;создать&nbsp;новое&nbsp;окружение</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>newgt<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>})</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;newgt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;установить&nbsp;его</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;1</font>
</pre>

<p>В этом коде новое окружение наследует <code>print</code> и <code>а</code> из старого окружения. Однако любое присваивание идет в новую таблицу. Тем самым нет опасности по ошибке изменить глобальное окружение, хотя его все равно можно изменить через <code>_G</code>:</p>

<pre class="code">
<font color=008000>--&nbsp;продолжаем&nbsp;предыдущий&nbsp;код</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>.</font>a<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;1</font>
<font color=0080C0>_G</font><font color=FF0000>.</font>a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>20</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>.</font>a<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;20</font>
</pre>

<p>Поскольку <code>_ENV</code> является обычной переменной, она подчиняется обычным правилам видимости. В частности, функции, определенные внутри блока, обращаются к <code>_ENV</code> так же, как и к любой другой внешней переменной:</p>

<pre class="code">
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=0080C0>_G</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>}</font>
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0080C0>_G</font><font color=FF0000>.</font>print<font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;компилируется&nbsp;в&nbsp;'_ENV._G.print(_ENV.a)'</font>
<font color=0000DF>end</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;_ENV.a</font>
foo<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=0080C0>_G</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>,</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>}</font>
foo<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;20</font>
</pre>

<p>Если мы определим новую локальную переменную с именем <code>_ENV</code>, то доступ к свободным именам будет идти через нее:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>2</font>
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font><font color=0080C0>print</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>,</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>14</font><font color=FF0000>}</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;14</font>
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;2&nbsp;(назад&nbsp;к&nbsp;исходной&nbsp;_ENV)</font>
</pre>

<p>Поэтому несложно построить функцию с собственным (закрытым) окружением:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;factory&nbsp;<font color=FF0000>(</font><font color=0080C0>_ENV</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;a&nbsp;<font color=008000>--&nbsp;"глобальная"&nbsp;a</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
f1&nbsp;<font color=FF0000>=</font>&nbsp;factory<font color=FF0000>{</font>a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>6</font><font color=FF0000>}</font>
f2&nbsp;<font color=FF0000>=</font>&nbsp;factory<font color=FF0000>{</font>a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>7</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>f1<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;6</font>
<font color=0080C0>print</font><font color=FF0000>(</font>f2<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;7</font>
</pre>

<p>Функция <code>factory</code> создает простые замыкания, которые возвращают значение и локальных переменных <code>а</code>. Когда замыкание создано, то видимая переменная <code>_ENV</code> - это параметр <code>_ENV</code> из содержащей функции <code>factory</code>; поэтому замыкание использует эту переменную для доступа к свободным именам.</p>

<p>Используя обычные правила видимости, мы можем работать с окружениями различными способами. Например, у нас может быть несколько функций с общим для них окружением или функция, которая изменяет окружение, общее с другими функциями.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="14.5. ENV и load"></a>14.5. ENV и load
</div>

<p>Как я уже упоминал, <code>load</code> обычно инициализирует значение <code>_ENV</code> загруженного блока указателем на глобальное окружение. Однако у <code>load</code> есть необязательный четвертый параметр, который задаст значение для <code>_ENV</code>.(Функция <code>loadfile</code> также имеет аналогичный параметр.)</p>

<p>В качестве примера пусть у нас есть типичный конфигурационный файл, определяющий различные константы и функции, используемые программой; это может быть что-то вроде:</p>

<pre class="code">
<font color=008000>--&nbsp;file&nbsp;'config.lua'</font>
width&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>200</font>
height&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>300</font>
<font color=FF0000>...</font>
</pre>

<p>Мы можем загрузить его при помощи следующего кода:</p>

<pre class="code">
env&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>loadfile</font><font color=FF0000>(</font><font color=8888CC>"config.lua"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"t"</font><font color=FF0000>,</font>&nbsp;env<font color=FF0000>)</font>
f<font color=FF0000>()</font>
</pre>

<p>Весь код из конфигурационного файла будет выполнен с пустым окружением <code>env</code>. Более важно, что все его определения пойдут именно в это окружение. Конфигурационный файл не может повлиять на что-либо еще, даже по ошибке. Даже зловредный код не может причинить много вреда. Он может выполнить DoS-атаку, тратя время CPU и память, но ничего больше.</p>

<p>Иногда вам может понадобиться выполнить блок несколько раз, каждый раз с другой таблицей окружения. В этом случае дополнительный аргумент у <code>load</code> нам не помогает. Вместо этого у нас есть два варианта.</p>

<p>Первый вариант - это использовать функцию <code>debug.setupvalue</code> из отладочной библиотеки. Как следует из имени, <code>setupvalue</code> позволяет нам изменить любое входящее значение (<code>upvalue</code>) заданной функции. Следующий код иллюстрирует его использование:</p>

<pre class="code">
f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>loadfile</font><font color=FF0000>(</font>filename<font color=FF0000>)</font>
<font color=FF0000>...</font>
env&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=FF8000>debug.setupvalue</font><font color=FF0000>(</font>f<font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;env<font color=FF0000>)</font>
</pre>

<p>Первый аргумент при вызове <code>setupvalue</code> - это функция, второй -это индекс значения, и третий -- это новое значение. Для нашего использования второй аргумент всегда равен единице: когда функция является результатом <code>load</code> или <code>loadfile</code>, Lua гарантирует, что будет всего одно значение и это значение есть <code>_ENV</code>.</p>

<p>Неболыиим минусом данного решения является зависимость от отладочной библиотеки. Эта библиотека нарушает некоторые стандартные предположения насчет программ. Например, <code>debug.setupvalue</code> нарушает правила видимости Lua, которые гарантируют, что переменная не может быть увидена за пределами своей области видимости.</p>

<p>Другим способом запускать блок с различными окружениями является небольшое изменение блока при его загрузке. Представьте себе, что мы добавляем следующую строку к началу загружаемого блока:</p>

<pre class="code"><font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>...;</font></pre>

<p>Вспомним из <a href="#8.1. Компиляция">раздела 8.1</a>, что Lua любой блок рассматривает как функцию с переменным числом аргументов. Поэтому эта строка присвоит переменной <code>_ENV</code> первый аргумент блока, устанавливая его как окружение. После загрузки блока мы вызываем получающуюся функцию, передавая желаемое окружение как первый аргумент. Следующий фрагмент кода иллюстрирует эту идею, используя функцию <code>loadwithprefix</code> из <a href="#упражнение 8.1">упражнения 8.1</a>:</p>

<pre class="code">
f&nbsp;<font color=FF0000>=</font>&nbsp;loadwithprefix<font color=FF0000>(</font><font color=8888CC>"local&nbsp;_ENV&nbsp;=&nbsp;...;"</font><font color=FF0000>,</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;<font color=8888CC>"*L"</font><font color=FF0000>))</font>
<font color=FF0000>...</font>
env&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
f<font color=FF0000>(</font>env<font color=FF0000>)</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="14. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 14.1.</b><br>
Функция <code>getfield</code>, которую мы определили в начале этой главы, обеспечивает слишком мало контроля, так как она допускает такие поля, как <code>math?sin</code> или <code>string!!!gsub</code>. Перепишите ее так, чтобы она воспринимала в качестве разделителя только одну точку (Для этого упражнения вам может понадобиться информация из <a href="#Глава 21. Библиотека для работы со строками">главы 21</a>.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 14.2.</b><br>
Обьясните в деталях, что происходит в следующей программе и какой будет ее вывод.</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;foo
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_ENV</font>
&nbsp;&nbsp;<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>X<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
X&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>13</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
foo<font color=FF0000>()</font>
X&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
</pre>

<hr color="#99CCFF">

<p><b>Упражнение 14.3.</b><br>
Обьясните в деталях, что происходит в следующей программе и какой будет ее вывод.</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0080C0>print</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>print</font>
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font><font color=0080C0>_ENV</font><font color=FF0000>,</font>&nbsp;a<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>a&nbsp;<font color=FF0000>+</font>&nbsp;b<font color=FF0000>)</font>
<font color=0000DF>end</font>
foo<font color=FF0000>({</font>b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>14</font><font color=FF0000>},</font>&nbsp;<font color=AC00A9>12</font><font color=FF0000>)</font>
foo<font color=FF0000>({</font>b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>},</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>
</pre>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 15. Модули и пакеты"></a>Глава 15. Модули и пакеты
</div>

<p>Обычно Lua не устанавливает каких-либо соглашений. Вместо этого Lua предоставляет механизмы, которые достаточно мощны для групп разработчиков для реализации тех соглашений, которые им подходят. Однако этот подход плохо работает для модулей. Одной из основных целей системы модулей является позволить различным людям совместно использовать код. Отсутствие общей политики мешает этому совместному использованию.</p>

<p>Начиная с версии 5.1, Lua определил набор соглашений для модулей и пакетов (пакет - это набор модулей). Эти соглашения не требуют каких-либо дополнительных возможностей от языка; программисты могут их реализовать, используя то, что мы уже в языке видели: таблицы, функции, метатаблицы и окружения. Программисты могут использовать другие соглашения. Однако другие соглашения могут привести к тому, что нельзя будет использовать чужие модули и свои модули не могут быть использованы в чужих программах.</p>

<p>С точки зрения пользователя, <i>модуль</i> - это некоторый код (на Lua или на С), который может быть загружен при помощи <code>require</code> и который создает и возвращает таблицу. Все, что модуль экспортирует, будь это функции или таблицы, он определяет внутри этой таблицы, которая выступает в качестве пространства имен.</p>

<p>Например, все стандартные библиотеки - это модули. Вы можете использовать математическую библиотеку следующим образом:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;m&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font>&nbsp;<font color=8888CC>"math"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>m<font color=FF0000>.</font>sin<font color=FF0000>(</font><font color=AC00A9>3.14</font><font color=FF0000>))</font>
</pre>

<p>Однако отдельный интерпретатор (доступный в виде командной строки) заранее загружает все стандартные библиотеки при помощи кода, эквивалентного следующему:</p>

<pre class="code">
<font color=0080C0>math</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font>&nbsp;<font color=8888CC>"math"</font>
<font color=8000FF>string</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font>&nbsp;<font color=8888CC>"string"</font>
<font color=FF0000>...</font>
</pre>

<p>Эта загрузка позволяет нам использовать обычную запись <code>math.sin</code>. Очевидным плюсом от использования таблиц для реализации модулей является то, что мы можем работать с модулями так же, как и с таблицами, и использовать для этого всю силу Lua. В большинстве языков модули не являются значениями первого класса (то есть они не могут быть запомнены в переменных, переданы как аргументы функциям и т. п.), поэтому этим языкам нужны специальные механизмы для каждой возможности, которую они хотят предложить для модулей. В Lua вы получаете эти возможности бесплатно.</p>

<p>Например, существует несколько способов вызвать функцию из модуля. Обычным способом является следующий:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;mod&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font>&nbsp;<font color=8888CC>"mod"</font>
mod<font color=FF0000>.</font>foo<font color=FF0000>()</font>
</pre>

<p>Пользователь может установить любое локальное имя для модуля:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;m&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font>&nbsp;<font color=8888CC>"mod"</font>
m<font color=FF0000>.</font>foo<font color=FF0000>()</font>
</pre>

<p>Также можно предоставить альтернативные имена для отдельных функций:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;m&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font>&nbsp;<font color=8888CC>"mod"</font>
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;mod<font color=FF0000>.</font>foo
f<font color=FF0000>()</font>
</pre>

<p>Приятной стороной этих возможностей является то, что они не требуют специальной поддержки от языка. Они используют только то, что язык и так предоставляет.</p>

<p>Распространенной жалобой на <code>require</code> является то, что эта функция не позволяет передать аргумент загружаемому модулю. Например, математический модуль мог бы получить аргумент, позволяющий выбирать между использованием градусов или радиан:</p>

<pre class="code">
<font color=008000>--&nbsp;плохой&nbsp;код</font>
<font color=0000DF>local</font>&nbsp;<font color=0080C0>math</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font><font color=FF0000>(</font><font color=8888CC>"math"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"degree"</font><font color=FF0000>)</font>
</pre>

<p>Проблемой является то, что одной из главных целей <code>require</code> является избегать загрузки уже загруженного модуля. Как только модуль загружен, он будет переиспользован любой частью программы, которая в нем нуждается. Поэтому при использовании параметров возникла бы проблема, если бы понадобился тот же самый модуль, но с другими параметрами:</p>

<pre class="code">
<font color=008000>--&nbsp;плохой&nbsp;код</font>
<font color=0000DF>local</font>&nbsp;<font color=0080C0>math</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font><font color=FF0000>(</font><font color=8888CC>"math"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"degree"</font><font color=FF0000>)</font>

<font color=008000>--&nbsp;где-то&nbsp;в&nbsp;другом&nbsp;месте&nbsp;той&nbsp;же&nbsp;программы</font>
<font color=0000DF>local</font>&nbsp;<font color=0080C0>math</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font><font color=FF0000>(</font><font color=8888CC>"math"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"radians"</font><font color=FF0000>)</font>
</pre>

<p>В случае если вы действительно хотите, чтобы ваш модуль поддерживал параметры, лучше создать явную функцию для их задания:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;mod&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font><font color=8888CC>"mod"</font>
mod<font color=FF0000>.</font>init<font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font>
</pre>

<p>Если инициализирующая функция возвращает сам модуль, то мы можем писать код вроде следующего:</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;mod&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font><font color=8888CC>"mod"</font><font color=FF0000>.</font>init<font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font></pre>

<p>Другой вариант - сделать так, чтобы модуль возвращал функцию для инициализации и уже эта функция возвращала бы таблицу модуля:</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;mod&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font><font color=8888CC>"mod"</font><font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>)</font></pre>

<p>В любом случае помните, что модуль загружается всего один раз; модуль сам должен разрешать инициализации с конфликтами.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="15.1. Функция require"></a>15.1. Функция require
</div>

<p>Функция <code>require</code> пытается свести к минимуму предположения о том, что является модулем. Для <code>require</code> модуль - это просто какой-то код, который определяет некоторые значения (такой как функции или таблицы, содержащие функции). Обычно этот код возвращает таблицу, состоящую из функций этого модуля. Однако, поскольку это делается кодом самого модуля, а не <code>require</code>, некоторые модули могут выбрать возвращать другие значения или даже иметь побочные эффекты.</p>

<p>Для загрузки модуля мы просто вызываем <code>require"modname"</code>. Первым шагом <code>require</code> является проверка по таблице <code>package.loaded</code>, не загружен ли данный модуль уже. Если это так, то <code>require</code> возвращает соответствующее значение. Поэтому, как только модуль загружен, другие вызовы, требующие загрузки этого модуля, просто вернут то же значение без выполнения какого-либо кода.</p>

<p>Если модуль еще не загружен, то <code>require</code> ищет файл на Lua с именем модуля. Если он находит такой Lua файл, то он его загружает при помощи <code>loadfile</code>. Результатом этого является функция, которую мы называем <i>загрузчиком</i>.(Загрузчик - это функция, которая при вызове возвращает модуль.)</p>

<p>Если <code>require</code> не может найти файл на Lua с именем модуля, то она ищет библиотеку на С с именем модуля. Если она находит соответствующую библиотеку на С, то она загружает ее при помощи <code>package.loadlib</code> (которую мы обсудили в <a href="#8.3. Код на С">разделе 8.3</a>) и ищет функцию с именем <code>luaopen_modname</code> (В разделе 27.3 мы обсудим как загружать библиотеки на С). В этом случае загрузчик является результатом <code>loadlib</code>, то есть функцией <code>luaopen_modname</code>, выглядящей как функция на Lua.</p>

<p>Независимо от того, является ли модуль файлом на Lua или библиотекой на С, у <code>require</code> теперь есть для него загрузчик. Для окончательной загрузки модуля <code>require</code> вызывает загрузчик с двумя аргументами: именем модуля и именем файла с загрузчиком (Большинство модулей просто игнорируют эти аргументы.) Если загрузчик возвращает какое-либо значение, то <code>require</code> возвращает это значение и запоминает его в таблице <code>package.loaded</code> для того, чтобы всегда возвращать именно это значение для этого модуля. Если загрузчик ничего не возвращает, то <code>require</code> ведет себя так лее, как если бы модуль вернул <b>true</b>. Без этого уточнения, последующие вызовы <code>require</code> снова бы выполняли этот модуль.</p>

<p>Для того чтобы заставить <code>require</code> загрузить указанный модуль еще раз, мы просто стираем запись об этом модуле из таблицы <code>package.loaded</code>:</p>

<pre class="code"><font color=FF8000>package.loaded</font><font color=FF0000>.<</font>modname<font color=FF0000>&gt;</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font></pre>

<p>В следующий раз, когда понадобится этот модуль, <code>require</code> проделает всю необходимую работу еще раз.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="15.1. Переименовывание модуля"></a>Переименовывание модуля
</div>

<p>Обычно в качестве имени модуля мы используем их изначальные имена, но иногда мы должны переименовать модуль, чтобы избежать конфликта по именам. Типичной ситуацией является загрузка разных версий одного и того же модуля, например для тестирования. Модули на Lua не имеют внутри себя зашитых имен, поэтому обычно достаточно просто переименовать соответствующий <code>.lua</code>-файл. Однако мы не можем отредактировать бинарную библиотеку для изменения имени ее функции <code>luaopen_*</code>. Для того чтобы поддерживать подобные переименования, есть маленькая хитрость внутри <code>require</code>: если имя модуля содержит минус, то <code>require</code> отрезает часть имени вплоть до знака минуса при создании имени функции <code>luaopen_*</code>. Например, если имя модуля - это <code>а-b</code>, то <code>require</code> ожидает, что соответствующая функция будет называться <code>luaopen_b</code>, а не <code>luaopen_a-b</code> (что по-любому не будет допустимым именем в языке С). Поэтому если нам нужно использовать два модуля с именем <code>mod</code>, то мы можем переименовать один из них в <code>vl-mod</code>, например. Когда мы вызовем <code>ml=require"vl-mod"</code>, <code>require</code> найдет переименованный файл <code>vl-mod</code> и внутри этого файла найдет функцию с именем <code>luaopen_mod</code>.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="15.1. Поиск по пути"></a>Поиск по пути
</div>

<p>При поиске файла на Lua <code>require</code> использует путь для поиска, который несколько отличается от обычных путей для поиска. Типичный путь - это список каталогов, где нужно искать заданный файл. Однако в ANSI С (абстрактной платформой, на которой выполняется Lua) нет понятия каталога. Поэтому путь, используемый <code>require</code>, - это список <i>шаблонов</i>, каждый из которых задает свой способ преобразования имени модуля (аргумента <code>require</code>) в имя файла. Более точно, каждый шаблон в пути - это имя файла, содержащее необязательные знаки вопроса. Для каждого шаблона <code>require</code> заменяет каждый <code>'?'</code> на имя модуля и проверяет, есть ли файл с соответствующим именем; если нет, то переходит на следующий шаблон. Шаблоны с пути разделены при помощи точки с запятой (символ, редко используемый в именах файлов в современных операционных системах). Например, если путь равен</p>

<pre class="code">?;?.lua;c:\windows\?;/usr/local/lua/?/?.lua</pre>

<p>то вызов <code>require("sql")</code> попробует открыть следующие файлы:</p>

<pre class="code">
sql
sql.lua
c:\windows\sql
/usr/local/lua/sql/sql.lua
</pre>

<p>В качестве специальных символов функция <code>require</code> использует только точку с запятой (как разделитель компонент) и вопросительный знак; все остальное, включая разделители в пути и расширения файлов, определяется самим путем.</p>

<p>Путь, который <code>require</code> использует для поиска файлов на Lua, - это всегда текущее значение переменной <code>package.path</code>. При запуске Lua она инициализирует эту неременную значением следующей переменной окружения <code>LUA_PATH_5_2</code>. Если эта переменная окружения не установлена, то Lua пытается использовать переменную окружения с именем <code>LUA_PATH</code>. Если они обе не определены, то Lua использует путь по умолчанию, задаваемый на этапе компилирования (В Lua 5.2 параметр командной строки <code>-E</code> предотвращает использование переменных окружения и приводит к использованию пути, заданного при компиляции). При использовании переменных окружения Lua подставляет путь по умолчанию вместо любой подстроки <code>";;"</code>. Например, если <code>LUA_PATH_5_2</code> равна <code>"mydir/?.lua;;"</code>, то окончательный путь будет шаблоном <code>"mydir/?.lua"</code>, за которым следует путь по умолчанию.</p>

<p>Путь для поиска библиотек на С работает таким же образом, но значение пути берется из переменной <code>package.cpath</code> (вместо <code>package.path</code>). Аналогично эта переменная получает свое начальное значение из переменной окружения <code>LUA_CPATH_5_2</code> или <code>LUA_CPATH</code>. Типичным значением для UNIX-систем бывает</p>

<pre class="code">./?.so;/usr/local/lib/lua/5.2/?.so</pre>

<p>Обратите внимание, что путь определяет расширение файла. Предыдущий пример использует <code>.so</code> для всех шаблонов; в Windows типичный шаблон будет похож на следующий:</p>

<pre class="code">.\?.dll;C:\Program Files\Lua502\dll\?.dll</pre>

<p>Функция <code>package.searchpath</code> реализует все эти соглашения для поиска библиотек. Она получает имя модуля и путь и ищет файл, следуя описанным выше правилам. Она возвращает или имя первого найденного файла, или <b>nil</b> и сообщение об ошибке, описывающее все файлы, которые она попыталась открыть, как в следующем примере:</p>

<pre class="code">
path&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>".\\?.dll;C:\\Program&nbsp;Files\\Lua502\\dll\\?.dll"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>package<font color=FF0000>.</font>searchpath<font color=FF0000>(</font><font color=8888CC>"X"</font><font color=FF0000>,</font>&nbsp;path<font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;nil</font>
&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;no&nbsp;file&nbsp;'.\X.dll'</font>
&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;no&nbsp;file&nbsp;'C:\Program&nbsp;Files\Lua502\dll\X.dll'</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="15.1. Искатели файлов"></a>Искатели файлов
</div>

<p>В действительности <code>require</code> несколько сложнее, чем мы описали. Поиск файла на Lua и поиск С-библиотеки - это просто два частных случая более общего понятия <i>искателя файла</i> (<i>searcher</i>). Искатель файла - это просто функция, которая получает имя модуля и возвращает загрузчик для этого блока или <b>nil</b>, если она не может найти ни одного.</p>

<p>Массив <code>package.searchers</code> содержит список искателей файлов, которые использует <code>require</code>. При поиске модуля <code>require</code> вызывает каждый искатель по очереди, передавая ему имя модуля, до тех пор, пока не найдет загрузчик для модуля. Если поиск завершится впустую, то <code>require</code> вызывает ошибку.</p>

<p>Использование списка для управления поиском модуля придает большую гибкость функции <code>require</code>. Например, если вы хотите хранить модули сжатыми в <b>zip</b>-файлы, то все, что вам для этого нужно, - это предоставить соответствующую искатель-функцию и добавить ее к списку. Однако чаще всего программам все же не нужно изменять значение <code>package.searchers</code>. В конфигурации по умолчанию искатель функций на Lua и искатель библиотек на С, которые мы описали выше, занимают вторую и третью позиции. Перед ними стоит искатель уже загруженных модулей (<i>preload searcher</i>).</p>

<p>Этот искатель позволяет ввести произвольную функцию для загрузки модуля. Он использует таблицу <code>package.preload</code> для сопоставления именам модулей загрузочных функций. При поиске этот искатель просто ищет заданное имя в таблице. Если он находит функцию, то он возвращает ее как загрузчик модуля. Иначе он возвращает <b>nil</b>. Этот искатель предоставляет способ обрабатывать некоторые нетипичные случаи. Например, библиотека на С, статически прилинко-ванная к Lua, может зарегистрировать свою функцию <code>luaopen_</code> так, что она будет вызвана, только когда (и если) пользователю понадобится этот модуль. Таким образом, программа не тратит времени на открытие модуля, если он не используется.</p>

<p>По умолчанию <code>package.searchers</code> включает в себя четвертую функцию, которая нужна для подмодулей. Мы рассмотрим их в <a href="#15.4. Подмодули и пакеты">разделе 15.4</a>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="15.2. Стандартный подход для написания модулей на Lua"></a>15.2. Стандартный подход для написания модулей на Lua
</div>

<p>Простейший способ создать модуль на Lua действительно прост: мы создаем таблицу, помещаем все функции, которые мы хотим экспортировать, внутрь нее и возвращаем эту таблицу. <a href="#листинг 15.1">Листинг 15.1</a> демонстрирует этот подход. Обратите внимание, как мы определяем функцию <code>inv</code> как закрытую, просто обьявляя ее внутри блока.</p>

<p>Некоторым не правится завершающий оператор <code>return</code>. Одним из способов устранить его является запись таблицы модуля непосредственно в <code>package.loaded</code>:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;M&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=FF8000>package.loaded</font><font color=FF0000>[...]</font>&nbsp;<font color=FF0000>=</font>&nbsp;M
&nbsp;&nbsp;<font color=FF0000>&lt;</font>as&nbsp;before<font color=FF0000>&gt;</font>
</pre>

<p>Имейте в виду, что <code>require</code> вызывает загрузчик, передавая имя модуля как первый аргумент. Поэтому выражение переменного числа аргументов <code>...</code> дает в результате именно это имя. После этого присваивания нам больше не нужно возвращать <code>M</code> в конце модуля: если модуль не возвращает значение, то <code>require</code> вернет текущее значение <code>package.loaded[modname]</code> (если оно не <b>nil</b>). Однако я предпочитаю возвращать таблицу, поскольку это выглядит аккуратнее.</p>

<p>Другим способом записи модуля является определение всех функций как локальных и построение таблицы в конце, как в <a href="#листинг 15.2">листинге 15.2</a>. В чем преимущества этого подхода? Вам не нужно начинать каждое имя с <code>M</code>. или чего-то похожего; существует явный список экспортируемых функций; вы определяете и используете экспортируемые и внутренние функции абсолютно одинаково внутри модуля. В чем заключаются недостатки этого подхода? Список экспортируемых функций находится в конце модуля, а не в его начале, где он был бы более удобен в качестве быстрой справки; и список для экспорта избыточен, так как нужно каждое имя записать дважды (Этот последний недостаток может стать преимуществом, поскольку он позволяет функциям иметь разные имена снаружи модуля и внутри него, но я думаю, что программисты редко этим пользуются.) Мне лично нравится данный стиль.</p>

<p>Однако помните, что вне зависимости от того, как определен модуль, пользователи должны иметь возможность использовать его стандартным образом:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;cpx&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>require</font>&nbsp;<font color=8888CC>"complex"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>cpx<font color=FF0000>.</font>tostring<font color=FF0000>(</font>cpx<font color=FF0000>.</font>add<font color=FF0000>(</font>cpx<font color=FF0000>.</font>new<font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>,</font><font color=AC00A9>4</font><font color=FF0000>),</font>&nbsp;cpx<font color=FF0000>.</font>i<font color=FF0000>)))</font>
<font color=008000>--&gt;&nbsp;(3,5)</font>
</pre>

<p><a name="листинг 15.1"></a><b class="sect">Листинг 15.1</b>. Простой модуль для комплексных чисел</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;M&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>

<font color=0000DF>function</font>&nbsp;M<font color=FF0000>.</font>new&nbsp;<font color=FF0000>(</font>r<font color=FF0000>,</font>&nbsp;i<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>{</font>r<font color=FF0000>=</font>r<font color=FF0000>,</font>&nbsp;i<font color=FF0000>=</font>i<font color=FF0000>}</font>&nbsp;<font color=0000DF>end</font>

<font color=008000>--&nbsp;определяем&nbsp;константу&nbsp;'i'</font>
M<font color=FF0000>.</font>i&nbsp;<font color=FF0000>=</font>&nbsp;M<font color=FF0000>.</font>new<font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>

<font color=0000DF>function</font>&nbsp;M<font color=FF0000>.</font>add&nbsp;<font color=FF0000>(</font>c1<font color=FF0000>,</font>&nbsp;c2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;M<font color=FF0000>.</font>new<font color=FF0000>(</font>c1<font color=FF0000>.</font>r&nbsp;<font color=FF0000>+</font>&nbsp;c2<font color=FF0000>.</font>r<font color=FF0000>,</font>&nbsp;c1<font color=FF0000>.</font>i&nbsp;<font color=FF0000>+</font>&nbsp;c2<font color=FF0000>.</font>i<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;M<font color=FF0000>.</font>sub&nbsp;<font color=FF0000>(</font>c1<font color=FF0000>,</font>&nbsp;c2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;M<font color=FF0000>.</font>new<font color=FF0000>(</font>c1<font color=FF0000>.</font>r&nbsp;<font color=FF0000>-</font>&nbsp;c2<font color=FF0000>.</font>r<font color=FF0000>,</font>&nbsp;c1<font color=FF0000>.</font>i&nbsp;<font color=FF0000>-</font>&nbsp;c2<font color=FF0000>.</font>i<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;M<font color=FF0000>.</font>mul&nbsp;<font color=FF0000>(</font>c1<font color=FF0000>,</font>&nbsp;c2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;M<font color=FF0000>.</font>new<font color=FF0000>(</font>c1<font color=FF0000>.</font>r<font color=FF0000>*</font>c2<font color=FF0000>.</font>r&nbsp;<font color=FF0000>-</font>&nbsp;c1<font color=FF0000>.</font>i<font color=FF0000>*</font>c2<font color=FF0000>.</font>i<font color=FF0000>,</font>&nbsp;c1<font color=FF0000>.</font>r<font color=FF0000>*</font>c2<font color=FF0000>.</font>i&nbsp;<font color=FF0000>+</font>&nbsp;c1<font color=FF0000>.</font>i<font color=FF0000>*</font>c2<font color=FF0000>.</font>r<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;inv&nbsp;<font color=FF0000>(</font>c<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;c<font color=FF0000>.</font>r<font color=FF0000>^</font><font color=AC00A9>2</font>&nbsp;<font color=FF0000>+</font>&nbsp;c<font color=FF0000>.</font>i<font color=FF0000>^</font><font color=AC00A9>2</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;M<font color=FF0000>.</font>new<font color=FF0000>(</font>c<font color=FF0000>.</font>r<font color=FF0000>/</font>n<font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font>c<font color=FF0000>.</font>i<font color=FF0000>/</font>n<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;M<font color=FF0000>.</font>div&nbsp;<font color=FF0000>(</font>c1<font color=FF0000>,</font>&nbsp;c2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;M<font color=FF0000>.</font>mul<font color=FF0000>(</font>c1<font color=FF0000>,</font>&nbsp;inv<font color=FF0000>(</font>c2<font color=FF0000>))</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;M<font color=FF0000>.</font>tostring&nbsp;<font color=FF0000>(</font>c<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8888CC>"("</font>&nbsp;<font color=FF0000>..</font>&nbsp;c<font color=FF0000>.</font>r&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>","</font>&nbsp;<font color=FF0000>..</font>&nbsp;c<font color=FF0000>.</font>i&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>")"</font>
<font color=0000DF>end</font>

<font color=0000DF>return</font>&nbsp;M
</pre>

<p><a name="листинг 15.2"></a><b class="sect">Листинг 15.2</b>. Модуль с явным списком экспортируемых функций</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;new&nbsp;<font color=FF0000>(</font>r<font color=FF0000>,</font>&nbsp;i<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>{</font>r<font color=FF0000>=</font>r<font color=FF0000>,</font>&nbsp;i<font color=FF0000>=</font>i<font color=FF0000>}</font>&nbsp;<font color=0000DF>end</font>

<font color=008000>--&nbsp;определяем&nbsp;константу&nbsp;'i'</font>
<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;complex<font color=FF0000>.</font>new<font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>

&nbsp;&nbsp;<font color=FF0000>&lt;</font>other&nbsp;functions&nbsp;follow&nbsp;the&nbsp;same&nbsp;pattern<font color=FF0000>&gt;</font>
&nbsp;&nbsp;
<font color=0000DF>return</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;new&nbsp;<font color=FF0000>=</font>&nbsp;new<font color=FF0000>,</font>
&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i<font color=FF0000>,</font>
&nbsp;&nbsp;add&nbsp;<font color=FF0000>=</font>&nbsp;add<font color=FF0000>,</font>
&nbsp;&nbsp;sub&nbsp;<font color=FF0000>=</font>&nbsp;sub<font color=FF0000>,</font>
&nbsp;&nbsp;mul&nbsp;<font color=FF0000>=</font>&nbsp;mul<font color=FF0000>,</font>
&nbsp;&nbsp;div&nbsp;<font color=FF0000>=</font>&nbsp;div<font color=FF0000>,</font>
&nbsp;&nbsp;<font color=0080C0>tostring</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>,</font>
<font color=FF0000>}</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="15.3. Использование окружений"></a>15.3. Использование окружений
</div>

<p>Одним из недостатков рассмотренных методов для создания модулей является то, что очень легко засорить глобальное пространство имен, например просто забыв <code>local</code> в описании локального ресурса.</p>

<p>Окружения предоставляют интересный подход к созданию модулей, который решает эту проблему. Если у модуля есть свое окружение, то не только все функции попадут в эту таблицу, но также и все глобальные переменные. Поэтому мы можем определить все открытые функции как глобальные, и они автоматически попадут в соответствующую таблицу. Все, что нужно сделать модулю, - так это присвоить эту таблицу переменной <code>_ENV</code>. После этого, когда мы определяем функцию <code>add</code>, она автоматически становится <code>М.add</code>:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;M&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;M
<font color=0000DF>function</font>&nbsp;add&nbsp;<font color=FF0000>(</font>c1<font color=FF0000>,</font>&nbsp;c2<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;new<font color=FF0000>(</font>c1<font color=FF0000>.</font>r&nbsp;<font color=FF0000>+</font>&nbsp;c2<font color=FF0000>.</font>r<font color=FF0000>,</font>&nbsp;c1<font color=FF0000>.</font>i&nbsp;<font color=FF0000>+</font>&nbsp;c2<font color=FF0000>.</font>i<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Более того, мы можем вызывать другие функции из этого модуля без какого-либо префикса. В предыдущем коде <code>add</code> обращается к <code>new</code> из своего окружения, то есть на самом деле обращается к <code>М.new</code>.</p>

<p>Этот метод является хорошим способом создания модулей, требуя очень небольшой работы от программиста. Префиксы вообще не нужны. Нет никакой разницы между вызовом экспортируемой и закрытой функций. Если программист забывает вставить <code>local</code>, то он не засоряет глобальное пространство имен; вместо этого закрытая функция просто становится экспортируемой.</p>

<p>Тем не менее обычно я предпочитаю один из двух ранее рассмотренных методов. Хотя они могут потребовать чуть больше работы, тем не менее код получается более понятным. Для того чтобы не создать глобальную величину по ошибке, я просто присваиваю <code>_ENV</code> значение <b>nil</b>. После этого любая попытка создать глобальную величину просто вызывает ошибку.</p>

<p>Чего при этом не хватает, так это доступа к другим модулям. После того как мы изменили значение <code>_ENV</code>, мы потеряли доступ ко всем предыдущим глобальным переменным. Есть несколько способов вернуть этот доступ, каждый со своими плюсами и минусами.</p>

<p>Одним вариантом является использование наследования:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;M&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>M<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>})</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;M
</pre>

<p>(Вам нужно вызвать <code>setmetatable</code> перед присваиванием <code>_ENV</code>, понятно почему?) При использовании этого подхода модуль получает прямой доступ к любой глобальной переменной, при очень небольшой цене такого доступа. Любопытным последствием этого решения является то, что ваш модуль теперь содержит все глобальные переменные. Например, кто-то, использующий ваш модуль, теперь может вызывать стандартную функцию для вычисления синуса при помощи <code>complex.math.sin(x)</code> (Подобная особенность есть также и в языке Perl.)</p>

<p>Другим быстрым способом доступа к другим модулям является введение локальной переменной, содержащей глобальное окружение:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;M&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>local</font>&nbsp;<font color=0080C0>_G</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>_G</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;M&nbsp;<font color=008000>--&nbsp;or&nbsp;_ENV&nbsp;=&nbsp;nil</font>
</pre>

<p>Теперь вы должны начинать каждое глобальное имя с <code>_G.</code>, но доступ происходит немного быстрее, поскольку нет использования метаметодов.</p>

<p>Более строгим подходом является определение в качестве локальных переменных только тех функций или модулей, которые вам нужны:</p>

<pre class="code">
<font color=008000>--&nbsp;настройка&nbsp;модуля</font>
<font color=0000DF>local</font>&nbsp;M&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>

<font color=008000>--&nbsp;раздел&nbsp;импорта:</font>
<font color=008000>--&nbsp;возьмите&nbsp;снаружи&nbsp;все,&nbsp;что&nbsp;нужно&nbsp;этому&nbsp;модулю</font>
<font color=0000DF>local</font>&nbsp;sqrt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.sqrt</font>
<font color=0000DF>local</font>&nbsp;<font color=FF8000>io</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io</font>

<font color=008000>--&nbsp;с&nbsp;этого&nbsp;места&nbsp;доступ&nbsp;наружу&nbsp;невозможен</font>
<font color=0080C0>_ENV</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=008000>--&nbsp;or&nbsp;_ENV&nbsp;=&nbsp;M</font>
</pre>

<p>Этот подход требует больше работы, но он явно документирует зависимости вашего модуля. Также он приводит к коду, который выполняется немного быстрее, чем в ранее рассмотренных случаях, из-за использования локальных переменных.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="15.4. Подмодули и пакеты"></a>15.4. Подмодули и пакеты
</div>

<p>Lua допускает использование иерархических имен модулей, используя точку для разделения уровней. Например, модуль с именем <code>mod.sub</code> является <i>подмодулем</i> модуля <code>mod</code>. <i>Пакет</i> - это полное дерево модулей; он является единицей распространения кода в Lua.</p>

<p>Когда вам нужен модуль с именем <code>mod.sub</code>, то <code>require</code> сперва ищет в таблице <code>package.loaded</code> и затем в таблице <code>package.preload</code>, используя полное имя <code>"mod. sub"</code> в качестве ключа; в этом случае точка является таким же символом, как и любой другой.</p>

<p>Однако при поиске файла, задающего этот подмодуль, <code>require</code> переводит точку в другой символ, обычно системный разделитель в пути (то есть '<code>/</code>' для <i>UNIX</i> и для <i>Windows</i>). После этого преобразования <code>require</code> ищет получающемся имя, как и любое другое имя. Например, путь <code>'/'</code> - это разделитель пути, и у нас есть следующий путь:</p>

<pre class="code">./?.lua;/usr/local/lua/?.lua;/usr/local/lua/?/init.lua</pre>

<p>Вызов <code>require("a.b")</code> попробует открыть следующие файлы:</p>

<pre class="code">
./a/b.lua
/usr/local/lua/a/b.lua
/usr/local/lua/a/b/init.lua
</pre>

<p>Это поведение позволяет всем модулям пакета находиться в отдельном каталоге. Например, если в пакете содержатся модули <code>р</code>, <code>р.а</code> и <code>р.b</code>, то соответствующими файлами могут быть <code>p/init.lua</code>, <code>р/а.lua</code> и <code>p/b.lua</code>, где каталог <code>р</code> содержится в соответствующем месте.</p>

<p>Разделитель пути, используемый Lua, задается во время компиляции и может быть любой строкой (вспомните, что Lua ничего не знает про каталоги). Например, системы без иерархических каталогов могут использовать <code>'_'</code> в качестве такого разделителя, так что <code>require("а.b")</code> будет искать файл <code>a_b.lua</code>.</p>

<p>Имена в С не могут содержать точки, поэтому библиотека на С для подмодуля <code>а.b</code> не может экспортировать функцию <code>luaopen_a.b</code>. В этом случае <code>require</code> переводит точку в другой символ - подчеркивание. Таким образом, библиотека на С с именем <code>а.b</code> должна назвать свою инициализирующую функцию <code>iuaopen_a_b</code>. Мы также можем использовать здесь прием с минусом, но с более сложным результатом. Например, пусть у нас есть библиотека на С с именем <code>а</code> и мы хотим сделать ее подмодулем <code>mod</code>, тогда мы можем переименовать соответствующий файл в <code>mod/v-a</code>. При вызове <code>require "mod.v-a"</code> вызов <code>require</code> правильно найдет новый файл <code>mod/v-a</code>, так же как и функцию <code>luaopen_a</code> внутри него.</p>

<p>Также у <code>require</code> есть один дополнительный искатель для загрузки подмодулей на С. Когда он не может найти ни Lua-файл, ни С-файл для подмодуля, этот искатель опять ищет в пути для С, но на этот раз ищет имя пакета. Например, если программа хочет загрузить подмодуль <code>а.b.с</code>, то этот искатель просто будет искать <code>а</code>. Если он найдет библиотеку на С для этого имени, то <code>require</code> будет искать в этой библиотеке соответствующую функцию, в нашем случае <code>luaopen_a_b_c</code>. Эта возможность позволяет размещать несколько подмодулей вместе в одной библиотеке на С, каждая со своей инициализирующей функцией.</p>

<p>С точки зрения Lua, подмодули в одном пакете не имеют явной связи. Загрузка модуля <code>а</code> не приводит к загрузке любого из ее подмодулей; также загрузка <code>а.b</code> не загружает автоматически <code>а</code>. Конечно, при реализации пакета разработчик вправе задать эти связи при желании. Например, модуль <code>а</code> может явно потребовать загрузки как кого-то конкретного(или всех) своего подмодуля.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="15. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 15.1.</b><br>
Перепишите код в <a href="#листинг 13.1">листинге 13.1</a> как отдельный модуль.</p>

<hr color="#99CCFF">

<p><b>Упражнение 15.2.</b><br>
Что случится при поиске библиотеки, если путь содержит фиксированную компоненту (то есть компоненту, не содержащую знака вопроса)? Может ли такое поведение быть полезным?</p>

<hr color="#99CCFF">

<p><b>Упражнение 15.3.</b><br>
Напишите искатель, который одновременно ищет файлы на Lua и библиотеки на С. Например, путь для этого искателя может быть чем-то вроде:</p>

<pre class="code">./?.lua;./?.so;/usr/lib/lua5.2/?.so;/usr/share/lua5.2/?.lua</pre>

(<i>Подсказка</i>: используйте <code>package.searchpath</code> для поиска соответствующего файла, затем попытайтесь загрузить его, сначала при помощи <code>loadfile</code>, затем при помощи <code>package.loadlib</code>.)

<hr color="#99CCFF">

<p><b>Упражнение 15.4.</b><br>
Что случится, если вы установите метатаблицу для <code>package.preload</code> при помощи метаметода <code>__index</code>? Может ли это быть полезным?</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 16. Обьектно-ориентированное программирование"></a>Глава 16. Обьектно-ориентированное программирование
</div>

<p>Таблица в Lua является обьектом более чем в одном смысле. Подобно обьектам, у таблицы есть состояние. Подобно обьектам, у таблицы есть идентичность (<code>self</code>), которая не зависит от ее значений; в частности, две таблицы с одинаковыми значениями являются разными обьектами, обьект может иметь разные значения в разные моменты времени. Подобно обьектам, у таблиц есть жизненный цикл, который не зависит от того, кто их создал или где они были созданы.</p>

<p>У обьектов есть свои методы. У таблиц также могут быть свои методы, как показано ниже:</p>

<pre class="code">
Account&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>}</font>
<font color=0000DF>function</font>&nbsp;Account<font color=FF0000>.</font>withdraw&nbsp;<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;Account<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;Account<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>-</font>&nbsp;v
<font color=0000DF>end</font>
</pre>

<p>Это определение создает новую функцию и запоминает ее в поле <code>withdraw</code> обьекта <code>Account</code>. Затем мы можем вызвать ее, как показано ниже:</p>

<pre class="code">Account<font color=FF0000>.</font>withdraw<font color=FF0000>(</font><font color=AC00A9>100.00</font><font color=FF0000>)</font></pre>

<p>Функция подобного типа - это почти то, что мы называем методом. Однако использование глобального имени <code>Account</code> внутри функции является плохой практикой. Во-первых, эта функция будет работать только для данного конкретного обьекта. Во-вторых, даже для этого обьекта ровно до тех пор, пока этот обьект записан в этой конкретной глобальной переменной. Если мы изменим имя обьекта, то <code>withdraw</code> больше не будет работать:</p>

<pre class="code">
a<font color=FF0000>,</font>&nbsp;Account&nbsp;<font color=FF0000>=</font>&nbsp;Account<font color=FF0000>,</font>&nbsp;<font color=0000DF>nil</font>
a<font color=FF0000>.</font>withdraw<font color=FF0000>(</font><font color=AC00A9>100.00</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;ОШИБКА!</font>
</pre>

<p>Подобное поведение нарушает принцип, что у каждого обьекта должен быть свой, независимый цикл жизни.</p>

<p>Более гибким вариантом является использование <i>получателя</i> операции. Для этого нашему методу понадобится дополнительный аргумент со значением получателя. Этот параметр обычно имеет имя <code>self</code> или <code>this</code>.</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;Account<font color=FF0000>.</font>withdraw&nbsp;<font color=FF0000>(</font>self<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>-</font>&nbsp;v
<font color=0000DF>end</font>
</pre>

<p>Теперь, когда мы вызываем метод, мы должны указать, с каким обьектом он должен работать:</p>

<pre class="code">
a1&nbsp;<font color=FF0000>=</font>&nbsp;Account<font color=FF0000>;</font>&nbsp;Account&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=FF0000>...</font>
a1<font color=FF0000>.</font>withdraw<font color=FF0000>(</font>a1<font color=FF0000>,</font>&nbsp;<font color=AC00A9>100.00</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;OK</font>
</pre>

<p>При использовании параметра <code>self</code> мы можем использовать один и тот же метод для многих обьектов:</p>

<pre class="code">
a2&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>balance<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;withdraw&nbsp;<font color=FF0000>=</font>&nbsp;Account<font color=FF0000>.</font>withdraw<font color=FF0000>}</font>
<font color=FF0000>...</font>
a2<font color=FF0000>.</font>withdraw<font color=FF0000>(</font>a2<font color=FF0000>,</font>&nbsp;<font color=AC00A9>260.00</font><font color=FF0000>)</font>
</pre>

<p>Это использование параметра <code>self</code> является ключевым в любом обьектно-ориентированном языке. В большинстве обьектно-ориентированных языков данный механизм частично скрыт от программиста, поэтому этот параметр не нужно явно обьявлять (хотя внутри метод по-прежнему можно использовать - <code>self</code> или <code>this</code>). Lua также может скрывать этот параметр при помощи <i>оператора двоеточие</i>. Мы можем переписать предыдущее определение метода следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;Account<font color=FF0000>:</font>withdraw&nbsp;<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>-</font>&nbsp;v
<font color=0000DF>end</font>
</pre>

<p>Тогда вызов метода будет выглядеть следующим образом:</p>

<pre class="code">a<font color=FF0000>:</font>withdraw<font color=FF0000>(</font><font color=AC00A9>100.00</font><font color=FF0000>)</font></pre>

<p>Двоеточие добавляет дополнительный скрытый параметр в определение метода и добавляет дополнительный аргумент в вызов метода. Двоеточие является всего лишь синтаксическим сахаром, хотя и довольно удобным; ничего принципиально нового здесь нет. Мы можем определить метод при использовании синтаксиса с точкой и вызвать его, используя синтаксис с двоеточием, и наоборот, до тех пор, пока мы правильно обрабатываем дополнительный параметр:</p>

<pre class="code">
Account&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>&nbsp;balance<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;withdraw&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>self<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>-</font>&nbsp;v
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>}</font>

<font color=0000DF>function</font>&nbsp;Account<font color=FF0000>:</font>deposit&nbsp;<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>+</font>&nbsp;v
<font color=0000DF>end</font>

Account<font color=FF0000>.</font>deposit<font color=FF0000>(</font>Account<font color=FF0000>,</font>&nbsp;<font color=AC00A9>200.00</font><font color=FF0000>)</font>
Account<font color=FF0000>:</font>withdraw<font color=FF0000>(</font><font color=AC00A9>100.00</font><font color=FF0000>)</font>
</pre>

<p>К данному моменту у наших обьектов есть идентичность, состояние и операции над этим состоянием. Им не хватает системы классов, наследования и возможности скрыть свои переменные (состояние). Давайте сначала разберемся с первой задачей: как мы можем создать различные обьекты с одинаковым поведением? Например, как мы можем создать несколько счетов?</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="16.1. Классы"></a>16.1. Классы
</div>

<p>Класс, выступает как шаблон для создания обьектов. Большинство обьектно-ориентированных языков предлагают понятие класса. В таких языках каждый обьект является экземпляром какого-то конкретного класса. В Lua нет понятия класса; каждый обьект определяет свое поведение и свои данные. Однако это совсем не сложно -эмулировать классы в Lua, идя по пути прототипных языков вроде <i>Self</i> или <i>NewtonScript</i>. В этих языках у обьектов нет классов. Вместо этого каждый обьект может иметь прототип, который является обьектом, в котором первый обьект ищет операции, которые он не знает. Для представления классов в таких языках мы просто создаем обьект, который будет использован только в качестве прототипа для других обьектов (его экземпляров). И классы, и прототипы выступают в качестве места, в которое помещается поведение, общее для различных обьектов.</p>

<p>В Lua мы можем реализовать прототипы, используя идею наследования из <a href="#13.4. Метаметод __index">раздела 13.4</a>. Точнее, если у нас есть два обьекта <code>а</code> и <code>b</code>, то все, что нам нужно сделать, чтобы <code>b</code> выступил как прототип для <code>а</code>, - это следующее:</p>

<pre class="code"><font color=0080C0>setmetatable</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;b<font color=FF0000>})</font></pre>

<p>После этого <code>а</code> будет искать в <code>b</code> все операции, которых он не знает. Установить <code>b</code> в качестве класса для <code>а</code> - это на самом деле практически то же самое.</p>

<p>Давайте вернемся к нашему примеру с банковским счетом. Для создания других счетов с поведением, аналогичным <code>Account</code>, мы сделаем так, что эти новые обьекты унаследуют свои операции от <code>Account</code> при помощи метаметода <code>__index</code>. В качестве небольшой оптимизации мы можем не создавать отдельные метатаблицы для каждого из обьектов; вместо этого мы будем использовать саму таблицу <code>Account</code>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;Account<font color=FF0000>:</font>new&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;o&nbsp;<font color=FF0000>=</font>&nbsp;o&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;создать&nbsp;таблицу,&nbsp;если&nbsp;пользователь&nbsp;не&nbsp;передал&nbsp;ее</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>o<font color=FF0000>,</font>&nbsp;self<font color=FF0000>)</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;self
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;o
<font color=0000DF>end</font>
</pre>

<p>(Когда мы вызываем <code>Account:new</code>, то <code>self</code> равно <code>Account</code>; поэтому мы могли бы явно использовать <code>Account</code> вместо <code>self</code>. Однако использование <code>self</code> очень нам при пригодится в следующем разделе, когда мы введем наследование.) Что произойдет, когда мы создадим новый счет и вызовем его метод, как показано ниже?</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;Account<font color=FF0000>:</font>new<font color=FF0000>{</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>}</font>
a<font color=FF0000>:</font>deposit<font color=FF0000>(</font><font color=AC00A9>100.00</font><font color=FF0000>)</font>
</pre>

<p>Когда мы создаем новый счет, у а будет выставлена <code>Account</code> (параметр <code>self</code> при вызове <code>Account:new</code>) в качестве метатаблицы. Затем, когда мы вызываем <code>а:deposit(100.00)</code>, мы на самом деле вызываем <code>a.deposit(а, 100.00)</code>; двоеточие - это просто синтаксический сахар. Однако Lua не может найти запись <code>deposit</code> в таблице <code>а</code>; поэтому Lua ищет запись <code>__index</code> в метатаблице. Ситуация выглядит примерно следующим образом:</p>

<pre class="code"><font color=0080C0>getmetatable</font><font color=FF0000>(</font>a<font color=FF0000>).</font>__index<font color=FF0000>.</font>deposit<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;<font color=AC00A9>100.00</font><font color=FF0000>)</font></pre>

<p>Метатаблицей <code>а</code> является <code>Account</code> и <code>Account.__index</code> - это также <code>Account</code> (поскольку метод <code>new</code> выполнил <code>self.__index=self</code>). Поэтому предыдущее выражение сводится к</p>

<pre class="code">Account<font color=FF0000>.</font>deposit<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;<font color=AC00A9>100.00</font><font color=FF0000>)</font></pre>

<p>То есть Lua вызывает исходную функцию <code>deposit</code>, но передавая <code>а</code> в качестве параметра <code>self</code>. Таким образом, новый счет <code>а</code> унаследовал функцию <code>deposit</code> от <code>Account</code>. Таким же образом он наследует все поля от <code>Account</code>.</p>

<p>Наследование работает не только для методов, но также и для других полей, которых нет в новом счете. Поэтому класс может предоставлять не только методы, но и значения по умолчанию для полей экземпляра. Напомним, что в нашем первом определении <code>Account</code> мы предоставили поле <code>balance</code> со значением <code>0</code>. Поэтому если мы создадим счет без начального значения баланса, то он унаследует это значение по умолчанию:</p>

<pre class="code">
b&nbsp;<font color=FF0000>=</font>&nbsp;Account<font color=FF0000>:</font>new<font color=FF0000>()</font>
<font color=0080C0>print</font><font color=FF0000>(</font>b<font color=FF0000>.</font>balance<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;0</font>
</pre>

<p>Когда мы вызовем у <code>b</code> метод <code>deposit</code>, то этот вызов будет эквивалентен следующему коду (поскольку <code>self</code> равно <code>b</code>):</p>

<pre class="code">b<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;b<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>+</font>&nbsp;v</pre>

<p>Выражение <code>b.balance</code> дает <code>0</code>, и метод присваивает начальный вклад <code>b.balance</code>. Последующие обращения к <code>b.balance</code> уже не приведут к вызову соответствующего метаметода, так как у <code>b</code> теперь есть свое поле <code>balance</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="16.2. Наследование"></a>16.2. Наследование
</div>

<p>Поскольку классы являются обьектами, они также могут получать методы от других классов. Это поведение позволяет легко реализовать наследование (в обычном обьектно-ориентированном смысле).</p>

<p>Пусть у нас есть базовый класс <code>Account</code>:</p>

<pre class="code">
Account&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>}</font>

<font color=0000DF>function</font>&nbsp;Account<font color=FF0000>:</font>new&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;o&nbsp;<font color=FF0000>=</font>&nbsp;o&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>o<font color=FF0000>,</font>&nbsp;self<font color=FF0000>)</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;self
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;o
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;Account<font color=FF0000>:</font>deposit&nbsp;<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>+</font>&nbsp;v
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;Account<font color=FF0000>:</font>withdraw&nbsp;<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;v&nbsp;<font color=FF0000>&gt;</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0080C0>error</font><font color=8888CC>"insufficient&nbsp;funds"</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>-</font>&nbsp;v
<font color=0000DF>end</font>
</pre>

<p>От этого класса мы можем унаследовать класс <code>SpecialAccount</code>, позволяющий покупателю снять больше, чем есть на его балансе. Мы начинаем с пустого класса, который наследует все операции от своего базового класса:</p>

<pre class="code">SpecialAccount&nbsp;<font color=FF0000>=</font>&nbsp;Account<font color=FF0000>:</font>new<font color=FF0000>()</font></pre>

<p>До этого момента <code>SpecialAccount</code> является просто экземпляром <code>Account</code>. Однако интересное случается дальше:</p>

<pre class="code">s&nbsp;<font color=FF0000>=</font>&nbsp;SpecialAccount<font color=FF0000>:</font>new<font color=FF0000>{</font>limit<font color=FF0000>=</font><font color=AC00A9>1000.00</font><font color=FF0000>}</font></pre>

<p><code>SpecialAccount</code> наследует <code>new</code> от <code>Account</code>, как и все остальные методы. Однако на этот раз при выполнении <code>new</code> его параметр <code>self</code> уже будет ссылаться на <code>SpecialAccount</code>. Поэтому метатаблицей <code>s</code> будет <code>SpecialAccount</code>, чье значение в поле <code>__index</code> равно <code>SpecialAccount</code>. Поэтому <code>s</code> наследует от <code>SpecialAccount</code>, который, в свою очередь, наследует от <code>Account</code>. Теперь если мы выполним</p>

<pre class="code">s<font color=FF0000>:</font>deposit<font color=FF0000>(</font><font color=AC00A9>100.00</font><font color=FF0000>)</font></pre>

<p>То Lua не сможет найти поле <code>deposit</code> в <code>s</code>, поэтому он будет искать его в <code>SpecialAccount</code>, там его он также не найдет и будет далее искать в <code>Account</code>, где он и найдет исходную реализацию этого метода.</p>

<p>Что делает <code>SpecialAccount</code> особенным, это то, что мы можем переопределить любой метод, унаследованный от его родительского класса. Все, что нам нужно, - это просто записать новый метод:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;SpecialAccount<font color=FF0000>:</font>withdraw&nbsp;<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;v&nbsp;<font color=FF0000>-</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>>=</font>&nbsp;self<font color=FF0000>:</font>getLimit<font color=FF0000>()</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>error</font><font color=8888CC>"insufficient&nbsp;funds"</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>-</font>&nbsp;v
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;SpecialAccount<font color=FF0000>:</font>getLimit&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;self<font color=FF0000>.</font>limit&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>end</font>
</pre>

<p>Теперь, когда мы вызовем <code>s:withdraw(200.00)</code>, то Lua не обратится в <code>Account</code>, поскольку она до этого найдет новый метод <code>withdraw</code> в классе <code>SpecialAccount</code>. Так как <code>s.limit</code> равно <code>1000.00</code> (мы задали это поле при создании <code>s</code>), то программа осуществит снятие, оставляя в результате <code>s</code> с отрицательным балансом.</p>

<p>Интересной особенностью обьектов в Lua является то, что вам не нужно создавать новый класс для задания нового поведения. Если изменить поведение нужно всего для одного обьекта, то мы можем реализовать это изменение непосредственно в этом обьекте. Например, если счет <code>s</code> представляет особого клиента, чей предел всегда равен 10% от текущего баланса, то мы можем изменить всего лишь один счет:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;s<font color=FF0000>:</font>getLimit&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>*</font>&nbsp;<font color=AC00A9>0.10</font>
<font color=0000DF>end</font>
</pre>

<p>После этого вызов <code>s:withdraw(200.0)</code> выполнит метод <code>withdraw</code> из класса <code>SpecialAccount</code>, но когда <code>withdraw</code> вызовет <code>s:getLimit</code>, то будет вызвано ранее введенное определение этой функции.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="16.3. Множественное наследование"></a>16.3. Множественное наследование
</div>

<p>Поскольку обьекты не являются базовыми примитивами, в Lua есть несколько способов использовать обьектно-ориентированное программирование. Подход, который мы только что видели, использующий метаметод <code>__index</code>, является, наверное, лучшей комбинацией простоты, скорости и гибкости. Однако есть и другие реализации, которые могут оказаться более подходящими для каких-то определенных случаев. Сейчас мы увидим альтернативную реализацию, которая допускает множественное наследование в Lua.</p>

<p>Ключевым в этой реализации является использование функции в качестве метаполя <code>__index</code>. Напомним, что когда у метатаблицы данной таблицы есть поле <code>__index</code>, то Lua вызовет эту функцию всякий раз, когда не сможет найти ключ в исходной таблице. В этом случае  <code>__index</code> может искать отсутствующий ключ в любом количестве родителей.</p>

<p>Множественное наследование означает, что у класса может быть более одного <i>суперкласса</i> (родительского класса). Поэтому мы,уже пе можем использовать такую функцию, как ранее, для создания дочерних классов. Вместо этого мы определим функцию <code>createClass</code>, которая получает в качестве аргументов родительские классы (см. <a href="#листинг 16.1">листинг 16.1</a>). Эта функция создает таблицу для представления нового класса и устанавливает его метатаблицу с метаметодом  <code>__index</code>, который и реализует множественное наследование. Несмотря на множественное наследование, каждый созданный обьект принадлежит одному классу, который и используется для поиска методов. Поэтому взаимоотношение между классом и суперклассами отличается от взаимоотношения между классами и его экземплярами (созданными обьектами). В частности, класс не может одновременно быть метатаблицей для его экземпляров и дочерних классов. В <a href="#листинг 16.1">листинге 16.1</a> мы используем класс как метатаблицу для созданных экземпляров и создаем отдельную таблицу в качестве метатаблицы класса.</p>


<p><a name="листинг 16.1"></a><b class="sect">Листинг 16.1</b>. Реализация множественного наследования</p>

<pre class="code">
<font color=008000>--&nbsp;ищем&nbsp;'k'&nbsp;в&nbsp;списке&nbsp;таблиц&nbsp;'plist'</font>
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;search&nbsp;<font color=FF0000>(</font>k<font color=FF0000>,</font>&nbsp;plist<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>plist&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;v&nbsp;<font color=FF0000>=</font>&nbsp;plist<font color=FF0000>[</font>i<font color=FF0000>][</font>k<font color=FF0000>]</font>&nbsp;<font color=008000>--&nbsp;попробовать&nbsp;i-й&nbsp;суперклас</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;v&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;v&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;createClass&nbsp;<font color=FF0000>(...)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;<font color=008000>--&nbsp;новый&nbsp;класс</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;parents&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{...}</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=008000>--&nbsp;класс&nbsp;будет&nbsp;искать&nbsp;каждый&nbsp;метод&nbsp;в&nbsp;списке&nbsp;своих&nbsp;родителей</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>c<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;search<font color=FF0000>(</font>k<font color=FF0000>,</font>&nbsp;parents<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>})</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=008000>--&nbsp;подготовить&nbsp;'c'&nbsp;в&nbsp;качестве&nbsp;метатаблицы&nbsp;его&nbsp;экземпляров</font>
&nbsp;&nbsp;c<font color=FF0000>.</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;c
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=008000>--&nbsp;определить&nbsp;новый&nbsp;конструктор&nbsp;для&nbsp;этого&nbsp;нового&nbsp;класса</font>
&nbsp;&nbsp;<font color=0000DF>function</font>&nbsp;c<font color=FF0000>:</font>new&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;<font color=FF0000>=</font>&nbsp;o&nbsp;<font color=0000DF>or</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>o<font color=FF0000>,</font>&nbsp;c<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;o
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;c&nbsp;<font color=008000>--&nbsp;вернуть&nbsp;новый&nbsp;класс</font>
<font color=0000DF>end</font>
</pre>

<p>Давайте проиллюстрируем использование <code>createClass</code> при помощи небольшого примера. Пусть у нас есть наш старый класс <code>Account</code> и класс <code>Named</code> с методами <code>setname</code> и <code>getname</code>.</p>

<pre class="code">
Named&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>

<font color=0000DF>function</font>&nbsp;Named<font color=FF0000>:</font>getname&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;self<font color=FF0000>.</font>name
<font color=0000DF>end</font>

<font color=0000DF>function</font>&nbsp;Named<font color=FF0000>:</font>setname&nbsp;<font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;self<font color=FF0000>.</font>name&nbsp;<font color=FF0000>=</font>&nbsp;n
<font color=0000DF>end</font>
</pre>

<p>Для создания нового класса <code>NamedAccount</code>, который является дочерним классом и <code>Account</code>, и <code>Named</code>, мы просто вызовем <code>createClass</code>:</p>

<pre class="code">
NamedAccount&nbsp;<font color=FF0000>=</font>&nbsp;createClass<font color=FF0000>(</font>Account<font color=FF0000>,</font>&nbsp;Named<font color=FF0000>)</font>
</pre>

<p>Мы создаем и используем экземпляры этого класса, как и ранее:</p>

<pre class="code">
account&nbsp;<font color=FF0000>=</font>&nbsp;NamedAccount<font color=FF0000>:</font>new<font color=FF0000>{</font>name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Paul"</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>account<font color=FF0000>:</font>getname<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;Paul</font>
</pre>

<p>Теперь давайте посмотрим, как работает последний оператор. Lua не может найти метод <code>getname</code> в <code>account</code>; поэтому он ищет поле <code>__index</code> в метатаблице <code>account</code>, то есть в <code>NamedAccount</code>. Но в <code>NamedAccount</code> также нет поля "<code>getname</code>", поэтому Lua ищет поле <code>__index</code> в метатаблице <code>NamedAccount</code>. Поскольку это поле содержит функцию, то Lua вызывает ее. Эта функция сперва ищет "<code>getname</code>" в <code>Account</code> и, не найдя его там ищет в <code>Named</code>, где она и находит отличное от <b>nil</b> значение, которое и становится окончательным результатом.</p>

<p>Конечно, из-за сложности такого поиска быстродействие для множественного наследования отличается от быстродействия для простого наследования. Простым способом улучшить это быстродействие является скопировать наследованные методы в дочерние классы. С использованием этого подхода метаметод <code>__index</code> будет выглядеть следующим образом:</p>

<pre class="code">
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>c<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;k<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;v&nbsp;<font color=FF0000>=</font>&nbsp;search<font color=FF0000>(</font>k<font color=FF0000>,</font>&nbsp;parents<font color=FF0000>)</font>
&nbsp;&nbsp;t<font color=FF0000>[</font>k<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;v&nbsp;<font color=008000>--&nbsp;сохранить&nbsp;для&nbsp;следующего&nbsp;обращения</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;v
<font color=0000DF>end</font><font color=FF0000>})</font>
</pre>

<p>При помощи данного приема доступ к унаследованным методам становится столь же быстрым, как и доступ к локальным методам (за исключением первого обращения). Недостатком является то, что сложно изменить определения методов, когда система работает, поскольку эти изменения не переносятся вдоль цепочки наследования.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="16.4. Скрытие"></a>16.4. Скрытие
</div>

<p>Многие считают возможность скрытия неотьемлемой частью обьектно-ориентированного языка. Состояние каждого обьекта является его личным делом. В некоторых обьектно-ориентированиых языках, таких как <i>С++</i> и <i>Java</i>, вы можете управлять тем, будет ли поле обьекта или его метод видны снаружи. В языке <i>Smalltalk</i> все переменные скрыты, а все методы доступны снаружи. <i>Simula</i>, первый обьектно-ориентированный язык, не предоставляет подобной защиты для полей и методов.</p>

<p>Дизайн обьектов для Lua, который мы ранее рассматривали, не предоставляет механизмов скрытия. Частично это является следствием нашего использования таблиц для представления обьектов. Кроме того, Lua избегает избыточности и искусственных ограничений. Если вы не хотите обращаться к полям внутри обьекта, просто <i>не делайте этого</i>.</p>

<p>Тем не менее другой целью Lua является гибкость, она предоставляет метамеханизмы, позволяющие эмулировать многие возможности. Хотя базовый дизайн обьектов для Lua и не предусматривает механизмов скрытия, мы можем реализовать обьекты другим способом, так чтобы получить контроль за доступом. Хотя эту возможность программисты используют нечасто, будет полезным узнать о ней, поскольку это приоткрывает некоторые интересные аспекты Lua и может быть хорошим решением и для других задач.</p>

<p>Основная идея альтернативного дизайна - это представлять каждый обьект при помощи двух таблиц: одна - для его состояния и другая - для его операций (его интерфейс). Обращение к обьекту идет через вторую таблицу, то есть через операции, образующие его интерфейс. Для того чтобы избежать несанкционированного доступа, таблица, предоставляющая его состояние, не хранится в поле другой таблицы, она доступна только через замыкания внутри методов. Например, чтобы представлять банковский счет при помощи этого дизайна, мы будем создавать новые обьекты при помощи следующей функции-фабрики:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;newAccount&nbsp;<font color=FF0000>(</font>initialBalance<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;self&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;initialBalance<font color=FF0000>}</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;withdraw&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>-</font>&nbsp;v
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;deposit&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>=</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>+</font>&nbsp;v
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;getBalance&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>return</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;&nbsp;&nbsp;withdraw&nbsp;<font color=FF0000>=</font>&nbsp;withdraw<font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;deposit&nbsp;<font color=FF0000>=</font>&nbsp;deposit<font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;getBalance&nbsp;<font color=FF0000>=</font>&nbsp;getBalance
&nbsp;&nbsp;<font color=FF0000>}</font>
<font color=0000DF>end</font>
</pre>

<p>Сначала функция создает таблицу для хранения внутреннего состояния обьекта и запоминает ее в локальной переменной <code>self</code>. Затем функция создает методы для обьекта. Наконец, функция создает и возвращает внешний обьект, который сопоставляет имена методов их реализациям. Ключевым здесь является то, что эти методы не получают <code>self</code> как дополнительный параметр. Вместо этого они непосредственно обращаются к <code>self</code>. Поскольку дополнительного аргумента нет, то мы не используем синтаксис с двоеточием для работы с обьектом. Мы вызываем их методы просто как обычные функции:</p>

<pre class="code">
acc1&nbsp;<font color=FF0000>=</font>&nbsp;newAccount<font color=FF0000>(</font><font color=AC00A9>100.00</font><font color=FF0000>)</font>
acc1<font color=FF0000>.</font>withdraw<font color=FF0000>(</font><font color=AC00A9>40.00</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>acc1<font color=FF0000>.</font>getBalance<font color=FF0000>())</font>&nbsp;<font color=008000>--&gt;&nbsp;60</font>
</pre>

<p>Этот дизайн обеспечивает полную скрытость для всего, что хранится в таблице <code>self</code>. После возвращения из функции <code>newAccount</code> нет никакого способа получить непосредственный доступ к этой таблице. Хотя наш пример хранит всего одну переменную в закрытой таблице, мы можем хранить все закрытые части обьекта в этой таблице. Мы можем также определить закрытые методы: они похожи на открытые, по мы не помещаем их в интерфейс. Например, наши счета могут предоставлять дополнительный 10%-пый кредит при балансе выше определенной величины, но мы не хотим, чтобы пользователи имели доступ к деталям вычислений. Мы можем реализовать эту функциональность следующим образом:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;newAccount&nbsp;<font color=FF0000>(</font>initialBalance<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;self&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;&nbsp;&nbsp;balance&nbsp;<font color=FF0000>=</font>&nbsp;initialBalance<font color=FF0000>,</font>
&nbsp;&nbsp;&nbsp;&nbsp;LIM&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10000.00</font><font color=FF0000>,</font>
&nbsp;&nbsp;<font color=FF0000>}</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;extra&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>&gt;</font>&nbsp;self<font color=FF0000>.</font>LIM&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;self<font color=FF0000>.</font>balance<font color=FF0000>*</font><font color=AC00A9>0.10</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=AC00A9>0</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;getBalance&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;self<font color=FF0000>.</font>balance&nbsp;<font color=FF0000>+</font>&nbsp;extra<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=FF0000>&lt;</font>как&nbsp;ранее<font color=FF0000>&gt;</font>
</pre>

<p>Опять нет никакого способа непосредственно вызвать функцию <code>extra</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="16.5. Подход с единственным методом"></a>16.5. Подход с единственным методом
</div>

<p>Частным случаем предыдущего подхода для обьектно-ориентированного программирования является случай, когда у обьекта всего один метод. В подобном случае нам не нужно создавать интерфейсную таблицу; мы можем просто вернуть этот метод в качестве представления обьекта. Если это выглядит немного странно, давайте вспомним <a href="#7.1. Итераторы и замыкания">раздел 7.1</a>, где мы создавали итерирующие функции, храпящие свое состояние как замыкания. Итератор, хранящий свое состояние, ничем не отличается от обьекта с единственной функцией.</p>

<p>Другим интересным случаем обьектов с единственным методом является случай, когда этот метод на самом деле выполняет различные задачи в зависимости от определенного аргумента. Возможная реализация такого обьекта приведена ниже:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;newObject&nbsp;<font color=FF0000>(</font>value<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>action<font color=FF0000>,</font>&nbsp;v<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;action&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"get"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;value
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>elseif</font>&nbsp;action&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"set"</font>&nbsp;<font color=0000DF>then</font>&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;v
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"invalid&nbsp;action"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Его использование довольно просто:</p>

<pre class="code">
d&nbsp;<font color=FF0000>=</font>&nbsp;newObject<font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>d<font color=FF0000>(</font><font color=8888CC>"get"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0</font>
d<font color=FF0000>(</font><font color=8888CC>"set"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>d<font color=FF0000>(</font><font color=8888CC>"get"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;10</font>
</pre>

<p>Эта реализация обьектов довольно эффективна. Синтаксис <code>d("set", 10)</code> хотя и выглядит странно, всего на два символа длиннее, чем традиционный <code>d:set(10</code>). Каждый обьект использует одно замыкание, что дешевле одной таблицы. Здесь нет наследования, но зато мы имеем полную закрытость: единственный способ обратиться к состоянию обьекта заключается в использовании его единственного метода.</p>

<p><i>Tcl/Tk</i> использует похожий подход для своих виджетов. Имя виджета в <i>Тк</i> обозначает функцию (<i>команду виджета</i>), которая может выполнять различные типы операций над виджетом.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="16. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 16.1.</b><br>
Реализуйте класс <code>Stack</code> с методами <code>push</code>, <code>pop</code>, <code>top</code> и <code>isempty</code>.</p>

<hr color="#99CCFF">

<p><b>Упражнение 16.2.</b><br>
Реализуйте класс <code>StackQueue</code> как подкласс <code>Stack</code>. Кроме унаследованных методов, добавьте к этому классу метод insertbottom, который вставляет элемент в конец стека (Этот метод позволяет использовать обьекты данного класса как очереди.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 16.3.</b><br>
Другой способ обеспечить закрытость для обьектов - это реализовать их с использованием прокси (<i>proxy</i>) (см. <a href="#13.4. Метаметоды для доступа к таблице">раздел 13.4</a>). Каждый обьект представлен пустой таблицей (прокси). Внутренняя таблица устанавливает соответствие между этими пустыми таблицами и таблицами, несущими состояние обьекта. Эта внутренняя таблица не доступна снаружи, но методы используют ее для перевода своего параметра <code>self</code> на реальную таблицу, с которой они работают. Реализуйте пример с классом <code>Account</code> при помощи этого подхода и рассмотрите его плюсы и минусы.</p>

<p>(С этим подходом есть одна маленькая проблема. Постарайтесь найти ее сами или обратитесь к <a href="#17.3. Атрибуты обьекта">разделу 17.3</a>, где предлагается ее решение.)</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="Глава 17. Слабые таблицы и финализаторы"></a>Глава 17. Слабые таблицы и финализаторы
</div>

<p>Lua осуществляет управление памятью. Программы создают обьекты (таблицы, нити и т. п.), но нет функции для уничтожения обьектов. Lua автоматически уничтожает обьекты, которые становятся мусором, при помощи <i>сборки мусора</i>. Это освобождает вас от основной части работы с памятью и, что более важно, освобождает от большинства ошибок, связанных с этой деятельностью, таких как висящие ссылки и утечки памяти.</p>

<p>Использование сборщика мусора означает, что у Lua нет проблем с циклами. Вам не нужно никаких специальных действий при использовании циклических структур данных - они автоматически освобождаются, как и любые другие данные. Однако иногда даже умному сборщику мусора нужна ваша помощь. Ни один сборщик мусора не позволит вам забыть обо всех проблемах об управлении ресурсами, такими как внешние ресурсы.</p>

<p>Слабые таблицы и финализаторы - это механизмы, которые вы можете использовать в Lua для того, чтобы помочь сборщику мусора. Слабые таблицы позволяют сбор обьектов Lua, которые все еще доступны программе, в то время как финализаторы позволяют сборку внешних обьектов, не находящихся под непосредственным контролем сборщика мусора. В этой главе мы обсудим оба этих механизма.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="17.1. Слабые таблицы"></a>17.1. Слабые таблицы
</div>

<p>Сборщик мусора может собрать только то, что гарантированно является мусором. Он не может сам угадать, что является мусором по вашему мнению. Типичным примером является стек, реализованный как массив, со ссылкой на вершину стека. Вы знаете, что данные лежат только от начала массива и до этого индекса (вершины стека), но Lua этого не знает. Если вы снимаете элемент с вершины стека, просто уменьшая индекс вершины, то оставшийся в массиве обьект не является мусором для Lua. Аналогично любой обьект, на который ссылается глобальная переменная, также не является мусором для Lua, даже если вы его никогда не будете использовать. В обоих случаях вам (точнее, вашей программе) следует записать <b>nil</b> в соответствующие переменные (или элементы массива), для того чтобы избежать появления неуничтожаемых обьектов.</p>

<p>Однако просто убрать ссылки не всегда достаточно. В некоторых случаях нужно дополнительное взаимодействие между вашей программой и сборщиком мусора. Типичным примером является набор всех активных обьектов определенного типа (например, файлов) в вашей программе. Задача кажется простой: все, что вам требуется, - это добавить каждый новый обьект к этому набору. Однако как только обьект становится частью набора, он уже никогда не будет уничтожен! Даже если на него никто и не ссылается, то набор все равно ссылается на него. Lua не может знать, что эта ссылка не должна препятствовать уничтожению этого обьекта, если только вы не скажете Lua об этом.</p>

<p>Слабые таблицы - это тот механизм, который вы используете в Lua, для того чтобы сказать, что ссылка не должна препятствовать уничтожению обьекта. <i>Слабая ссылка</i> - это такая ссылка на обьект, которая не учитывается сборщиком мусора. Если все ссылки, указывающие на обьект, являются слабыми, то данный обьект освобождается, и все эти слабые ссылки уничтожаются. Lua реализует слабые ссылки при помощи слабых таблиц: <i>слабая таблица</i>, - это такая таблица, все ссылки которой являются слабыми. Это значит, что если обьект хранится только внутри слабой таблицы, то сборщик мусора рано или поздно уничтожит данный обьект.</p>

<p>Таблицы хранят ключи и значения, и те, и другие могут быть обьектами любого типа. В нормальных условиях сборщик мусора не уничтожает обьекты, которые являются ключами и ссылками в доступной таблице. И ключи, и значения являются <i>сильными</i> ссылками, то есть они предотвращают уничтожение тех обьектов, на которые они указывают. В слабой таблице и ключи, и значения могут быть слабыми. Это значит, что существуют три типа слабых таблиц: таблицы со слабыми ключами, таблицы со слабыми значениями и полностью слабые таблицы, где и ключи, и значения являются слабыми. Независимо от типа таблицы, при уничтожении ключа или значения вся запись удаляется из таблицы.</p>

<p>Слабость таблицы задается полем <code>__mode</code> ее метатаблицы. Значение этого поля, когда оно присутствует, должно быть строкой. Если эта строка равна <code>"к"</code>, то ключи в этой таблице являются слабыми. Если эта строка равна <code>"v"</code>, то слабыми являются значения в этой таблице. Если эта строка равна <code>"kv"</code>, то и ключи, и значения в данной таблице являются слабыми. Следующий пример, хотя и искусственный, показывает поведение слабых таблиц:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"k"</font><font color=FF0000>}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;теперь&nbsp;у&nbsp;'а'&nbsp;слабые&nbsp;ключи</font>
key&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;первый&nbsp;ключ</font>
a<font color=FF0000>[</font>key<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
key&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;второй&nbsp;ключ</font>
a<font color=FF0000>[</font>key<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>2</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;заставляем&nbsp;сборщик&nbsp;мусора&nbsp;удалить&nbsp;мусор</font>
<font color=0000DF>for</font>&nbsp;k<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>v<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
<font color=008000>--&gt;&nbsp;2</font>
</pre>

<p>В этом примере второе присваивание <code>кеу={}</code> уничтожает ссылку на первый ключ. Вызов <code>collectgarbage</code> заставляет сборщик мусора удалить весь мусор. Поскольку нет больше ссылок на первый ключ, то этот ключ и соответствующая запись в таблице удаляются. Второй ключ по-прежнему хранится в переменной <code>key</code>, поэтому он не удаляется.</p>

<p>Обратите внимание, что только обьекты могут быть удалены из слабой таблицы. Такие значения, как числа и логические значения, не удаляются. Например, если мы вставим числовой ключ в таблицу <code>а</code> (из нашего предыдущего примера), то сборщик мусора никогда его не удалит. Конечно, если значение, соответствующее числовому ключу, хранится в таблице со слабыми значениями, то вся соответствующая запись целиком удаляется из таблицы.</p>

<p>Со строками есть определенная тонкость. Хотя строки и удаляются сборщиком мусора, с точки зрения реализации они отличаются от остальных обьектов. Другие обьекты, такие как таблицы и нити, создаются явно. Например, когда Lua выполняет выражение <code>{}</code>, то он создает новую таблицу. Однако создает ли Lua новую строку при выполнении <code>"а" .. "b"</code>? Что, если в системе уже есть строка <code>"ab"</code>? Создаст ли Lua новую строку? Может ли компилятор создать эту строку перед выполнением программы? Это не имеет никакого значения. Это все детали реализации. С точки зрения программиста, строки являются значениями, а не обьектами. Поэтому, так же как и число или логическое значение, строка не может быть удалена из слабой таблицы (кроме случая, когда удаляется связанное с ней значение).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="17.2. Функции с кэшированием"></a>17.2. Функции с кэшированием
</div>

<p>Распространенным программистским приемом является получение выигрыша во времени за счет проигрыша по памяти. Вы можете ускорить функцию, кэшируя ее результаты, так что когда позлее вы вызовете эту же функцию с теми же аргументами, функция сможет использовать сохраненное в кэше значение.</p>

<p>Представьте себе сервер, получающий запросы в виде строк, содержащих код на Lua. Каждый раз при получении запроса сервер выполняет <code>load</code> для полученной строки и затем вызывает полученную функцию. Однако <code>load</code> - это дорогая функция, и некоторые команды серверу могут много раз повторяться. Вместо постоянного вызова <code>load</code> каждый раз, когда сервер получает команду вроде "<code>closeconnection()</code>", сервер может запомнить результат <code>load</code> во вспомогательной таблице. Перед вызовом <code>load</code> сервер проверяет, нет ли уже значения, соответствующего данной строке. Если он не может найти соответствующее значение, то тогда (и только тогда) сервер вызывает <code>load</code> и запоминает результат в этой таблице. Мы можем реализовать это поведение при помощи следующей функции:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;results&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>function</font>&nbsp;mem_loadstring&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;results<font color=FF0000>[</font>s<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;res&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;результата&nbsp;нет?</font>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>load</font><font color=FF0000>(</font>s<font color=FF0000>))</font>&nbsp;<font color=008000>--&nbsp;вычислить&nbsp;новый&nbsp;результат</font>
&nbsp;&nbsp;&nbsp;&nbsp;results<font color=FF0000>[</font>s<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;res&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;сохранить&nbsp;результат</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;res
<font color=0000DF>end</font>
</pre>

<p>Выигрыш от этой схемы может быть очень значительным. Однако также она может вызвать большие потери памяти. Хотя некоторые команды повторяются снова и снова, многие другие команды встречаются только один раз. Со временем таблица <code>results</code> собирает все команды, которые сервер когда-либо получал, и соответствующий им код. Со временем это может привести к исчерпанию памяти на сервере. Слабые таблицы предоставляют простое решение данной проблемы. Если таблица <code>results</code> хранит слабые значения, то каждый цикл сборки мусора удалит все неиспользуемые на данный момент значения (фактически все):</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;results&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>results<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"v"</font><font color=FF0000>})</font>&nbsp;<font color=008000>--&nbsp;значения&nbsp;будут&nbsp;слабыми</font>
<font color=0000DF>function</font>&nbsp;mem_loadstring&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>как&nbsp;ранее<font color=FF0000>&gt;</font>
</pre>

<p>На самом деле, поскольку индексы всегда являются строками, мы можем сделать эту таблицу полностью слабой, если мы этого хотим:</p>

<pre class="code">
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>results<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"kv"</font><font color=FF0000>})</font>
</pre>

<p>Техника кэширования также полезна, чтобы гарантировать уникальность обьектов определенного типа. Например, пусть мы представляем цвета как таблицы с полями <code>red</code>, <code>green</code> и <code>blue</code>. Простейшая фабрика цветов будет создавать новую таблицу каждый раз, когда мы к ней обращаемся:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;createRGB&nbsp;<font color=FF0000>(</font>r<font color=FF0000>,</font>&nbsp;g<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>{</font>red&nbsp;<font color=FF0000>=</font>&nbsp;r<font color=FF0000>,</font>&nbsp;green&nbsp;<font color=FF0000>=</font>&nbsp;g<font color=FF0000>,</font>&nbsp;blue&nbsp;<font color=FF0000>=</font>&nbsp;b<font color=FF0000>}</font>
<font color=0000DF>end</font>
</pre>

<p>Используя кэширование, мы можем переиспользовать таблицы для одних и тех же цветов. Для создания уникального ключа для каждого цвета мы просто соединяем компоненты цвета при помощи некоторого разделителя:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;results&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>results<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"v"</font><font color=FF0000>})</font>&nbsp;<font color=008000>--&nbsp;значения&nbsp;будут&nbsp;слабыми</font>
<font color=0000DF>function</font>&nbsp;createRGB&nbsp;<font color=FF0000>(</font>r<font color=FF0000>,</font>&nbsp;g<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;key&nbsp;<font color=FF0000>=</font>&nbsp;r&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"-"</font>&nbsp;<font color=FF0000>..</font>&nbsp;g&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"-"</font>&nbsp;<font color=FF0000>..</font>&nbsp;b
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;color&nbsp;<font color=FF0000>=</font>&nbsp;results<font color=FF0000>[</font>key<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;color&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;color&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>red&nbsp;<font color=FF0000>=</font>&nbsp;r<font color=FF0000>,</font>&nbsp;green&nbsp;<font color=FF0000>=</font>&nbsp;g<font color=FF0000>,</font>&nbsp;blue&nbsp;<font color=FF0000>=</font>&nbsp;b<font color=FF0000>}</font>
&nbsp;&nbsp;&nbsp;&nbsp;results<font color=FF0000>[</font>key<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;color
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;color
<font color=0000DF>end</font>
</pre>

<p>Интересным последствием этой реализации является то, что пользователь может сравнивать цвета на равенство при помощи стандартного оператора сравнения, поскольку двум одновременно существующим одинаковым цветам всегда будет соответствовать одинаковая таблица. Обратите внимание, что одинаковый цвет может быть представлен разными таблицами в разные моменты времени, поскольку время от времени сборщик мусора будет опустошать таблицу <code>results</code>. Однако пока данный цвет используется, он не может быть удален из <code>results</code>. Поэтому если цвет существует достаточно долго, чтобы быть сравненным с другим цветом, его представление также будет существовать столь же долго.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="17.3. Атрибуты обьекта"></a>17.3. Атрибуты обьекта
</div>

<p>Другим интересным использованием слабых таблиц является связывание атрибутов с обьектами. Существует бесконечное число ситуаций, когда нам может понадобиться привязать некоторый атрибут к обьекту: имена к функциям, значения по умолчанию к таблицам, размеры к массивам и т. д.</p>

<p>Когда обьект является таблицей, то мы можем запомнить атрибут в самой таблице, выбрав подходящий уникальный ключ. Как мы уже видели, простой и надежный способ создать уникальный ключ - создать новый обьект (обычно таблицу) и использовать его в качестве ключа. Однако если обьект не является таблицей, то этот подход уже не годится. Даже для таблиц нам может понадобиться не хранить атрибут в самой таблице. Например, мы можем захотеть сделать подобный атрибут закрытым или мы не хотим влиять на то, как таблица перебирается. Во всех этих случаях нам нужен другой способ связывания атрибутов с обьектами.</p>

<p>Конечно, отдельная таблица предоставляет идеальный способ привязывания атрибутов обьектам (не случайно, что таблицы иногда называют <i>ассоциативными массивами</i>). Мы можем использовать обьекты как ключи, а их атрибуты - как значения. Такая таблица может хранить атрибуты обьектов любого типа, так как Lua позволяет использовать обьекты любого типа в качестве ключей таблицы. Более того, атрибуты, хранимые в отдельной таблице, не влияют на другие обьекты и могут быть закрытыми, так же как и сама таблица.</p>

<p>Однако это решение обладает огромным недостатком: как только мы использовали обьект в качестве ключа в таблице, он уже не может быть удален сборщиком мусора. Lua не может удалить обьект, который используется в качестве ключа. Если мы используем обычную таблицу, для того чтобы привязать к функциям их имена, то пи одна из этих функций никогда не будет удалена. Как вы можете предположить, мы можем избежать этого недостатка при помощи слабых таблиц. Однако на этот раз нам понадобятся слабые ключи. Использование слабых ключей не мешает сборщику мусора удалять эти ключи, когда на них не остается больше ссылок. С другой стороны, у таблицы не могут быть слабые значения, иначе атрибуты существующих обьектов могли бы быть удалены.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="17.4. Опять таблицы со значениями по умолчанию"></a>17.4. Опять таблицы со значениями по умолчанию
</div>

<p>В <a href="#13.4. Метаметоды для доступа к таблице">разделе 13.4</a> мы рассмотрели, как можно работать со значениями по умолчанию, отличными от <b>nil</b>. Мы показали один подход и заметили, что два других подхода требуют использования слабых таблиц, поэтому рассказ о них мы отложили на потом. Теперь пора вернуться к этой теме. Как вы увидите, эти два подхода к реализации значений по умолчанию на самом деле являются частными случаями уже рассмотренных подходов, а именно атрибутов обьектов и кэширования.</p>

<p>В первом подходе мы используем слабые таблицы, для того чтобы связать с таблицей ее значения по умолчанию:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;defaults&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>defaults<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"k"</font><font color=FF0000>})</font>
<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;defaults<font color=FF0000>[</font>t<font color=FF0000>]</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>}</font>
<font color=0000DF>function</font>&nbsp;setDefault&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;d<font color=FF0000>)</font>
&nbsp;&nbsp;defaults<font color=FF0000>[</font>t<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;d
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Если бы <code>defaults</code> не использовал слабые ключи, то все таблицы со значениями по умолчанию существовали бы всегда.</p>

<p>Во втором решении мы используем разные метатаблицы для разных значений по умолчанию, но при этом мы переиспользуем одну и ту же метатаблицу, когда мы снова используем то же самое значение по умолчанию. Это типичный случай кэширования:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;metas&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>metas<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"v"</font><font color=FF0000>})</font>
<font color=0000DF>function</font>&nbsp;setDefault&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;d<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;metas<font color=FF0000>[</font>d<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;mt&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__index&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>return</font>&nbsp;d&nbsp;<font color=0000DF>end</font><font color=FF0000>}</font>
&nbsp;&nbsp;&nbsp;&nbsp;metas<font color=FF0000>[</font>d<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;mt&nbsp;<font color=008000>--&nbsp;запомнить</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>В этом случае мы используем слабые значения, для того чтобы неиспользуемые метатаблицы могли бы быть собраны сборщиком мусора.</p>

<p>Какое из этих двух решений является лучшим? Как обычно, это зависит от использования. Оба решения обладают примерно одинаковой сложностью и одинаковым быстродействием. Первое решение требует нескольких слов памяти для каждой таблицы со значением по умолчанию (на запись в <code>defaults</code>). Второе решение требует нескольких десятков слов памяти на каждое уникальное значение по умолчанию (новая таблица, новое замыкание плюс запись в <code>metas</code>). Поэтому если в вашем приложении тысячи таблиц с всего несколькими различными значениями по умолчанию, то второе решение явно будет лучше. С другой стороны, если несколько таблиц обладают общими значениями по умолчанию, то вам лучше предпочесть первую реализацию.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="17.5. Эфемерные таблицы"></a>17.5. Эфемерные таблицы
</div>

<p>Интересный случай возникает, когда в таблице со слабыми ключами значение ссылается на его собственный ключ.</p>

<p>Этот случай гораздо более распространен, чем может показаться. Типичным примером является фабрика, возвращающая функции. Подобная фабрика получает обьект и возвращает функцию, которая при вызове вернет этот обьект:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;factory&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>return</font>&nbsp;o&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Эта фабрика является хорошим кандидатом для кэширования, для того чтобы не создавать новые замыкания, когда уже есть подходящее, уже созданное замыкание:</p>

<pre class="code">
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;mem&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>(</font>mem<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"k"</font><font color=FF0000>})</font>
&nbsp;&nbsp;<font color=0000DF>function</font>&nbsp;factory&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;mem<font color=FF0000>[</font>o<font color=FF0000>]</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;res&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=0000DF>return</font>&nbsp;o&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem<font color=FF0000>[</font>o<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;res
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;res
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Однако здесь есть один подвох. Обратите внимание, что значение (соответствующая функция), связанная с обьектом, находящимся в <code>mem</code>, - ссылается на свой собственный ключ (сам обьект). Хотя ключи являются слабыми в этой таблице, но значения слабыми не являются. При стандартной интерпретации слабых таблиц ничто не будет удалено из кэширующей таблицы. Поскольку значения не являются слабыми, то всегда есть сильная ссылка на каждую функцию. Каждая функция ссылается на свой обьект, то есть всегда есть сильная ссылка на каждый обьект. Поэтому эти обьекты не могут быть удалены, несмотря на использование слабых ключей.</p>

<p>Однако подобная интерпретация не всегда очень полезна. Большинство людей ожидает, что значение в таблице доступно только через соответствующий ключ. Поэтому мы можем рассматривать подобный сценарий как случай цикла, где замыкание ссылается на обьект, который (через кэширующую таблицу) сам ссылается на это замыкание.</p>

<p>Lua 5.2 решает данную проблему при помощи эфемерных таблиц. В Lua 5.2 таблица со слабыми ключами и сильными значениями является <i>эфемерной таблицей</i> (<i>ephemeron table</i>). В эфемерной таблице доступность ключа управляет доступностью соответствующего значения. Более точно рассмотрим запись <code>(k,v)</code> в эфемерной таблице. Ссылка на <code>v</code> является сильной, только если есть сильная ссылка на <code>k</code>. В противном случае запись со временем удаляется из таблицы, даже если <code>v</code> ссылается (непосредственно или опосредованно) на <code>k</code>.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="17.6. Финализаторы"></a>17.6. Финализаторы
</div>

<p>Хотя целью сборщика мусора является удаление обьектов Lua, он также может помочь программе освобождать внешние ресурсы. Для этих целей различные языки программирования предлагают механизм финализаторов. <i>Финализатор</i> - это функция, связанная с обьектом, которая вызывается перед тем, как обьект будет удален сборщиком мусора.</p>

<p>Lua реализует финализаторы при помощи метаметода <code>__gc</code>. Посмотрите на следующий пример:</p>

<pre class="code">
o&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"hi"</font><font color=FF0000>}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>o<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>o<font color=FF0000>.</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>})</font>
o&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;hi</font>
</pre>

<p>В этом примере мы сперва создаем таблицу и устанавливаем для нее метатаблицу, у которой есть метаметод <code>__gc</code>. Затем мы уничтожаем единственную ссылку на эту таблицу (глобальная переменная <code>о</code>) и вызываем сборку мусора при помощи вызова <code>collectgarbage</code>. Во время сборки мусора Lua обнаруживает, что данная таблица не является доступной и вызывает ее финализатор(метаметод <code>__gc</code>).</p>

<p>Тонким моментов в Lua является помечание обьекта для финализации. Мы помечаем обьект для финализации, когда задаем для него метатаблицу с ненулевым нолем <code>__gc</code>. Если мы не пометим обьект, то он не будет финализирован. Большая часть кода, который мы пишем, будет работать, однако иногда возникают странные случаи вроде следующего:</p>

<pre class="code">
o&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"hi"</font><font color=FF0000>}</font>
mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>o<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
mt<font color=FF0000>.</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>o<font color=FF0000>.</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
o&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;(ничего&nbsp;не&nbsp;печатает)</font>
</pre>

<p>В этом примере метатаблица, которую мы устанавливаем для <code>о</code>, не содержит метаметода <code>__gc</code>, поэтому обьект и не помечается для финализации. Даже если мы потом и добавляем поле <code>__gc</code> метатаблице, Lua не рассматривает это присваивание как нечто особенное, поэтому обьект и не будет помечен. Как мы уже сказали, это редко бывает проблемой. Обычно метатаблица не изменяется после того, как она была назначена метатаблицей.</p>

<p>Если вы действительно хотите задать метаметод позже, то вы можете использовать любое значение для поля <code>__gc</code> в качестве временного:</p>

<pre class="code">
o&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"hi"</font><font color=FF0000>}</font>
mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font><font color=FF0000>}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>o<font color=FF0000>,</font>&nbsp;mt<font color=FF0000>)</font>
mt<font color=FF0000>.</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>o<font color=FF0000>.</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
o&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;hi</font>
</pre>

<p>Теперь, поскольку метатаблица содержит поле <code>__gc</code>, обьект <code>о</code> помечается для финализации. Нет никакой проблемы в том, чтобы задать метаметод позжее. Lua вызывает финализатор, только если он является функцией.</p>

<p>Когда сборщик мусора уничтожает несколько обьектов в одном и том же цикле, он вызывает их финализаторы в порядке, обратном тому, в котором обьекты были помечены для финализации. Рассмотрим следующий пример, который создаст связанный список обьектов с финализаторами:</p>

<pre class="code">
mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>o<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>])</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>}</font>
list&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>3</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;list&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>({</font>i<font color=FF0000>,</font>&nbsp;link&nbsp;<font color=FF0000>=</font>&nbsp;list<font color=FF0000>},</font>&nbsp;mt<font color=FF0000>)</font>
<font color=0000DF>end</font>
list&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>
<font color=008000>--&gt;&nbsp;3</font>
<font color=008000>--&gt;&nbsp;2</font>
<font color=008000>--&gt;&nbsp;1</font>
</pre>

<p>Первым финализируемым обьектом будет обьект <code>3</code>, который был последним помеченным обьектом.</p>

<p>Распространенным заблуждением является мнение о том, что ссылки между уничтожаемыми обьектами могут повлиять на порядок, в котором они будут финализированы. Например, можно подумать, что обьект <code>2</code> в предыдущем примере должен быть финализирован перед обьектом <code>1</code>, поскольку существует ссылка от <code>2</code> к <code>1</code>. Однако ссылки могут формировать циклы. Поэтому они не накладывают никакого порядка на финализацию.</p>

<p>Другим тонким моментом, связанным с финализаторами, является <i>восстановление</i>. Когда финализатор вызывается, то он получает финализируемый обьект в качестве параметра. Таким образом, обьект снова становится живым, по крайней мере на время финализации, Я называю это <i>временным восстановлением</i>. Во время выполнения финализатора ничего не мешает ему запомнить обьект например в глобальной переменной, таким образом, что обьект останется доступным после завершения финализатора. Я называю это <i>постоянным восстановлением</i>.</p>

<p>Восстановление должно быть транзитивным. Рассмотрим следующий фрагмент кода:</p>

<pre class="code">
A&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"this&nbsp;is&nbsp;A"</font><font color=FF0000>}</font>
B&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>f&nbsp;<font color=FF0000>=</font>&nbsp;A<font color=FF0000>}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font>B<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>o<font color=FF0000>.</font>f<font color=FF0000>.</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>})</font>
A<font color=FF0000>,</font>&nbsp;B&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;this&nbsp;is&nbsp;A</font>
</pre>

<p>Финализатор для <code>В</code> обращается к <code>А</code>, поэтому <code>А</code> не может быть удален перед финализацией <code>В</code>. Lua должен восстановить и <code>А</code>, и <code>В</code> перед вызовом финализатора.</p>

<p>Из-за восстановления обьекты с финализаторами восстанавливаются в два прохода. Вначале сборщик мусора обнаруживает, что обьект с финализатором недостижим (на него никто не ссылается), тогда он восстанавливает этот обьект и добавляет его к очереди для финализации. После выполнения финализатора Lua помечает обьект как финализированный. В следующий раз, когда сборщик мусора обнаружит, что обьект недостижим, он его уничтожит. Если вы хотите гарантировать, что весь мусор в вашей программе действительно собран, то вы должны вызвать <code>collectgarbage</code> дважды. Второй вызов уничтожит обьекты, которые были финализированы во время первого вызова.</p>

<p>Финализатор для каждого обьекта выполняется ровно один раз, поскольку Lua помечает уже финализированные обьекты. Если обьект не был удален до конца работы программы, то Lua позовет его в самом конце. Эта возможность позволяет реализовать в Lua аналог <code>atexit</code> функций, то есть функций, которые вызываются непосредственно перед завершением работы программы. Все, что для этого нужно, - это создать таблицу с финализатором и запомнить ссылку на нее где-нибудь, например в глобальной переменной:</p>

<pre class="code">
<font color=0080C0>_G</font><font color=FF0000>.</font>AA&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;your&nbsp;'atexit'&nbsp;code&nbsp;comes&nbsp;here</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"finishing&nbsp;Lua&nbsp;program"</font><font color=FF0000>)</font>
<font color=0000DF>end</font><font color=FF0000>}</font>
<font color=0080C0>setmetatable</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>.</font>AA<font color=FF0000>,</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>.</font>AA<font color=FF0000>)</font>
</pre>

<p>Другой интересной возможностью является возможность вызывать определенную функцию каждый раз, когда Lua завершает цикл сборки мусора. Поскольку финализатор вызывается ровно один раз, то необходимо в финализаторе создать новый обьект для вызова следующего финализатора:</p>

<pre class="code">
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;все,&nbsp;что&nbsp;вы&nbsp;хотите&nbsp;сделать</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"новый&nbsp;цикл"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;новый&nbsp;обьект&nbsp;для&nbsp;следующего&nbsp;цикла</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>({},</font>&nbsp;<font color=0080C0>getmetatable</font><font color=FF0000>(</font>o<font color=FF0000>))</font>
&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>}</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;создаем&nbsp;первый&nbsp;обьект</font>
&nbsp;&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>({},</font>&nbsp;mt<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;новый&nbsp;цикл</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;новый&nbsp;цикл</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;новый&nbsp;цикл</font>
</pre>

<p>Взаимодействие обьектов с финализаторами и слабых таблиц содержит тонкий момент. Сборщик мусора очищает значения в слабой таблице перед восстановлением, в то время как ключи очищаются после восстановления. Следующий фрагмент кода иллюстрирует это поведение:</p>

<pre class="code">
<font color=008000>--&nbsp;таблица&nbsp;со&nbsp;слабыми&nbsp;ключами</font>
wk&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>({},</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"k"</font><font color=FF0000>})</font>

<font color=008000>--&nbsp;таблица&nbsp;со&nbsp;слабыми&nbsp;значениями</font>
wv&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>({},</font>&nbsp;<font color=FF0000>{</font>__mode&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"v"</font><font color=FF0000>})</font>

o&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;обьект</font>
wv<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;o<font color=FF0000>;</font>&nbsp;wk<font color=FF0000>[</font>o<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>&nbsp;<font color=008000>--&nbsp;добавим&nbsp;к&nbsp;обеим&nbsp;таблицам</font>

<font color=0080C0>setmetatable</font><font color=FF0000>(</font>o<font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>o<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>wk<font color=FF0000>[</font>o<font color=FF0000>],</font>&nbsp;wv<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>])</font>
<font color=0000DF>end</font><font color=FF0000>})</font>

o&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font><font color=FF0000>;</font>&nbsp;<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&gt;&nbsp;10&nbsp;nil</font>
</pre>

<p>Во время выполнения финализатора он находит обьект в таблице <code>wk</code>, но не в таблице <code>wv</code>. Обоснованием такого поведения является то, что мы часто храним свойства обьекта в таблицах слабыми ключами (как мы это рассмотрели в <a href="#17.3. Атрибуты обьекта">разделе 17.3</a>) и финализаторам может понадобиться обращение к этим атрибутам. Однако мы используем таблицы со слабыми значениями для переиспользования существующих обьектов; в этом случае социализируемые обьекты больше не нужны.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="17. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 17.1.</b><br>
Напишите код, для того чтобы проверить, действительно ли Lua использует эфемерные таблицы (Не забудьте вызвать <code>collectgarbage</code> для сборки мусора.) По возможности проверьте ваш код как в Lua 5.1, так и в Lua 5.2.</p>

<hr color="#99CCFF">

<p><b>Упражнение 17.2.</b><br>
Рассмотрим первый пример из <a href="#17.6. Финализаторы">разделе 17.6</a>, создающий таблицу с финализатором, печатающим сообщение при вызове. Что произойдет, если программа завершится без вызова сборки мусора? Что случится, если программа вызовет <code>os.exit</code>? Что случится, если программа завершит свое выполнение с ошибкой?</p>

<hr color="#99CCFF">

<p><b>Упражнение 17.3.</b><br>
Пусть вам нужно реализовать кэширующую таблицу для функции, получающей строку и возвращающей строку. Использование слабой таблицы не позволит удалять записи, поскольку слабые таблицы не рассматривают строки как удаляемые обьекты. Как вы можете реализовать кэширование в этом случае?</p>

<hr color="#99CCFF">

<p><b>Упражнение 17.4.</b><br>
Обьясните вывод следующей программы:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>

<font color=0000DF>local</font>&nbsp;mt&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>__gc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;count&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=0000DF>end</font><font color=FF0000>}</font>
<font color=0000DF>local</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>

<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>10000</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;count&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>setmetatable</font><font color=FF0000>({},</font>&nbsp;mt<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>collectgarbage</font><font color=8888CC>"count"</font>&nbsp;<font color=FF0000>*</font>&nbsp;<font color=AC00A9>1024</font><font color=FF0000>,</font>&nbsp;count<font color=FF0000>)</font>
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>nil</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>collectgarbage</font><font color=8888CC>"count"</font>&nbsp;<font color=FF0000>*</font>&nbsp;<font color=AC00A9>1024</font><font color=FF0000>,</font>&nbsp;count<font color=FF0000>)</font>
<font color=0080C0>collectgarbage</font><font color=FF0000>()</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>collectgarbage</font><font color=8888CC>"count"</font>&nbsp;<font color=FF0000>*</font>&nbsp;<font color=AC00A9>1024</font><font color=FF0000>,</font>&nbsp;count<font color=FF0000>)</font>
</pre>

<!-- ================================================================================ -->
<div class="part">
  ЧАСТЬ III. Стандартные библиотеки
</div>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 18. Математическая библиотека"></a>Глава 18. Математическая библиотека
</div>

<p>В этой и следующих главах, посвященных стандартной библиотеке, моей целью является не дать полную спецификацию каждой функции, а показать, какую функциональность предоставляет каждая библиотека. Я могу опустить некоторые специфические опции или поведение для ясности изложения. Главной целью является зажечь ваше любопытство, которое затем может быть удовлетворено чтением документации по Lua.</p>

<p>Библиотека <code>math</code> содержит стандартный набор математических функций, таких как тригонометрические (<code>sin, cos, tan, asin, acos</code> и т.п.), экспоненцирование и логарифмирование (<code>exp, log, log10</code>), округление (<code>floor, ceil</code>), <code>min, max</code>, функции для генерации псевдослучайных чисел (<code>random, randomseed</code>) и переменные <code>pi</code> и <code>huge</code> (последнее является наибольшим представнмым числом, на некоторых платформах может принимать специальное значение <code>inf</code>).</p>

<p>Все тригонометрические функции работают с радианами. Вы можете использовать функции <code>deg</code> и <code>rad</code> для перевода между градусами и радианами. Если вы хотите работать с градусами, вы можете переопределить тригонометрические функции:</p>

<pre class="code">
<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;sin<font color=FF0000>,</font>&nbsp;asin<font color=FF0000>,</font>&nbsp;<font color=FF0000>...</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.sin</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.asin</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>...</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;deg<font color=FF0000>,</font>&nbsp;rad&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>math.deg</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.rad</font>
&nbsp;&nbsp;<font color=8000FF>math.sin</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;sin<font color=FF0000>(</font>rad<font color=FF0000>(</font>x<font color=FF0000>))</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=8000FF>math.asin</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>&nbsp;<font color=0000DF>return</font>&nbsp;deg<font color=FF0000>(</font>asin<font color=FF0000>(</font>x<font color=FF0000>))</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF0000>...</font>
<font color=0000DF>end</font>
</pre>

<p>Функция <code>math.random</code> генерирует псевдослучайные числа. Мы можем вызывать ее тремя разными способами. Когда мы вызываем ее без аргументов, она возвращает вещественное псевдослучайное число в диапазоне <code>[0,1)</code>. Когда мы вызываем ее с единственным аргументом, целым <code>n</code>, то она возвращает псевдослучайное целое число <code>х</code>, лежащее между <code>1</code> и <code>n</code>. Наконец, мы можем вызвать ее с двумя целочисленными аргументами <code>l</code> и <code>u</code>, тогда она вернет псевдослучайное целое число, лежащее между <code>l</code> и <code>u</code>.</p>

<p>Вы можете задать «затравку» (<i>seed</i>) для генератора псевдослучайных чисел при помощи функции <code>randomseed</code>. Ее единственным числовым аргументом является «затравка». Обычно при начале работы программы генератор псевдослучайных чисел инициализируется некоторым фиксированным значением. Это значит, что каждый раз, когда вы запускаете вашу программу, она генерирует одну и ту же последовательность псевдослучайных чисел. Для отладки это оказывается весьма полезным, но в игре все время будете получать одно и то же. Стандартным приемом для борьбы с этим является использование текущего времени в качестве «затравки» при помощи вызова <code>math.randomseed(os.time())</code>. Функция <code>os.time</code> возвращает число, представляющее текущее время, обычно в виде числа секунд, прошедших с определенной даты.</p>

<p>Функция <code>math.random</code> использует функцию <code>rand</code> из стандартной библиотеки языка С. В некоторых реализациях возвращает числа с не очень хорошими статистическими свойствами. Вы можете обратиться к независимым дистрибутивам в поисках более удачного генератора псевдослучайных чисел (Стандартная поставка Lua не включает в себя подобного генератора из-за проблем с авторским правом. Она содержит только код, написанный авторами Lua.)</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="18. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 18.1.</b><br>
Напишите функцию для проверки того, является ли заданное число степенью двойки.</p>

<hr color="#99CCFF">

<p><b>Упражнение 18.2.</b><br>
Напишите функцию для расчета обьема конуса по его высоте и углу между его образующей и осью.</p>

<hr color="#99CCFF">

<p><b>Упражнение 18.3.</b><br>
Реализуйте другой генератор псевдослучайных чисел для Lua. Поищите хороший алгоритм в Интернете. (Вам может понадобиться библиотека для побитовых операций.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 18.4.</b><br>
Используя функцию <code>math.random</code>, напишите функцию для получения псевдослучайных чисел с гауссовским распределением.</p>

<hr color="#99CCFF">

<p><b>Упражнение 18.5.</b><br>
Напишите функцию для перемешивания заданного списка. Убедитесь, что все варианты равновероятны.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 19. Библиотека для побитовых операций"></a>Глава 19. Библиотека для побитовых операций
</div>

<p>Источником постоянных жалоб насчет Lua является отсутствие в нем побитовых операций. Это отсутствие вовсе не случайно. Не так легко помирить побитовые операции с числами с плавающей точкой.</p>

<p>Мы можем выразить некоторые побитовые операции как арифметические операции. Например, сдвиги влево соответствуют умножению на степени двух, сдвиги направо соответствуют делению. Однако у побитовых <code>AND</code> и <code>OR</code> нет таких арифметических аналогов. Они определены для двоичных представлений целых чисел. Практически невозможно расширить их на операции с плавающей точкой. Даже некоторые простые операции теряют смысл. Что должно быть дополнением <code>0.0</code>? Должно ли это быть равно <code>-1</code>? Или <code>0xFFFFFFFF</code>(что в Lua равно <code>4 294 967 295</code>, что явно не равно <code>-1</code>)? Или может быть <code>2^64 - 1</code> (число, которое нельзя точно представить при помощи значения типа <code>double</code>)?</p>

<p>Для того чтобы избежать подобных проблем, Lua 5.2 вводит побитовые операции при помощи библиотеки, а не как встроенные в язык операции. Это делает ясным, что данные операции не являются «родными» для чисел в Lua, по они используют определенную интерпретацию для работы с этими числами. Более того, другие библиотеки могут предложить иные интерпретации побитовых операций(например, используя более 32 битов).</p>

<p>Для большинства примеров в этой главе я буду использовать шестнадцатеричную запись. Я буду использовать слово <i>max</i> для обозначения <code>0xFFFFFFFF</code>(то есть <code>2^32-1</code>). В примерах я буду использовать следующую дополнительную функцию:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;printx&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"0x%X"</font><font color=FF0000>,</font>&nbsp;x<font color=FF0000>))</font>
<font color=0000DF>end</font>
</pre>

<p>Побитовая библиотека в Lua 5.2 называется <code>bit32</code>. Как следует из имени, она работает с 32-битовыми числами. Поскольку <b>and</b>, <b>or</b> и <b>not</b> являются зарезервированными в Lua словами, то соответствующие функции названы <code>band</code>, <code>bor</code> и <code>bnot</code>. Для последовательности в названиях функция для побитового исключающего <i>ИЛИ</i> названа <code>bxor</code>:</p>

<pre class="code">
printx<font color=FF0000>(</font><font color=0099FF>bit32.band</font><font color=FF0000>(</font><font color=AC00A9>0xDF</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0xFD</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0xDD</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.bor</font><font color=FF0000>(</font><font color=AC00A9>0xD0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0x0D</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xDD</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.bxor</font><font color=FF0000>(</font><font color=AC00A9>0xD0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0xFF</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0x2F</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.bnot</font><font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xFFFFFFFF</font>
</pre>

<p>Функции <code>band, bor</code> и <code>bxor</code> принимают любое количество аргументов:</p>

<pre class="code">
printx<font color=FF0000>(</font><font color=0099FF>bit32.bor</font><font color=FF0000>(</font><font color=AC00A9>0xA</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0xA0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0xA00</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xAAA</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.band</font><font color=FF0000>(</font><font color=AC00A9>0xFFA</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0xFAF</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0xAFF</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0xAAA</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.bxor</font><font color=FF0000>(</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0xAAA</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xAAA</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.bor</font><font color=FF0000>())</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0x0</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.band</font><font color=FF0000>())</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xFFFFFFFF</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.bxor</font><font color=FF0000>())</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0x0</font>
</pre>

<p>(Они все коммутативны и ассоциативны.)</p>

<p>Побитовая библиотека работает с беззнаковыми целыми числами. В ходе работы любое число, переданное как аргумент, приводится к целому числу в диапазоне <code>0-МАХ</code>. Во-первых, неуказанные числа округляются неуказанным способом. Во-вторых, числа вне диапазона <code>0-МАХ</code> приводятся к нему при помощи операции остатка от деления: целое <code>n</code> становится <code>n %(2^32)</code>. Эта операция эквивалентна получению двоичного представления числа и затем взятию его младших 32 бит. Как и ожидается, <code>-1</code> становится <code>МАХ</code>. Вы можете использовать следующие операции для нормализации числа(то есть отображения его в диапазон <code>0-МАХ</code>):</p>

<pre class="code">
printx<font color=FF0000>(</font><font color=0099FF>bit32.bor</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>^</font><font color=AC00A9>32</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0x0</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.band</font><font color=FF0000>(-</font><font color=AC00A9>1</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xFFFFFFFF</font>
</pre>

<p>Конечно, в стандартном Lua легче просто выполнить <code>n%(2^32)</code>. Если явно не указано, все функции в библиотеке возвращают результат, который также лежит в <code>0-МАХ</code>. Однако вам следует быть осторожными при использовании результатов побитовых операций в качестве обычных чисел. Иногда Lua компилируется, используя другой тип для чисел. В частности, некоторые системы с ограниченными возможностями используют 32-битовые числа в качестве чисел в Lua. В этих системах <code>МАХ=-1</code>. Более того, некоторые побитовые библиотеки используют различные соглашения для своих результатов. Поэтому всякий раз, когда вам нужно использовать результат побитовой операции в качестве числа, будьте осторожны. Избегайте сравнений: вместо <code>х &lt; 0</code> напишите <code>bit32.btest(х, 0x80000000)</code>.(Мы скоро увидим функцию <code>btest</code>.) Используйте саму побитовую библиотеку для нормализации констант:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;<font color=0099FF>bit32</font><font color=FF0000>.</font>or<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0099FF>bit32</font><font color=FF0000>.</font>or<font color=FF0000>(-</font><font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;<font color=FF0000>&lt;</font>какой<font color=FF0000>-</font>то&nbsp;код<font color=FF0000>&gt;</font>
</pre>

<p>Побитовая библиотека также определяет операции для сдвига и вращения бит: <code>lshift</code> для сдвига налево; <code>rshift</code> и <code>arshift</code> для сдвига направо; <code>lrotate</code> для вращения налево и <code>rrotate</code> для вращения направо. За исключением арифметического сдвига (<code>arshift</code>), все сдвиги заполняют новые биты нулями. Арифметический сдвиг заполняет биты слева копиями своего последнего бита.</p>

<pre class="code">
printx<font color=FF0000>(</font><font color=0099FF>bit32.rshift</font><font color=FF0000>(</font><font color=AC00A9>0xDF</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xD</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.lshift</font><font color=FF0000>(</font><font color=AC00A9>0xDF</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xDF0</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.rshift</font><font color=FF0000>(-</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>28</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xF</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.arshift</font><font color=FF0000>(-</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>28</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xFFFFFFFF</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.lrotate</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0xBCDEF01A</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.rrotate</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0x1ABCDEF0</font>
</pre>

<p>Сдвиг или вращение на отрицательное число бит сдвигает (вращает) в противоположную сторону. Например, сдвиг на <code>-1</code> бит направо эквивалентен сдвигу на <code>1</code> бит влево. Результат сдвига на более чем <code>31</code> бит равен <code>0</code> или <code>мах</code>, поскольку все исходные биты пропали:</p>

<pre class="code">
printx<font color=FF0000>(</font><font color=0099FF>bit32.lrotate</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>4</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0x1ABCDEF0</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.lrotate</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>36</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0x1ABCDEF0</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.lshift</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>36</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0x0</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.rshift</font><font color=FF0000>(-</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>34</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0x0</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.arshift</font><font color=FF0000>(-</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>34</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xFFFFFFFF</font>
</pre>

<p>Кроме этих, более или менее стандартных операций, побитовая библиотека также предоставляет три дополнительные функции. Функция <code>btest</code> осуществляет ту же операцию, что и <code>band</code>, но возвращает результат сравнения побитовой операции с нулем:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0099FF>bit32.btest</font><font color=FF0000>(</font><font color=AC00A9>12</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;false</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0099FF>bit32.btest</font><font color=FF0000>(</font><font color=AC00A9>13</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;true</font>
</pre>

<p>Другой распространенной операцией является извлечение заданных битов из числа. Обычно эта операция включает в себя сдвиг и побитовое <i>AND</i>. Побитовая библиотека упаковывает все это в одну функцию. Вызов <code>bit32.extract(х, f, w)</code> возвращает <code>w</code> бит из <code>х</code>, начиная с бита <code>f</code>:</p>

<pre class="code">
printx<font color=FF0000>(</font><font color=0099FF>bit32.extract</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>8</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xF0</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.extract</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>20</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>12</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0xABC</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.extract</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>12</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xF01</font>
</pre>

<p>Эта операция считает биты, начиная с <code>0</code> и до <code>31</code>. Если третий аргумент (<code>w</code>) не задан, то он считается равным единице:</p>

<pre class="code">
printx<font color=FF0000>(</font><font color=0099FF>bit32.extract</font><font color=FF0000>(</font><font color=AC00A9>0x0000000F</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0x1</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.extract</font><font color=FF0000>(</font><font color=AC00A9>0xF0000000</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>31</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0x1</font>
</pre>

<p>Обратной к операции <code>extract</code> является операция <code>replace</code>, которая заменяет заданные биты. Первым параметром является исходное число. Второй параметр задает значение, которое надо вставить. Последние два параметра, <code>f</code> и <code>w</code>, имеют тот же смысл, что и в <code>bit32.extract</code>:</p>

<pre class="code">
printx<font color=FF0000>(</font><font color=0099FF>bit32.replace</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0x55</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>8</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;0xABCDE551</font>
printx<font color=FF0000>(</font><font color=0099FF>bit32.replace</font><font color=FF0000>(</font><font color=AC00A9>0xABCDEF01</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0x0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>8</font><font color=FF0000>))</font>&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;0xABCDE001</font>
</pre>

<p>Обратите внимание, что для любых допустимых значений <code>х</code>, <code>f</code> и <code>w</code> выполняется следующее равенство:</p>

<pre class="code">
<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0099FF>bit32.replace</font><font color=FF0000>(</font>x<font color=FF0000>,</font>&nbsp;<font color=0099FF>bit32.extract</font><font color=FF0000>(</font>x<font color=FF0000>,</font>&nbsp;f<font color=FF0000>,</font>&nbsp;w<font color=FF0000>),</font>&nbsp;f<font color=FF0000>,</font>&nbsp;w<font color=FF0000>)</font>&nbsp;<font color=FF0000>==</font>&nbsp;x<font color=FF0000>)</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="19. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 19.1.</b><br>
Напишите функцию для проверки того, что заданное число является степенью двух.</p>

<hr color="#99CCFF">

<p><b>Упражнение 19.2.</b><br>
Напишите функцию для вычисления чйсла единичных бит в двоичном представлении числа.</p>

<hr color="#99CCFF">

<p><b>Упражнение 19.3.</b><br>
Напишите функцию для проверки того, является ли двоичное представление числа палиндромом.</p>

<hr color="#99CCFF">

<p><b>Упражнение 19.4.</b><br>
Определите операции сдвига и побитовый <i>AND</i> при помощи арифметических операций Lua.</p>

<hr color="#99CCFF">

<p><b>Упражнение 19.5.</b><br>
Напишите функцию, которая получает строку, закодированную в <i>UTF-8</i>, и возвращает ее первый символ как число. Функция должна вернуть nil, если строка не начинается с допустимой в <i>UTF-8</i> последовательности.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 20. Библиотека для работы с таблицами"></a>Глава 20. Библиотека для работы с таблицами
</div>

<p>Библиотека <code>table</code> содержит в себе дополнительные функции, позволяющие работать с таблицами как с массивами. Она предоставляет функции для вставки и удаления элементов из списка, для сортировки элементов массива и для конкатенации всех строк в массиве.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="20.1. Функции insert и remove"></a>20.1. Функции insert и remove
</div>

<p>Функция <code>table.insert</code> вставляет элемент в заданное место массива, сдвигая остальные элементы, для того чтобы освободить место. Например, если <code>t</code> - это массив <code>{10, 20, 30}</code>, то после вызова <code>table.insert(t,1,15)</code>, <code>t</code> будет равен <code>{15, 10, 20, 30}</code>. Специальным (и довольно частым) случаем является вызов <code>insert</code> без указания положения, тогда элемент вставляется в самый конец массива и сдвига элементов не происходит. В качестве примера следующий код читает ввод строку за строкой, запоминая все строки в массиве:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=8000FF>table.insert</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;line<font color=FF0000>)</font>
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(#</font>t<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;(число&nbsp;прочтенных&nbsp;строк)</font>
</pre>

<p>В Lua 5.0 этот прием довольно распространен. В более поздних версиях я предпочитаю использовать <code>t[#t+l]=line</code>, для того чтобы добавить строку к массиву.</p>

<p>Функция <code>table.remove</code> удаляет (и возвращает) элемент из заданного места массива, сдвигая при этом следующие элементы массива. Если при вызове положение внутри массива не было указано, то удаляется последний элемент массива.</p>

<p>При помощи этих двух функций довольно легко реализовать стеки, очереди и двойные очереди. Мы можем инициализировать подобные структуры как <code>t={}</code>. Операция добавления элемента эквивалентна <code>table.insert(t, х)</code>. Операция удаления элемента эквивалентна <code>table.remove(t)</code>. Вызов <code>table.insert(t,1,x)</code> добавляет элемент в другой конец соответствующей структуры, а вызов <code>table.remove(t,l)</code> соответственно удаляет элемент из этого конца. Две последние операции пе особенно эффективны, так как они должны перемещать все элементы массива в памяти. Однако поскольку в библиотеке <code>table</code> эти функции реализованы на С, то они не являются слишком дорогими и хорошо работают для небольших массивов (до нескольких сот элементов).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="20.2. Сортировка"></a>20.2. Сортировка
</div>

<p>Другой полезной функцией для работы с массивами является <code>table.sort</code>. Мы уже видели ее ранее. Она принимает в качестве аргументов массив и опционально функцию для сравнения. Эта функция принимает на вход два аргумента и должна вернуть <b>true</b>, если первый элемент должен идти перед вторым. Если эта функция не указана, то функция сортировки использует стандартный оператор <code>'&lt;'</code>.</p>

<p>Типичная путаница происходит, когда программист пытается отсортировать индексы в таблице. В таблице индексы образуют множество, в котором нет никакого упорядочения. Если вы хотите их отсортировать, то вам надо скопировать их в массив и отсортировать этот массив. Давайте рассмотрим пример. Пусть вы прочли входной файл и построили таблицу, которая для каждого имени функции содержит строку, в которой эта функция была определена: что-то вроде следующего:</p>

<pre class="code">
lines&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>
&nbsp;&nbsp;luaH_set&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>,</font>
&nbsp;&nbsp;luaH_get&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>24</font><font color=FF0000>,</font>
&nbsp;&nbsp;luaH_present&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>48</font><font color=FF0000>,</font>
<font color=FF0000>}</font>
</pre>

<p>И теперь вам нужно напечатать эти функции в алфавитном порядке. Если вы обойдете эту таблицу при помощи функции <code>pairs</code>, то имена окажутся в произвольном порядке. Вы не можете их явно отсортировать, поскольку эти имена являются ключами таблицы. Однако если вы поместите их в массив, то тогда уже этот массив можно отсортировать. Поэтому вам сначала нужно создать массив с этими именами, затем отсортировать его и уже потом напечатать результат:</p>

<pre class="code">
a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;n&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>lines<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;a<font color=FF0000>[#</font>a&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;n&nbsp;<font color=0000DF>end</font>
<font color=8000FF>table.sort</font><font color=FF0000>(</font>a<font color=FF0000>)</font>
<font color=0000DF>for</font>&nbsp;_<font color=FF0000>,</font>&nbsp;n&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>ipairs</font><font color=FF0000>(</font>a<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>n<font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
</pre>

<p>Некоторых это смущает. В конце концов, в Lua в массивах нет никакого упорядочения (массивы - это на самом деле таблицы). Поэтому мы навязываем упорядочение при работе с индексами, которые можно упорядочить. Именно поэтому вам лучше обходить массив при помощи <code>ipairs</code>, а не <code>pairs</code>. Первая из этих функций устанавливает порядок ключей <code>1, 2, 3,...,</code> в то время как вторая просто использует произвольный порядок из таблицы.</p>

<p>В качестве более продвинутого решении мы можем написать итератор для обхода таблицы, использующей заданный порядок ключей. Необязательный параметр <code>f</code> задает этот порядок. Этот итератор сначала сортирует ключи в отдельный массив, а затем уже обходит этот массив. На каждом шаге он возвращает ключ и соответствующее значение из исходного массива:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;pairsByKeys&nbsp;<font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;f<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;n&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;a<font color=FF0000>[#</font>a&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;n&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=8000FF>table.sort</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;f<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;итерируемая&nbsp;переменная</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;итерирующая&nbsp;функция</font>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;i&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;a<font color=FF0000>[</font>i<font color=FF0000>],</font>&nbsp;t<font color=FF0000>[</font>a<font color=FF0000>[</font>i<font color=FF0000>]]</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>При помощи этого итератора легко напечатать имена функций в алфавитном порядке:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;name<font color=FF0000>,</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;pairsByKeys<font color=FF0000>(</font>lines<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>name<font color=FF0000>,</font>&nbsp;line<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="20.3. Конкатенация"></a>20.3. Конкатенация
</div>

<p>В <a href="#11.6. Строчные буферы">разделе 11.6</a> мы уже видели функцию <code>table.concat</code>. Она берет на вход список строк и возвращает результат конкатенации всех этих строк. Необязательный второй аргумент задает строку-разделитель. Также есть еще два необязательных аргумента, которые задают индексы первой и последней конкатенируимых строк.</p>

<p>Следующая функция является интересным обобщением <code>table.concat</code>. Она может принимать на вход вложенные списки строк:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;rconcat&nbsp;<font color=FF0000>(</font>l<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0080C0>type</font><font color=FF0000>(</font>l<font color=FF0000>)</font>&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"table"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;l&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;res&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>#</font>l&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;res<font color=FF0000>[</font>i<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;rconcat<font color=FF0000>(</font>l<font color=FF0000>[</font>i<font color=FF0000>])</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>table.concat</font><font color=FF0000>(</font>res<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Для каждого элемента списка <code>rconcat</code> рекурсивно вызывает себя для обработки вложенных списков. Затем она вызывает <code>table.concat</code> для обьединения промежуточных результатов.</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>rconcat<font color=FF0000>{{</font><font color=8888CC>"a"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"&nbsp;nice"</font><font color=FF0000>}},</font>&nbsp;<font color=8888CC>"&nbsp;and"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>{{</font><font color=8888CC>"&nbsp;long"</font><font color=FF0000>},</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"&nbsp;list"</font><font color=FF0000>}}})</font>
<font color=008000>--&gt;&nbsp;a&nbsp;nice&nbsp;and&nbsp;long&nbsp;list</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="20. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 20.1.</b><br>
Перепишите функцию <code>rconcat</code> так, чтобы для нее можно было задать строку-разделитель:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>rconcat<font color=FF0000>({{{</font><font color=8888CC>"a"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"b"</font><font color=FF0000>},</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"c"</font><font color=FF0000>}},</font>&nbsp;<font color=8888CC>"d"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>{},</font>&nbsp;<font color=FF0000>{</font><font color=8888CC>"e"</font><font color=FF0000>}},</font>&nbsp;<font color=8888CC>";"</font><font color=FF0000>)</font>
<font color=008000>--&gt;&nbsp;a;b;c;d;e</font>
</pre>

<hr color="#99CCFF">

<p><b>Упражнение 20.2.</b><br>
Проблемой <code>table.sort</code> является то, что эта сортировка не является устойчивой (<i>stable sort</i>), то есть элементы, которые сортирующая функция считает равными, могут поменять свой порядок в процессе сортировки. Как можно реализовать устойчивую сортировку в Lua?</p>

<hr color="#99CCFF">

<p><b>Упражнение 20.3.</b><br>
Напишите функцию для проверки того, является ли заданная таблица допустимой последовательностью.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 21. Библиотека для работы со строками"></a>Глава 21. Библиотека для работы со строками
</div>

<p>Непосредственные возможности работы со строками интерпретатора Lua довольно ограничены. Программа может создавать строки, соединять их и получать длину строки. Но она не может извлекать подстроки или исследовать их содержимое. Подлинная мощь для работы со строками идет из ее библиотеки для работы со строками.</p>

<p>Библиотека для работы со строками доступна как модуль <code>string</code>. Начиная с Lua 5.1, функции также экспортируются как методы строк (используя метатаблицы). Так, перевод строки в заглавные буквы можно записать как <code>string.upper(s)</code> или <code>s:upper()</code>. Выбирайте сами.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="21.1. Основные функции для работы со строками"></a>21.1. Основные функции для работы со строками
</div>

<p>Некоторые функции для работы со строками в библиотеке крайне просты: вызов <code>string.len(s)</code> возвращает длину строки <code>s</code>. Она эквивалентна <code>#s</code>. Вызов <code>string.rep(s, n)</code> (или <code>s:rep(n)</code>) возвращает строку <code>s</code>, повторенную <code>n</code> раз. Вы можете создать строку в 1 Мб (например, для тестов) при помощи <code>string.rep("а", 2^20)</code>. Вызов <code>string.lower(s)</code> возвращает копию строки с заглавными буквами, замененными в строчные; все остальные символы не меняются (Функция <code>string.upper</code> переводит строчные буквы в заглавные.) В качестве примера, если вы хотите отсортировать строки вне зависимости от заглавных/строчных букв, вы можете использовать следующий фрагмент кода:</p>

<pre class="code">
<font color=8000FF>table.sort</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;a<font color=FF0000>:</font><font color=8000FF>lower</font><font color=FF0000>()</font>&nbsp;<font color=FF0000>&lt;</font>&nbsp;b<font color=FF0000>:</font><font color=8000FF>lower</font><font color=FF0000>()</font>
<font color=0000DF>end</font><font color=FF0000>)</font>
</pre>

<p>Вызов <code>string.sub(s,i,j)</code> возвращает подстроку <code>s</code>, начиная с <code>i</code>-гo символа и заканчивая <code>j</code>-м (включительно). В Lua первый символ строки имеет индекс <code>1</code>. Вы можете также использовать негативные индексы, которые отсчитываются от конца строки: индекс <code>-1</code> ссылается на последний символ строки, <code>-2</code> на предпоследний символ и т. д. Таким образом, вызов <code>string.sub(s, 1, j)</code>(или <code>s:sub(1, j)</code>) возвращает начало строки длиной в <code>j</code>; <code>string.sub(s, j,-1)</code> (или просто <code>s:sub(j)</code>, поскольку значением по умолчанию для последнего аргумента является <code>-1</code>) возвращает конец строки, начиная с <code>j</code>-го символа; и <code>string.sub(s, 2, -2)</code> возвращает копию строки <code>s</code>, в которой удалены первый и последний символы:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"[in&nbsp;brackets]"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>:</font><font color=8000FF>sub</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>2</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;in&nbsp;brackets</font>
</pre>

<p>Помните, что строки в Lua неизменяемы. Функция <code>string.sub</code>, как и любая другая функция в Lua, не изменяет значения строки, а возвращает новую строку. Типичной ошибкой является использовать что-то вроде <code>s:sub(2,-2)</code> и ожидать, что это изменит значение строки <code>s</code>. Если вы хотите изменить значение переменной, то вы должны присвоить ей новое значение:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;s<font color=FF0000>:</font><font color=8000FF>sub</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>2</font><font color=FF0000>)</font>
</pre>

<p>Функции <code>string.char</code> и <code>string.byte</code> переводят между символами и их внутренними числовыми представлениями. Функция <code>string.char</code> берет на вход целые числа, преобразует каждое из них в символ и возвращает строку, построенную из всех этих символов. Вызов <code>string.byte(s, i)</code> возвращает внутреннее числовое представление <code>i</code>-го символа строки <code>s</code>; второй аргумент необязателен, вызов <code>string.byte(s)</code> возвращает внутреннее числовое представление первого символа строки <code>s</code>. В следующих примерах мы считаем, что символы представлены кодировкой ASCII:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.char</font><font color=FF0000>(</font><font color=AC00A9>97</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;a</font>
i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>99</font><font color=FF0000>;</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.char</font><font color=FF0000>(</font>i<font color=FF0000>,</font>&nbsp;i<font color=FF0000>+</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;i<font color=FF0000>+</font><font color=AC00A9>2</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;cde</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.byte</font><font color=FF0000>(</font><font color=8888CC>"abc"</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;97</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.byte</font><font color=FF0000>(</font><font color=8888CC>"abc"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;98</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.byte</font><font color=FF0000>(</font><font color=8888CC>"abc"</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>1</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;99</font>
</pre>

<p>В последней строке мы использовали отрицательный индекс для обращения к последнему символу строки.</p>

<p>Начиная с Lua 5.1 функция <code>string.byte</code> поддерживает третий, необязательный аргумент. Вызов <code>string.byte(s, i, j)</code> возвращает численные представления сразу всех символов, находящихся между индексами <code>i</code> и <code>j</code> (включительно):</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.byte</font><font color=FF0000>(</font><font color=8888CC>"abc"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;97&nbsp;98</font>
</pre>

<p>Значением по умолчанию для <code>j</code> является <code>i</code>, поэтому вызов без третьего аргумента возвращает <code>i</code>-й символ. Вызов <code>{s:byte(1,-1)}</code> создает таблицу с кодами всех символов строки <code>s</code>. По этой таблице мы можем получить исходную строку при помощи вызова <code>string.char(table.unpack(t))</code>. Этот прием не работает для очень длинных строк (более 1 Мб), поскольку в Lua есть ограничение на число возвращаемых функцией значений.</p>

<p>Функция <code>string.format</code> является мощным инструментом для форматирования строк, обычно для вывода. Она возвращает отформатированную версию от своих аргументов (поддерживается произвольное число аргументов), используя описание, заданное своим первым аргументом, так называемой <i>строкой формата</i>. Для этой строки существуют правила, похожие на правила для функции <code>printf</code> из стандартной библиотеки языка С: она состоит из обычного текста и <i>указателей</i>, которые управляют, где и как поместить каждый аргумент в результирующей строке. Указатель состоит из символа <code>'%'</code>, за которым следует символ, задающий, как отформатировать аргумент: '<code>d</code>' для десятичных чисел, '<code>x</code>' для шестнадцатеричных чисел, '<code>о</code>' для восьмеричных, '<code>f</code>' для чисел с плавающей точкой, '<code>s</code>' для строк, также есть еще некоторые другие варианты. Между '<code>%</code>' и символом могут находиться другие опции, задающие форматирование, такие как число десятичных цифр для числа с плавающей точкой:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"pi&nbsp;=&nbsp;%.4f"</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.pi</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;pi&nbsp;=&nbsp;3.1416</font>
d&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>5</font><font color=FF0000>;</font>&nbsp;m&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>11</font><font color=FF0000>;</font>&nbsp;y&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1990</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%02d/%02d/%04d"</font><font color=FF0000>,</font>&nbsp;d<font color=FF0000>,</font>&nbsp;m<font color=FF0000>,</font>&nbsp;y<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;05/11/1990</font>
tag<font color=FF0000>,</font>&nbsp;title&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"h1"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"a&nbsp;title"</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"&lt;%s&gt;%s&lt;/%s&gt;"</font><font color=FF0000>,</font>&nbsp;tag<font color=FF0000>,</font>&nbsp;title<font color=FF0000>,</font>&nbsp;tag<font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;&lt;h1&gt;a&nbsp;title&lt;/h1&gt;</font>
</pre>

<p>В первом примере <code>%.4f</code> задает число с плавающей точкой с четырьмя цифрами после десятичной точки. Во втором примере <code>%02d</code> обозначает десятичное число как минимум из двух цифр, при необходимости дополненное нулями; <code>%2d</code> без нуля будет дополнять число пробелами. За полным описанием этих опций обратитесь к справочному руководству по Lua или обратитесь к руководству по языку С, так как Lua использует библиотеку языка С для выполнения всей тяжелой работы здесь.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="21.2. Функции для работы с шаблонами"></a>21.2. Функции для работы с шаблонами
</div>

<p>Наиболее мощными функциями в библиотеке для работы со строками являются функции <code>find</code>, match и <code>gsub</code> (глобальная подстановка) и <code>gmatch</code> (глобальный поиск). Они все основаны на шаблонах.</p>

<p>В отличие от ряда других скриптовых языков, Lua не использует для работы с шаблонами ни синтаксис POSIX, ни синтаксис из языка Perl. Основной причиной для этого решения является размер: типичная реализация регулярных выражений POSIX занимает более 4000 строк кода. Это больше размера всех стандартных библиотек Lua, взятых вместе. Для сравнения реализация работы с шаблонами в Lua занимает менее 600 строк. Конечно, реализация работы с шаблонами в Lua уступает полноценной реализации POSIX. Тем не менее работа с шаблонами в Lua является мощным инструментом и включает в себя некоторые возможности, которые трудно соотнести со стандартными реализациями POSIX.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="21.2. Функция string.find"></a>Функция string.find
</div>

<p>Функция <code>string.find</code> ищет заданный шаблон внутри строки. Простейшим случаем шаблона является слово, которое соответствует своей копии. Например, шаблон '<code>hello</code>' будет искать подстроку "<code>hello</code>" внутри всей заданной строки. При нахождении шаблона <code>find</code> возвращает два значения: индекс, начиная с которого начинается совпадение, и индекс, где совпадение заканчивается. Если совпадение не найдено, то возвращается <b>nil</b>.</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"hello&nbsp;world"</font>
i<font color=FF0000>,</font>&nbsp;j&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"hello"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>,</font>&nbsp;j<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;1&nbsp;5</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.sub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;i<font color=FF0000>,</font>&nbsp;j<font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;hello</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.find</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"world"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;7&nbsp;11</font>
i<font color=FF0000>,</font>&nbsp;j&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"l"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>,</font>&nbsp;j<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;3&nbsp;3</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.find</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"lll"</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;nil</font>
</pre>

<p>Когда поиск шаблона завершился успешно, то мы можем вызвать <code>string.sub</code> с возвращенными значениями, для того чтобы получить часть исходной строки, удовлетворяющей шаблону. Для простых шаблонов такой строкой будет сам шаблон.</p>

<p>У функции <code>string.find</code> есть необязательный третий параметр: индекс, задающий, с какого места внутри строки следует начать поиск.</p>

<p>Этот параметр оказывается полезным, когда мы хотим получить все вхождения шаблона: в этом случае мы вызываем функцию поиска неоднократно, каждый раз начиная поиск после позиции, в которой было найдено предыдущее совпадение. В качестве примера следующий код строит таблицу с позициями всех символов '<code>\n</code>' внутри строки:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;таблица&nbsp;для&nbsp;хранения&nbsp;индексов</font>
<font color=0000DF>local</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>,</font>&nbsp;i<font color=FF0000>+</font><font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;ищем&nbsp;следующее&nbsp;вхождение</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;i&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;t<font color=FF0000>[#</font>t&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;i
<font color=0000DF>end</font>
</pre>

<p>Позже мы увидим более простой способ записи подобных циклов, используя итератор <code>string.gmatch</code>.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="21.2. Функция string.match"></a>Функция string.match
</div>

<p>Функция <code>string.match</code> похожа на <code>string.find</code> в том смысле, что она также ищет вхождения шаблона в строке. Однако, вместо того чтобы возвращать позиции, где был найден шаблон, она возвращает часть строки, удовлетворяющую шаблону:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.match</font><font color=FF0000>(</font><font color=8888CC>"hello&nbsp;world"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"hello"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;hello</font>
</pre>

<p>Для простых шаблонов вроде '<code>hello</code>' эта функция не имеет смысла. Она показывает свою мощь, когда используется со сложными шаблонами, как в следующем примере:</p>

<pre class="code">
date&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Today&nbsp;is&nbsp;17/7/1990"</font>
d&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.match</font><font color=FF0000>(</font>date<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%d+/%d+/%d+"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>d<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;17/7/1990</font>
</pre>

<p>Вскоре мы обсудим как значение шаблона '<code>%d+/%d+/%d+</code>', так и более сложное использование <code>string.match</code>.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="21.2. Функция string.gsub"></a>Функция string.gsub
</div>

<p>Функция <code>string.gsub</code> имеет три обязательных параметра: строку, шаблон и строку для замены. Она используется для замены всех вхождений шаблона в исходную строку на заданную строку:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"Lua&nbsp;is&nbsp;cute"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"cute"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"great"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;Lua&nbsp;is&nbsp;great</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"all&nbsp;lii"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"l"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"x"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;axx&nbsp;xii</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"Lua&nbsp;is&nbsp;great"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Sol"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Sun"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;Lua&nbsp;is&nbsp;great</font>
</pre>

<p>Необязательный четвертый параметр ограничивает число выполняемых замен:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"all&nbsp;lii"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"l"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"x"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;axl&nbsp;lii</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"all&nbsp;lii"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"l"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"x"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;axx&nbsp;lii</font>
</pre>

<p>Функция <code>string.gsub</code> также возвращает в качестве второго значения число выполненных замен. Например, простым способом посчитать число пробелов в строке является</p>

<pre class="code">
count&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>select</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>str<font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;"</font><font color=FF0000>))</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="21.2. Функция string.gmatch"></a>Функция string.gmatch
</div>

<p>Функция <code>string.gmatch</code> возвращает функцию, которая перебирает все вхождения шаблона в строку. Например, следующий пример собирает все слова в заданной строке <code>s</code>:</p>

<pre class="code">
words&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%a+"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;words<font color=FF0000>[#</font>words&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;w
<font color=0000DF>end</font>
</pre>

<p>Как мы вскоре обсудим, шаблон '<code>%а+</code>' соответствует вхождению одного или большего числа букв (то есть слов). Поэтому цикл обойдет все слова внутри строки, запоминая их в таблице <code>words</code>.</p>

<p>Следующий пример реализует функцию, аналогичную <code>package.searchpath</code>, при помощи <code>gmatch</code> и <code>gsub</code>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;search&nbsp;<font color=FF0000>(</font>modname<font color=FF0000>,</font>&nbsp;path<font color=FF0000>)</font>
&nbsp;&nbsp;modname&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>modname<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%."</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"/"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;c&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>path<font color=FF0000>,</font>&nbsp;<font color=8888CC>"[^;]+"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;fname&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>c<font color=FF0000>,</font>&nbsp;<font color=8888CC>"?"</font><font color=FF0000>,</font>&nbsp;modname<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.open</font><font color=FF0000>(</font>fname<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;f&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f<font color=FF0000>:</font><font color=FF8000>close</font><font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;fname
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=008000>--&nbsp;не&nbsp;найдено</font>
<font color=0000DF>end</font>
</pre>

<p>Первым шагом будет замена всех точек на разделитель в пути, который считается равным '<code>\</code>'.(Как мы увидим далее, точка имеет специальное значение в шаблонах. Для сопоставления с точкой мы должны записать '<code>%.</code>'). Далее функция перебирает все компоненты пути, где для каждой компоненты выполняется замена всех вопросительных знаков на имя модуля и проверяется, существует ли такой файл. Если да, то функция закрывает этот файл и возвращает его имя.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="21.3. Шаблоны"></a>21.3. Шаблоны
</div>

<p>Вы можете сделать шаблоны более полезными при помощи <i>классов символов</i>. Класс символов - это элемент в шаблоне, который может соответствовать любому символу из заданного множества. Например, класс <code>%d</code> соответствует любой цифре. Следовательно, можно искать дату в формате <code>dd/mm/yyyy</code> при помощи шаблона <code>%d%d/%d%d/%d%d%d%d</code>:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Deadline&nbsp;is&nbsp;30/05/1999,&nbsp;firm"</font>
date&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"%d%d/%d%d/%d%d%d%d"</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.sub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;date<font color=FF0000>)))</font>&nbsp;<font color=008000>--&gt;&nbsp;30/05/1999</font>
</pre>

<p>Следующая таблица содержит список всех классов символов:</p>

<table>
  <tr>
    <td width="10%"><code>.</code></td>
    <td><i>Все символы (точка)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%а</code></td>
    <td><i>Буквы</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%с</code></td>
    <td><i>Управляющие символы</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%d</code></td>
    <td><i>Цифры</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%g</code></td>
    <td><i>Печатные символы, кроме пробела</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%l</code></td>
    <td><i>Строчные буквы</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%р</code></td>
    <td><i>Символы пунктуации</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%s</code></td>
    <td><i>Пробельные символы</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%u</code></td>
    <td><i>Строчные буквы</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%w</code></td>
    <td><i>Буквы и цифры</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%x</code></td>
    <td><i>Шестнадцатсрипиые цифры</i></td>
  </tr>
</table>

<p>Если в качестве имени класса использовать соответствующую заглавную букву, то она соответствует дополнению класса (то есть всем символам, не входящим в класс). Например, '<code>%А</code>' соответствует всем небуквам:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"hello,&nbsp;up-down!"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%A"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"."</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;hello..up.down.&nbsp;4</font>
</pre>

<p>(<code>4</code> не являются частью результирующей строки. Это второе значение, возвращаемое <code>gsub</code>, полное число выполненных замен. Я буду далее опускать это число в следующих примерах, печатающих результат вызова <code>gsub</code>.)</p>

<p>Некоторые символы, называемые <i>магическими символами</i>, имеют специальное значение внутри шаблона. Магическими символами являются</p>

<pre class="code"><font color=FF0000>(</font>&nbsp;&nbsp;<font color=FF0000>)</font>&nbsp;&nbsp;<font color=FF0000>.</font>&nbsp;&nbsp;<font color=FF0000>%</font>&nbsp;&nbsp;<font color=FF0000>+</font>&nbsp;&nbsp;<font color=FF0000>-</font>&nbsp;&nbsp;<font color=FF0000>*</font>&nbsp;&nbsp;?&nbsp;&nbsp;<font color=FF0000>[</font>&nbsp;&nbsp;<font color=FF0000>]</font>&nbsp;&nbsp;<font color=FF0000>^</font>&nbsp;&nbsp;$</pre>

<p>Символ '<code>%</code>' используется для вставки этих символов в шаблон. Так, '<code>%.</code>' соответствует точке; '<code>%%</code>' соответствует самому символу '<code>%</code>'. Вы можете использовать подобным образом '<code>%</code>' не только с магическими символами, но и с любыми не алфавитно-цифровыми символами. Когда сомневаетесь, лучше используйте '<code>%</code>'.</p>

<p>Для парсера Lua шаблоны - это просто обычные строки. Они подчиняются тем же правилам, что и остальные строки. Только функции для работы с шаблонами рассматривают их как шаблоны, и только эти функции используют специальное значение символа '<code>%</code>'. Для помещения кавычек внутрь шаблона используются те же самые приемы, что используются для помещения кавычек внутри других строк.</p>

<p>Вы также можете создавать свои классы, группируя при этом различные классы и символы внутри квадратных скобок. Например, класс '<code>[%w_]</code>' соответствует алфавитно-цифровым символам и символу подчеркивания; класс '<code>[01]</code>' соответствует двоичным цифрам; класс '<code>[%[%]]</code>' соответствует квадратным скобкам. Для того чтобы посчитать число гласных в тексте, вы можете использовать следующий код:</p>

<pre class="code">
nvow&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>select</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>text<font color=FF0000>,</font>&nbsp;<font color=8888CC>"[AEIOUaeiou]"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>""</font><font color=FF0000>))</font>
</pre>

<p>В подобные классы вы можете также включать диапазоны символов, записывая первый и последний символы, разделенные знаком минус. Я редко этим пользуюсь, поскольку все наиболее часто используемые диапазоны уже определены; например, '<code>[0-9]</code>' - это то же самое, что и '<code>%d</code>', а '<code>[0-9a-fA-F]</code>' - это то же самое, что и '<code>%х</code>'. Однако если вам понадобятся восьмеричные цифры, то вы можете использовать '<code>[0-7]</code>' вместо '<code>[01234567]</code>', вы также можете получить дополнение любого класса, поставив в начале символ '<code>^</code>: так, шаблон '<code>[^0-7]</code>' находит любой символ, который не является восьмеричной цифрой, а '<code>[^\n]</code>' соответствует любому символу, отличному от '<code>\n</code>'. Однако помните, что для встроенных классов гораздо проще использовать вариант с большой буквой: '<code>%S</code>' проще, чем '<code>[^%s]</code>'.</p>

<p>Шаблоны могут стать более полезными, если использовать модификаторы для задания числа повторений и необязательных частей. Шаблоны в Lua предлагают четыре таких модификатора:</p>

<table>
  <tr>
    <td width="10%"><code>+</code></td>
    <td><i>1 или более повторений</i></td>
  </tr>
  <tr>
    <td width="10%"><code>*</code></td>
    <td><i>0 или более повторений</i></td>
  </tr>
  <tr>
    <td width="10%"><code>-</code></td>
    <td><i>0 или более коротких повторений</i></td>
  </tr>
  <tr>
    <td width="10%"><code>?</code></td>
    <td><i>Необязательно (0 или 1 раз)</i></td>
  </tr>
</table>

<p>Модификатор '<code>+</code>' соответствует одному или большему числу символов заданного класса. Он всегда вернет самое длинное вхождение шаблона. Например, шаблон '<code>%а+</code>' обозначает одну или более букв, то есть слово:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"one,&nbsp;and&nbsp;two;&nbsp;and&nbsp;three"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%a+"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"word"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;word,&nbsp;word&nbsp;word;&nbsp;word&nbsp;word</font>
</pre>

<p>Шаблон '<code>%d+</code>' соответствует одной или большему числу цифр (целому числу без знака):</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.match</font><font color=FF0000>(</font><font color=8888CC>"the&nbsp;number&nbsp;1298&nbsp;is&nbsp;even"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%d+"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;1298</font>
</pre>

<p>Модификатор '<code>*</code>' похож на '<code>+</code>' но он также допускает нулевое число вхождений символов из данного класса. Часто используется для обозначения необязательных пробелов между частями шаблона. Например, для шаблона, соответствующего паре скобок (возможно, с пробелами между ними), можно использовать следующий шаблон: '<code>%(%s*%)</code>': шаблон '<code>%s*</code>' соответствует нулю или большему числу пробелов между скобками (Скобки также имеют специальное значение в шаблонах, поэтому мы их задаем, используя символ '<code>%</code>'.) В качестве другого примера шаблон '<code>[_%а][_%w]*</code>' соответствует идентификаторам внутри программы на Lua: начинается с пробела или подчеркивания, за которым идет ноль или большее количество подчеркиваний и алфавитно-цифровых символов.</p>

<p>Подобно '<code>*</code>', модификатор '<code>-</code>' также соответствует нулю или большему количеству символов заданного класса. Однако вместо соответствия самой длинной последовательности он соответствует самой короткой последовательности. Иногда между ними нет никакой разницы, но обычно они дают разные результаты. Например, если вы попытаетесь найти идентификатор при помощи шаблона '<code>[_%а][_%а]-</code>', то вы получите только первый символ идентификатора, поскольку '<code>[_%а]-</code>' соответствует пустой последовательности. С другой стороны, допустим, вы хотите найти комментарии в программе на С. Большинство попытается использовать шаблон '<code>/%*.*%*/</code>' (то есть "<code>/*</code>", за которым следует любая последовательность символов, за которой следует "<code>*/</code>"). Однако поскольку '<code>.*</code>' будет пытаться соответствовать наибольшему количеству символов, то первый "<code>/*</code>" закроется только самым последним "<code>*/</code>" в программе:</p>

<pre class="code">
test&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"int&nbsp;x;&nbsp;/*&nbsp;x&nbsp;*/&nbsp;int&nbsp;y;&nbsp;/*&nbsp;y&nbsp;*/"</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.match</font><font color=FF0000>(</font>test<font color=FF0000>,</font>&nbsp;<font color=8888CC>"/%*.*%*/"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;/*&nbsp;x&nbsp;*/&nbsp;int&nbsp;y;&nbsp;/*&nbsp;y&nbsp;*/</font>
</pre>

<p>Шаблон '<code>.-</code>' захватит наименьшее количество символов, необходимое для первого "<code>*/</code>", и даст, таким образом, желаемый результат:</p>

<pre class="code">
test&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"int&nbsp;x;&nbsp;/*&nbsp;x&nbsp;*/&nbsp;int&nbsp;y;&nbsp;/*&nbsp;y&nbsp;*/"</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>test<font color=FF0000>,</font>&nbsp;<font color=8888CC>"/%*.-%*/"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>""</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;int&nbsp;x;&nbsp;int&nbsp;y;</font>
</pre>

<p>Последний модификатор '<code>?</code>' соответствует необязательно присутствующему символу. Например, пусть мы хотим найти число в тексте, которое может содержать необязательный знак. Шаблон '<code>[+-]?%d+</code>' успешно справляется с работой, находя такие последовательности, как "<code>-12</code>", "<code>23</code>" и "<code>+1009</code>". Класс '<code>[+-]</code>' соответствует либо символу '<code>+</code>', либо символу '<code>-</code>'; следующий за ним знак '<code>?</code>' делает этот символ необязательным.</p>

<p>В отличие от других систем, в Lua модификатор может быть применен только к классу символов. Нельзя группировать шаблоны под одним знаком модификатора. Например, нет шаблона, соответствующего необязательному слову (если только оно не состоит из одного символа). Обычно это ограничение можно обойти при помощи продвинутых приемов, которые мы увидим в конце этой главы.</p>

<p>Если шаблон начинается с символа '<code>^</code>', то он будет сопоставляться только с началом строки. Аналогично если шаблон заканчивается символом '<code>$</code>', то он будет сопоставляться только с концом строки. Вы можете использовать оба этих символа для создания шаблонов. Например, следующий тест проверяет, начинается ли строка с цифры:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"^%d"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=FF0000>...</font>
</pre>

<p>Следующий тест проверяет, что строка является числом, без других символов в начале или конце:</p>

<pre class="code">
<font color=0000DF>if</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"^[+-]?%d+$"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=FF0000>...</font>
</pre>

<p>Символы '<code>^</code>' и '<code>$</code>' обладают этим смыслом, только когда встречаются соответственно в начале или в конце строки. Иначе они выступают как обычные символы.</p>

<p>Другим элементом в шаблоне является '<code>%b</code>'. Мы записываем его как '<code>%bху</code>', где <code>х</code> и <code>у</code> - это два различных символа; символ <code>х</code> выступает как открывающий символ, а <code>у</code> -- как закрывающий. Например, шаблон '<code>%b()</code>' соответствует части строки, которая начинается с '<code>(</code>' и заканчивается '<code>)</code>':</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a&nbsp;(enclosed&nbsp;(in)&nbsp;parentheses)&nbsp;line"</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%b()"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>""</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;a&nbsp;line</font>
</pre>

<p>Обычно мы используем этот шаблон в виде '<code>%b()</code>', '<code>%b[]</code>', '<code>%b{}</code>' или '<code>%b&lt;&gt;</code>', но вы можете использовать в качестве разделителей любые символы.</p>

<p>Наконец, элемент '<code>%f[char-set]</code>' является <i>паттерном границы</i>. Он определяет место, в котором следующий символ содержится в классе <code>char-set</code>, а предыдущий - нет:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"the&nbsp;anthem&nbsp;is&nbsp;the&nbsp;theme"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>:</font><font color=8000FF>gsub</font><font color=FF0000>(</font><font color=8888CC>"%f[%w]the%f[%W]"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"one"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;one&nbsp;anthem&nbsp;is&nbsp;one&nbsp;theme</font>
</pre>

<p>Шаблон '<code>%f[%w]</code>' соответствует границе между неалфавитно-цифровым и алфавитно-цифровым символами, и шаблон '<code>%f[%W]</code>' соответствует границе между алфавитно-цифровым символом и неалфавитно-цифровым символом. Поэтому заданный шаблон соответствует строке "<code>the</code>" как целому слову. Обратите внимание, что множество символов мы должны записать внутри квадратных скобок, даже когда это всего один класс.</p>

<p>Положения перед первым и после последнего трактуются как содержащие символ с кодом <code>0</code>. В предыдущем примере первое "<code>the</code>" начинается с границы между нулевым символом(не в классе '<code>[%w]</code>') и '<code>t</code>'(в классе '<code>[%w]</code>')-</p>

<p>Шаблон границы был реализован в Lua 5.1, но не документирован. Официальным он стал только в Lua 5.2.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="21.4. Захваты"></a>21.4. Захваты
</div>

<p>Механизм <i>захвата</i> позволяет шаблону запомнить части строки, удовлетворяющие частям шаблона для последующего использования. Вы можете указать захват, записав части шаблона, которые вы хотите захватить, внутри круглых скобок.</p>

<p>Когда в шаблоне есть захваты, то функция <code>string.match</code> возвращает каждое захваченное значение как отдельный результат; другими словами, она разбивает строку на ее захваченные части.</p>

<pre class="code">
pair&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"name&nbsp;=&nbsp;Anna"</font>
key<font color=FF0000>,</font>&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.match</font><font color=FF0000>(</font>pair<font color=FF0000>,</font>&nbsp;<font color=8888CC>"(%a+)%s*=%s*(%a+)"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>key<font color=FF0000>,</font>&nbsp;value<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;name&nbsp;Anna</font>
</pre>

<p>Шаблон '<code>%a+</code>' задает непустую последовательность букв;. Шаблон '<code>%s*</code>' задает, возможно, пустую, последовательность пробелов. Поэтому в примере выше весь шаблон задает последовательность букв, за которой следует последовательность пробелов, за которой следует знак равенства '<code>=</code>', за которой опять следует последовательность пробелов, за которой следует другая последовательность букв. У обеих последовательностей букв их соответствующие шаблоны заключены в круглые скобки, поэтому они будут захвачены при соответствии. Ниже приводится похожий пример:</p>

<pre class="code">
date&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Today&nbsp;is&nbsp;17/7/1990"</font>
d<font color=FF0000>,</font>&nbsp;m<font color=FF0000>,</font>&nbsp;y&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.match</font><font color=FF0000>(</font>date<font color=FF0000>,</font>&nbsp;<font color=8888CC>"(%d+)/(%d+)/(%d+)"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>d<font color=FF0000>,</font>&nbsp;m<font color=FF0000>,</font>&nbsp;y<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;17&nbsp;7&nbsp;1990</font>
</pre>

<p>Внутри шаблона элемент '<code>%d</code>', где <code>d</code>-это цифра, соответствует копии <code>d</code>-ой захваченной строки. В качестве примера рассмотрим случай, когда вы хотите внутри строки найти подстроку, заключенную в обычные или двойные кавычки. Вы можете попробовать шаблон '<code>["'].-["']</code>'&gt; то есть кавычка, за которой следует что угодно, за которым следует другая кавычка; но при этом у вас будут проблемы со строками вроде "<code>it's all right</code>". Для решения этой проблемы мы можем захватить первую кавычку и использовать ее для задания второй кавычки:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>[[then&nbsp;he&nbsp;said:&nbsp;"it's&nbsp;all&nbsp;right"!]]</font>
q<font color=FF0000>,</font>&nbsp;quotedPart&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.match</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"([\"'])(.-)%1"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>quotedPart<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;it's&nbsp;all&nbsp;right</font>
<font color=0080C0>print</font><font color=FF0000>(</font>q<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;"</font>
</pre>

<p>Первое захваченное значение - это сам символ кавычки, и второе захваченное значение - это подстрока между кавычками (подстрока, удовлетворяющая '<code>.-</code>').</p>

<p>В качестве другого похолсего примера мы можем взять шаблон, соответствующий длинным строкам в Lua:</p>

<pre class="code"><font color=8888CC>"%[(=*)%[(.-)%]%1%]"</font></pre>

<p>Он соответствует открывающей квадратной скобке, за которой следует ноль или большее число знаков равенства, за которой следует другая открывающая квадратная скобка, за которой следует что угодно (сама строка), за которой следует закрывающая квадратная скобка, за которой следует то же самое количество знаков равенства, за которой следует еще одна закрывающая квадратная скобка:</p>

<pre class="code">
p&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"%[(=*)%[(.-)%]%1%]"</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a&nbsp;=&nbsp;[=[[[&nbsp;something&nbsp;]]&nbsp;]==]&nbsp;]=];&nbsp;print(a)"</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.match</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;p<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;=&nbsp;[[&nbsp;something&nbsp;]]&nbsp;]==]</font>
</pre>

<p>Первый захват - это последовательность знаков равенства (в примере только один знак); второе захваченное значение - это сама строка.</p>

<p>Также захваченные значения могут использоваться в заменяющей строке в <code>gsub</code>. Как и шаблон, заменяющая строка может содержать элементы '<code>%d</code>', которые заменяются на соответствующие захваченные значения при выполнении подстановки. В частности, элемент '<code>%0</code>' соответствует всей части строки, удовлетворяющей шаблону (Обратите внимание, что символ '<code>%</code>' в строке замены должен записываться как '<code>%%</code>'.) Еще один пример:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"hello&nbsp;Lua!"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%a"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%0-%0"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;h-he-el-ll-lo-o&nbsp;L-Lu-ua-a!</font>
</pre>

<p>Следующий пример переставляет соседние символы:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font><font color=8888CC>"hello&nbsp;Lua"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"(.)(.)"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%2%1"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;ehll&nbsp;ouLa</font></pre>

<p>В качестве более полезного примера давайте напишем простой преобразователь формата, который получает на вход строку с командами в стиле <i>LaTeX</i> и переводит их в <i>XML</i>-формат:</p>

<pre class="code">\command{some text} --&gt; <command>some text</command></pre>

<p>Если мы запретим вложенные команды, то следующий вызов <code>string.gsub</code> выполняет работу:</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>[[the&nbsp;\quote{task}&nbsp;is&nbsp;to&nbsp;\em{change}&nbsp;that.]]</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\\(%a+){(.-)}"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"&lt;%1&gt;%2&lt;/%1&gt;"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>)</font>
<font color=008000>--&gt;&nbsp;the&nbsp;&lt;quote&gt;task&lt;/quote&gt;&nbsp;is&nbsp;to&nbsp;&lt;em&gt;change&lt;/em&gt;&nbsp;that.</font>
</pre>

<p>(Далее мы увидим, как обрабатывать вложенные команды.)</b><br>
Другим полезным примером является удаление пробелов из начала и конца строки:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;trim&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"^%s*(.-)%s*$"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%1"</font><font color=FF0000>))</font>
<font color=0000DF>end</font>
</pre>

<p>Обратите внимание на аккуратное использование форматов. Два якоря ('<code>^</code>' и '<code>$</code>') гарантируют, что мы получим всю строку. Поскольку '<code>.-</code>' старается выбрать самую короткую строку, то два шаблона '<code>%s*</code>' захватывают все пробелы по краям. Также обратите внимание, что поскольку <code>gsub</code> возвращает два значения, то мы используем круглые скобки для отбрасывания лишнего (числа замен).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="21.5. Замены"></a>21.5. Замены
</div>

<p>Вместо строки в качестве третьего аргумента <code>string.gsub</code> мы можем использовать функцию или таблицу. При использовании функции <code>string.gsub</code> вызывает функцию каждый раз, когда находит удовлетворяющую шаблону подстроку. Аргументами каждого вызова являются захваченные значения, и возвращенное функцией значение используется в качестве заменяющей строки. Когда третьим аргументом является таблица, функция <code>string.gsub</code> обращается в таблицу, используя первое захваченное значение как ключ и полученное значение из таблицы как заменяющую строку. Если полученное от функции или таблицы значение - это <b>nil</b>, то для данного совпадения замены не производится.</p>

<p>В качестве первого примера рассмотрим выполнение простой подстановки - каждое вхождение <code>$varName</code> заменяется на значение глобальной переменной <code>varName</code>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;expand&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"$(%w+)"</font><font color=FF0000>,</font>&nbsp;<font color=0080C0>_G</font><font color=FF0000>))</font>
<font color=0000DF>end</font>
name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Lua"</font><font color=FF0000>;</font>&nbsp;status&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"great"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>expand<font color=FF0000>(</font><font color=8888CC>"$name&nbsp;is&nbsp;$status,&nbsp;isn't&nbsp;it?"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;Lua&nbsp;is&nbsp;great,&nbsp;isn't&nbsp;it?</font>
</pre>

<p>Для каждого совпадения с шаблоном '<code>$(%w+)</code>' (знак доллара, за которым следует имя переменной) функция <code>gsub</code> ищет соответствующую переменную в <code>_G</code>, найденное значение заменяет вхождение шаблона в строку. Когда в таблице пет соответствующей переменной, то замены не производится:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>expand<font color=FF0000>(</font><font color=8888CC>"$othername&nbsp;is&nbsp;$status,&nbsp;isn't&nbsp;it?"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;$othername&nbsp;is&nbsp;great,&nbsp;isn't&nbsp;it?</font>
</pre>

<p>Если вы не уверены в том, что соответствующие переменные имеют строковые значения, то вы можете попробовать применить <code>tostring</code> к этим значениям. В этом случае в качестве заменяющего значения вы можете использовать функцию:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;expand&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"$(%w+)"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>n<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=0080C0>tostring</font><font color=FF0000>(</font><font color=0080C0>_G</font><font color=FF0000>[</font>n<font color=FF0000>])</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>))</font>
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>expand<font color=FF0000>(</font><font color=8888CC>"print&nbsp;=&nbsp;$print;&nbsp;a&nbsp;=&nbsp;$a"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;print&nbsp;=&nbsp;function:&nbsp;0x8050ce0;&nbsp;a&nbsp;=&nbsp;nil</font>
</pre>

<p>Теперь для каждого совпадения с шаблоном '<code>$(%w+)</code>' <code>gsub</code> вызывает заданную функцию, передавая имя как аргумент; функция возвращает значение для замены.</p>

<p>В последнем примере мы возвращаемся к преобразованию формата команд. Мы опять хотим преобразовывать команды из стиля LaTeX'a (<code>\example{text}</code>) в стиль XML (<code>&lt;example&gt;text&lt;/example&gt;</code>), но на этот раз мы будем обрабатывать вложенные команды. Следующая функция использует рекурсию для решения нашей задачи:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;toxml&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\\(%a+)(%b{})"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>tag<font color=FF0000>,</font>&nbsp;body<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.sub</font><font color=FF0000>(</font>body<font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=FF0000>-</font><font color=AC00A9>2</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;remove&nbsp;brackets</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;<font color=FF0000>=</font>&nbsp;toxml<font color=FF0000>(</font>body<font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;handle&nbsp;nested&nbsp;commands</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"&lt;%s&gt;%s&lt;/%s&gt;"</font><font color=FF0000>,</font>&nbsp;tag<font color=FF0000>,</font>&nbsp;body<font color=FF0000>,</font>&nbsp;tag<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>toxml<font color=FF0000>(</font><font color=8888CC>"\\title{The&nbsp;\\bold{big}&nbsp;example}"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;&lt;title&gt;The&nbsp;&lt;bold&gt;big&lt;/bold&gt;&nbsp;example&lt;/title&gt;</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="21.5. Кодировка URL"></a>Кодировка URL
</div>

<p>Для нашего следующего примера мы будем использовать <i>кодирование URL</i>, которое применяется <i>HTTP</i> для передачи параметров в <i>URL</i>. Это кодирование заменяет специальные символы (такие как, '<code>=</code>', '<code>&middot;</code>' и '<code>+</code>') на '<code>%хх</code>', где <code>хх</code> - это шестнадцатеричный код символа. После этого он заменяет пробелы на '<code>+</code>'. Например, строка "<code>а+b = с</code>" будет закодирована как "<code>a%2Bb+%3D+c</code>". Также имя каждого параметра и его значение со знаком равенства между ними добавляются к итоговой строке, переменные отделяются друг от друга символом '<code>&middot;</code>'. Например, значения</p>

<pre class="code">
name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"al"</font><font color=FF0000>;</font>&nbsp;query&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a+b&nbsp;=&nbsp;c"</font><font color=FF0000>;</font>&nbsp;q<font color=FF0000>=</font><font color=8888CC>"yes&nbsp;or&nbsp;no"</font>
</pre>

<p>будут закодированы как "<code>name=al&middot;query=a%2Bb+%3D+c&middot;q=yes+or+no</code>".</p>

<p>Теперь пусть мы хотим раскодировать такой URL и записать каждое значение в таблицу по своему имени. Следующая функция выполняет подобное декодирование:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;unescape&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"+"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;"</font><font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%%(%x%x)"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>h<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.char</font><font color=FF0000>(</font><font color=0080C0>tonumber</font><font color=FF0000>(</font>h<font color=FF0000>,</font>&nbsp;<font color=AC00A9>16</font><font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s
<font color=0000DF>end</font>
</pre>

<p>Первый оператор заменяет каждый '<code>+</code>' на пробел. Второй находит закодированные шестнадцатеричным представлением символы и для каждого такого символа вызывает анонимную функцию. Эта функция переводит шестнадцатеричное представление в число (<code>tonumber</code> по основанию <code>16</code>) и возвращает соответствующий символ(<code>string.char</code>). Например:</p>

<pre class="code"><font color=0080C0>print</font><font color=FF0000>(</font>unescape<font color=FF0000>(</font><font color=8888CC>"a%2Bb+%3D+c"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;a+b&nbsp;=&nbsp;c</font></pre>

<p>Для декодирования пар <code>name=value</code> мы используем функцию <code>gmatch</code>. Поскольку и имя, и значение не могут содержать символов '<code>&middot;</code>' и '<code>=</code>', то мы можем использовать шаблон '<code>[^&middot;=]+</code>':</p>

<pre class="code">
cgi&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>function</font>&nbsp;decode&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;name<font color=FF0000>,</font>&nbsp;value&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"([^&=]+)=([^&=]+)"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;<font color=FF0000>=</font>&nbsp;unescape<font color=FF0000>(</font>name<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;unescape<font color=FF0000>(</font>value<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;cgi<font color=FF0000>[</font>name<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;value
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Вызов функции <code>gmatch</code> находит пары вида <code>name=value</code>. Для каждой такой пары итератор возвращает захваченные значения (выделенные скобками в шаблоне) как значения поля <code>name</code> и <code>value</code>. Тело цикла просто вызывает <code>unsecape</code> для обеих этих строк и записывает соответствующую пару в таблицу <code>cgi</code>.</p>

<p>Также легко записать и соответствующее кодирование. Для начала мы напишем функцию <code>escape</code>. Эта функция кодирует все специальные символы как '<code>%</code>', за которым следует шестнадцатеричный код символа (для функции <code>format</code> используется опция "<code>%02Х</code>", гарантирующая получение строки из двух цифр), и затем заменяет пробелы на символ '<code>+</code>':</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;escape&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"[&=+%%%c]"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>c<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%%%02X"</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.byte</font><font color=FF0000>(</font>c<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"+"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s
<font color=0000DF>end</font>
</pre>

<p>Функция <code>encode</code> обходит всю таблицу, которую нужно закодировать, и строит получающуюся строку:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;encode&nbsp;<font color=FF0000>(</font>t<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;b&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;k<font color=FF0000>,</font>v&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;b<font color=FF0000>[#</font>b&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>escape<font color=FF0000>(</font>k<font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"="</font>&nbsp;<font color=FF0000>..</font>&nbsp;escape<font color=FF0000>(</font>v<font color=FF0000>))</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>table.concat</font><font color=FF0000>(</font>b<font color=FF0000>,</font>&nbsp;<font color=8888CC>"&"</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{</font>name&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"al"</font><font color=FF0000>,</font>&nbsp;query&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"a+b&nbsp;=&nbsp;c"</font><font color=FF0000>,</font>&nbsp;q&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"yes&nbsp;or&nbsp;no"</font><font color=FF0000>}</font>
<font color=0080C0>print</font><font color=FF0000>(</font>encode<font color=FF0000>(</font>t<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;q=yes+or+no&query=a%2Bb+%3D+c&name=al</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="21.5. Замена табов"></a>Замена табов
</div>

<p>Пустой захват '<code>()</code>' в Lua имеет специальное значение. Вместо того чтобы не захватывать ничего (что совершенно не нужно), этот шаблон захватывает текущее положение внутри строки как число:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.match</font><font color=FF0000>(</font><font color=8888CC>"hello"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"()ll()"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;3&nbsp;5</font>
</pre>

<p>(Обратите внимание, что результат этого примера отличается от вызова <code>string.find</code>, поскольку положение второго захваченного значения идет после найденного шаблона.)</p>

<p>Красивым примером использования этой возможности является замена символов табуляции соответствующим числом пробелов:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;expandTabs&nbsp;<font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;tab<font color=FF0000>)</font>
&nbsp;&nbsp;tab&nbsp;<font color=FF0000>=</font>&nbsp;tab&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>8</font>&nbsp;<font color=008000>--&nbsp;размер&nbsp;таба(по-умолчанию&nbsp;8)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;corr&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"()\t"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>p<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;sp&nbsp;<font color=FF0000>=</font>&nbsp;tab&nbsp;<font color=FF0000>-</font>&nbsp;<font color=FF0000>(</font>p&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=FF0000>+</font>&nbsp;corr<font color=FF0000>)%</font>tab
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corr&nbsp;<font color=FF0000>=</font>&nbsp;corr&nbsp;<font color=FF0000>-</font>&nbsp;<font color=AC00A9>1</font>&nbsp;<font color=FF0000>+</font>&nbsp;sp
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.rep</font><font color=FF0000>(</font><font color=8888CC>"&nbsp;"</font><font color=FF0000>,</font>&nbsp;sp<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s
<font color=0000DF>end</font>
</pre>

<p>Вызов <code>gsub</code> находит все символы табуляции внутри строки, захватывая их положение. Для каждого символа табуляции внутренняя функция использует это положение, для того чтобы вычислить количество пробелов, которое нужно, чтобы получить позицию, являющуюся кратной значению <code>tab</code>. Она сначала вычитает один для перевода позиции, начиная с нуля, и затем добавляет <code>corr</code> для учета ранее встреченных табов (замена каждого символа табуляции влияет на положения последующих символов). Затем вычисляется поправка для следующего символа табуляции: минус один для удаляемого таба плюс <code>sp</code> для учета добавляемых пробелов. Наконец, она возвращает строку с соответствующим числом пробелов.</p>

<p>Для полноты давайте рассмотрим, как можно обратить эту операцию, заменяя пробелы символами табуляции. На первый взгляд также можно использовать пустые захваты для работы с положениями внутри строки, но существует более простое решение. На каждом восьмом символе мы будем вставлять пометку внутрь строки. Затем, когда перед этой пометкой идут пробелы, мы будем заменять соответствующую последовательность символом табуляции:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;unexpandTabs&nbsp;<font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;tab<font color=FF0000>)</font>
&nbsp;&nbsp;tab&nbsp;<font color=FF0000>=</font>&nbsp;tab&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>8</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;expandTabs<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;pat&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.rep</font><font color=FF0000>(</font><font color=8888CC>"."</font><font color=FF0000>,</font>&nbsp;tab<font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;pat<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%0\1"</font><font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;+\1"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"\t"</font><font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\1"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>""</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s
<font color=0000DF>end</font>
</pre>

<p>Эта функция начинает свою работу с замены всех имеющихся символов табуляции на пробелы. Затем она строит вспомогательный шаблон и использует его для добавления пометки (управляющего символа <code>\l</code>) после каждых <code>tab</code> символов. Далее все последовательности пробелов, за которыми следует пометка, заменяются на символ табуляции. Наконец, все пометки удаляются.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="21.6. Хитрые приемы"></a>21.6. Хитрые приемы
</div>

<p>Шаблоны - это очень мощный инструмент для работы со строками. Вы можете выполнить много сложных операций всего несколькими вызовами <code>string.gsub</code>. Однако, как и всякую другую силу, ее надо использовать аккуратно.</p>

<p>Использование шаблонов не заменяет парсер. Для быстрых решений (<i>quick-and-dirty</i>) вы можете использовать шаблоны для работы с исходным кодом, но получившиеся решения, скорее всего, не будут обладать высоким качеством. В качестве примера давайте рассмотрим шаблон, который мы использовали для поиска комментарием в программе на С: '<code>%*.-%*/</code>'. Если у вас в программе есть строка, содержащая "<code>/*</code>", то вы можете получить неверный результат:</p>

<pre class="code">
test&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>[[char&nbsp;s[]&nbsp;=&nbsp;"a&nbsp;/*&nbsp;here";&nbsp;/*&nbsp;a&nbsp;tricky&nbsp;string&nbsp;*/]]</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>test<font color=FF0000>,</font>&nbsp;<font color=8888CC>"/%*.-%*/"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"&lt;COMMENT&gt;"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;char&nbsp;s[]&nbsp;=&nbsp;"a&nbsp;&lt;COMMENT&gt;</font>
</pre>

<p>Строки с подобным содержимым встречаются довольно редко, и для ваших личных целей подобный шаблон, скорее всего, будет работать. Но вы не можете распространять программу с подобной ошибкой.</p>

<p>Обычно шаблоны работают в Lua довольно эффективно. Моему старому компьютеру Pentium нужно всего 0,3 секунды, для того чтобы найти все слова в тексте размером 4,4 Мб (850К слов). Но всегда лучше предпринять некоторые предосторожности. Всегда лучше делать шаблон как можно более точным. Неточные шаблоны медленнее точных. Простым примером является использование "<code>(.-)%$</code>' для получения всей подстроки до первого вхождения знака доллара. Если в строке есть знак доллара, то все хорошо. Но давайте допустим, что в строке вообще нет ни одного знака доллара. Тогда алгоритм сначала попытается получить подстроку, удовлетворяющую шаблону, начиная с первой позиции внутри строки. Дальше он будет двигаться вдоль всей строки в поисках знака доллара. Когда строка закончится, то мы получим несовпадения с шаблоном <i>только для первой позиции</i> внутри строки. Затем алгоритм выполнит то же самое, начиная уже со второй позиции внутри строки, и т. д. Таким образом, мы получим квадратичную сложность по времени, занимая более 4 минут на моем Pentium для строки из 100К символов. Вы можете легко исправить эту ситуацию, привязав шаблон к началу строки при помощи '<code>^(.-)%$</code>'. При использовании такой привязки выполнение занимает всего одну сотую секунды.</p>

<p>Также будьте очень аккуратны с <i>пустыми шаблонами</i>, то есть шаблонами, которым удовлетворяет пустая строка. Например, если вы попробуете искать имена при помощи шаблона '<code>%а*</code>', то вы везде будете находить имена:</p>

<pre class="code">
i<font color=FF0000>,</font>&nbsp;j&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.find</font><font color=FF0000>(</font><font color=8888CC>";$%&nbsp;**#$hello13"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%a*"</font><font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>i<font color=FF0000>,</font>j<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;1&nbsp;0</font>
</pre>

<p>В этом примере вызов <code>string.find</code> правильно находит пустую последовательность букв в начале строки.</p>

<p>Никогда не следует писать шаблон, который начинается или заканчивается с '<code>-</code>', поскольку ему будет удовлетворять пустая строка. Для этого модификатора обычно нужно что-то вокруг него, для того чтобы его ограничить. Аналогично шаблоны, включающие в себя '<code>.*</code>', также довольно коварны, поскольку эта конструкция может захватить гораздо больше, чем вы планировали.</p>

<p>Иногда проще использовать сам Lua для построения шаблонов. Мы уже использовали этот прием в функции, преобразующей пробелы в символы табуляции. В качестве другого примера давайте рассмотрим, как мы можем найти строки более чем из 70 символов. Такая строка - это последовательность из 70 или большего числа символов, отличных от '<code>\n</code>'. Одиночный символ, отличающийся от '<code>\n</code>' принадлежит классу '<code>[^\n]</code>'. Соответственно, мы можем получить шаблон для длинной строки, повторив шаблон для символа 70 раз и добавив шаблон для нуля или большего числа следующих далее символов. Вместо того, чтобы явно выписать этот шаблон, мы можем создать его при помощи <code>string.rep</code>:</p>

<pre class="code">
pattern&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.rep</font><font color=FF0000>(</font><font color=8888CC>"[^\n]"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>70</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"[^\n]*"</font>
"</pre>

<p>В качестве другого примера пусть вы хотите сделать поиск, нечуствительпый к регистру букв. Для этого можно заменить каждую букву <code>х</code> в шаблоне на класс '<code>[хХ]</code>', то есть класс, включающий в себя и строчную, и заглавную версии буквы. Мы можем автоматизировать это преобразование при помощи следующей функции:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;nocase&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%a"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>c<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8888CC>"["</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8000FF>string.lower</font><font color=FF0000>(</font>c<font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8000FF>string.upper</font><font color=FF0000>(</font>c<font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"]"</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;s
<font color=0000DF>end</font>

<font color=0080C0>print</font><font color=FF0000>(</font>nocase<font color=FF0000>(</font><font color=8888CC>"Hi&nbsp;there!"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;[hH][iI]&nbsp;[tT][hH][eE][rR][eE]!</font>
</pre>

<p>Иногда вам просто нужно заменить каждое вхождение <code>s1</code> на <code>s2</code>, без учета всяких магических символов. Если обе строки явно заданы в тексте, то вы легко можете сами добавить все необходимые преобразования для магических символов, но если это переменные, то вам понадобятся дополнительные <code>gsub</code> для выполнения этой работы:</p>

<pre class="code">
s1&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s1<font color=FF0000>,</font>&nbsp;<font color=8888CC>"(%W)"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%%%1"</font><font color=FF0000>)</font>
s2&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s2<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%%"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"%%%%"</font><font color=FF0000>)</font>
</pre>

<p>В строке, в которой мы ищем, мы заменяем все неалфавитно-цифровые символы, в строке замены мы заменяем только символ '<code>%</code>'.</p>

<p>Другим полезным приемом для работы с шаблонами является выполнение специальной обработки строки перед началом основной работы. Пусть мы хотим перевести в прописные все буквы, содержащиеся внутри двойных кавычек, но при этом внутри самой строки могут быть '<code>\"</code>':</p>

<pre class="code"><font color=8888CC>follows&nbsp;a&nbsp;typical&nbsp;string:&nbsp;"This&nbsp;is&nbsp;\"great\"!".</font></pre>

<p>Одним из подходов для подобных случаев является кодирование входной строки. Например, давайте заменим "<code>\"</code>" на "<code>\l</code>". Однако если в исходном тексте уже содержался символ "<code>\l</code>", то у нас проблема. Простым способом выполнить кодирование и избежать этой проблемы является замена всех последовательностей "<code>\х</code>" на "<code>\ddd</code>", где <code>ddd</code> - это десятичное представление символа <code>х</code>:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;code&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\\(.)"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>x<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"\\%03d"</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.byte</font><font color=FF0000>(</font>x<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>))</font>
<font color=0000DF>end</font>
</pre>

<p>Теперь любая последовательность "<code>\ddd</code>" могла прийти только из нашего кодирования, поскольку любое "<code>\ddd</code>" в исходной строке также было бы закодировано. Поэтому декодирование является простой задачей:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;decode&nbsp;<font color=FF0000>(</font>s<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\\(%d%d%d)"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>d<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8888CC>"\\"</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8000FF>string.char</font><font color=FF0000>(</font><font color=0080C0>tonumber</font><font color=FF0000>(</font>d<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>))</font>
<font color=0000DF>end</font>
</pre>

<p>Теперь мы можем завершить нашу задачу. Так как закодированная строка больше не содержит "<code>\"</code>" то мы можем смело использовать шаблон</p>

<pre class="code">
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>[[follows&nbsp;a&nbsp;typical&nbsp;string:&nbsp;"This&nbsp;is&nbsp;\"great\"!".]]</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;code<font color=FF0000>(</font>s<font color=FF0000>)</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>'".-"'</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.upper</font><font color=FF0000>)</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;decode<font color=FF0000>(</font>s<font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;follows&nbsp;a&nbsp;typical&nbsp;string:&nbsp;"THIS&nbsp;IS&nbsp;\"GREAT\"!".</font>
</pre>

<p>Или записав это короче:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font>decode<font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>code<font color=FF0000>(</font>s<font color=FF0000>),</font>&nbsp;<font color=8888CC>'".-"'</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.upper</font><font color=FF0000>)))</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="21.7. Юникод"></a>21.7. Юникод
</div>

<p>На данный момент библиотека для работы со строками не содержит явной поддержки юникода. Однако несложно реализовать некоторые простые задачи по работе с юникод-строками, закодированные в UTF-8 без использования дополнительных библиотек.</p>

<p>Основной кодировкой для юникода в Web является UTF-8. Из-за ее совместимости с ASCII эта кодировка также очень хорошо подходит для Lua. Эта совместимость обеспечивает то, что ряд приемов по работе со строками без каких-либо изменений будет работать с UTF-8.</p>

<p>UTF-8 представляет каждый символ юникода различным числом байт. Например, символ '<code>А</code>' он представляет одним байтом, <code>65</code>; символ Алеф, имеющий в юникоде код 1488, представлен двухбайтовой последовательностью <code>215-144</code>. UTF-8 представляет все символы из ASCII как ASCII, то есть одним байтом со значением, меньшим <code>128</code>.</p>

<p>Все остальные символы представляются последовательностями байт, где первый байт лежит в диапазоне <code>[194, 244]</code> и идущие далее байты лежат в диапазоне <code>[128, 191]</code>. Точнее, диапазон первого байта для двухбайтовых последовательностей это <code>[194, 223]</code>, для трехбайтовых последовательностей <code>[224, 239]</code> и для четырехбайтовых последовательностей <code>[240,244]</code>. Подобная схема гарантирует, что последовательность для любого символа никогда не встретится внутри последовательности для другого символа. Например, байт, меньший, чем <code>128</code>, никогда не встретится в многобайтовой последовательности; он всегда представлен своим ASCII-символом.</p>

<p>В Lua вы можете читать, записывать и хранить строки в UTF-8 как обычные строки. Строчные константы(литералы) также могут содержать внутри себя UTF-8 (Конечно, вы, скорее всего, захотите редактировать ваш файл как файл в UTF-8.) Операция конкатенации выполняется корректно для всех строк в UTF-8. Операции сравнения строк(меньше, чем; меньше или равно и т. п.) сравнивают строки в UTF-8, следуя порядку символов в юникоде.</p>

<p>Библиотека функций операционной системы и библиотека для ввода-вывода являются на самом деле просто интерфейсами к операционной системе, поэтому их поддержка UTF-8 зависит от поддержки UTF-8 в самой системе. В Linux, например, мы можем использовать UTF-8 для имен файлов, но Windows использует UTF-16. Поэтому для работы с именами файлов в юникоде в Windows понадобятся дополнительные библиотеки или модификация стандартных библиотек Lua.</p>

<p>Давайте посмотрим, как функции из библиотеки для работы со строками работают со строками в UTF-8.</p>

<p>Функции <code>string.reverse</code>, <code>string.byte</code>, <code>string.char</code>, <code>string.upper</code> и <code>string.lower</code> не работают со строками в UTF-8, поскольку каждая из этих функций считает, что один символ - это один байт.</p>

<p>Функции <code>string.format</code> и <code>string.rep</code> без всяких проблем работают со строками в UTF-8, за исключением опции '<code>%с</code>', которая подразумевает, что один символ - это один байт. Функции <code>string.len</code> и <code>string.sub</code> корректно работают со строками в UTF-8, но при этом индексы уже относятся не к символам, а к байтам. Довольно часто это именно то, что нужно. Но мы можем легко посчитать количество символов, как мы скоро увидим.</p>

<p>Для функций для работы с шаблонами их применимость зависит от шаблона. Простые шаблоны работают без всяких проблем, поскольку представление одного символа никогда не может встретиться внутри представления другого символа. Классы символов и множества символов работают только для ASCII-символов. Например, шаблон "<code>%s</code>" работает для строк в UTF-8, но он будет соответствовать только пробелам ASCII и не будет соответствовать пробелам в юникоде, таким как неразбиваемый пробел (<code>U+00A0</code>), разделителю параграфов (<code>U+2029</code>) или монгольскому <code>U+180Е</code>.</p>

<p>Некоторые шаблоны могут удачно использовать особенности UTF-8. Например, если вы хотите посчитать число символов в строке, то вы можете использовать следующее выражение:</p>

<pre class="code">
<font color=FF0000>(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>"[\128-\191]"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>""</font><font color=FF0000>))</font>
</pre>

<p>В этом примере <code>gsub</code> убирает второй, третий и четвертые байты, оставляя в результате по одному байту па каждый символ.</p>

<p>Аналогично следующий пример показывает, как можно перебрать все символы в строке в UTF-8:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;c&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>s<font color=FF0000>,</font>&nbsp;<font color=8888CC>".[\128-\191]*"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>c<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p><a href="#листинг 21.1">Листинг 21.1</a> показывает некоторые приемы для работы с UTF-8 строками в Lua. Конечно, для выполнения этих примеров вам нужна платформа, где <code>print</code> поддерживает UTF-8.</p>

<p>К сожалению, больше Lua ничего предложить не может. Адекватная поддержка юникода требует огромных таблиц, которые плохо соотносятся с маленьким размером Lua. У юникода много особенностей. Практически невозможно абстрагировать какое-либо понятие из конкретных языков. Даже понятие того, что есть символ, весьма нечетко, поскольку нет взаимно-однозначного соответствия между закодированными в юникоде символами и графемами (то есть символами с диакритическими пометками и «полностью игнорируемыми» символами). Другие вроде бы базовые понятия, такие как что есть символ, также различаются для разных языков.</p>

<p>Чего, на мой взгляд, не хватает в Lua, так это функций для перевода между UTF-8 и юникодом и проверкой правильности строк в UTF-8. Возможно, они войдут в следующую версию Lua. Для остальных вещей лучшим вариантом будет использование внешней библиотеки вроде <i>Slnunicode</i>.</p>

<p><a name="листинг 21.1"></a><b class="sect">Листинг 21.1</b>. Примеры работы с UTF-8 в Lua</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
a<font color=FF0000>[#</font>a&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Nahdaan"</font>
a<font color=FF0000>[#</font>a&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"acao"</font>
a<font color=FF0000>[#</font>a&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"Ao?E?"</font>

<font color=0000DF>local</font>&nbsp;l&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>table.concat</font><font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;<font color=8888CC>";"</font><font color=FF0000>)</font>

<font color=0080C0>print</font><font color=FF0000>(</font>l<font color=FF0000>,</font>&nbsp;<font color=FF0000>#(</font><font color=8000FF>string.gsub</font><font color=FF0000>(</font>l<font color=FF0000>,</font>&nbsp;<font color=8888CC>"[\128-\191]"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>""</font><font color=FF0000>)))</font>
<font color=008000>--&gt;&nbsp;Nahdaan;acao;Ao?E?&nbsp;18</font>

<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>l<font color=FF0000>,</font>&nbsp;<font color=8888CC>"[^;]+"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>w<font color=FF0000>)</font>
<font color=0000DF>end</font>
<font color=008000>--&gt;&nbsp;Nahdaan</font>
<font color=008000>--&gt;&nbsp;acao</font>
<font color=008000>--&gt;&nbsp;Ao?E?</font>

<font color=0000DF>for</font>&nbsp;c&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>a<font color=FF0000>[</font><font color=AC00A9>3</font><font color=FF0000>],</font>&nbsp;<font color=8888CC>".[\128-\191]*"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>c<font color=FF0000>)</font>
<font color=0000DF>end</font>
<font color=008000>--&gt;&nbsp;A</font>
<font color=008000>--&gt;&nbsp;o</font>
<font color=008000>--&gt;&nbsp;?</font>
<font color=008000>--&gt;&nbsp;E</font>
<font color=008000>--&gt;&nbsp;?</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="21. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 21.1.</b><br>
Напишите функцию <code>split</code>, которая получает строку и шаблон-разделитель и возвращает последовательность блоков, разделенных разделителем:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;split<font color=FF0000>(</font><font color=8888CC>"a&nbsp;whole&nbsp;new&nbsp;world"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"&nbsp;"</font><font color=FF0000>)</font>
<font color=008000>--&nbsp;t&nbsp;=&nbsp;{"a",&nbsp;"whole",&nbsp;"new",&nbsp;"world"}</font>
</pre>

<p>Как ваша функция обрабатывает пустые строки?(В частности, является ли пустая строка пустой последовательностью или последовательностью с одной пустой строкой?)</p>

<hr color="#99CCFF">

<p><b>Упражнение 21.2.</b><br>
Шаблоны '<code>%D</code>' и '<code>[^%d]</code>' эквивалентны. А что насчет шаблонов '<code>[^%d%u]</code>' и '<code>[%D%D]</code>'?</p>

<hr color="#99CCFF">

<p><b>Упражнение 21.3.</b><br>
Напишите функцию для транслитерации. Эта функция получает строку и заменяет каждый символ в этой строке другим символом в соответствии с таблицей, заданной вторым аргументом. Если таблица отображает '<code>а</code>' в '<code>b</code>', то функция должна заменить каждое вхождение '<code>а</code>' на '<code>b</code>'.Если таблица отображает '<code>а</code>' в <b>false</b>, то функция должна удалить все вхождения символа '<code>а</code>' из строки.</p>

<hr color="#99CCFF">

<p><b>Упражнение 21.4.</b><br>
Напишите функцию, которая реверсирует строку в UTF-8.</p>

<hr color="#99CCFF">

<p><b>Упражнение 21.5.</b><br>
Напишите функцию транслитерации для UTF-8.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 22. Библиотека ввода/вывода"></a>Глава 22. Библиотека ввода/вывода
</div>

<p>Библиотека ввода/вывода предоставляет две различные модели для работы с файлами. Простая модель использует <i>текущий входной</i> и <i>текущий выходной</i> файлы, и все ее операции происходят над этими файлами. Полная модель использует явные указатели на файлы; она опирается на обьектно-ориентированный подход, который определяет все операции как методы над указателями на файлы.</p>

<p>Простая модель удобная для простых вещей. Мы использовали ее на протяжении всей книги. Но ее недостаточно для более гибкой работы с файлами, например для одновременного чтения или одновременной записи сразу в несколько файлов. Для этого нам нужна полная модель.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="22.1. Простая модель ввода/вывода"></a>22.1. Простая модель ввода/вывода
</div>

<p>Простая модель выполняет все свои операции над двумя текущими файлами. Библиотека при инициализации использует стандартный ввод (<code>stdin</code>) как входной файл по умолчанию и стандартный вывод (<code>stdout</code>) как выходной файл по умолчанию. Таким образом, когда мы выполняем что-то вроде <code>io.read()</code>, что мы читаем из стандартного ввода.</p>

<p>Мы можем изменить эти текущие файлы при помощи функций <code>io.input</code> и <code>io.output</code>. Вызов <code>io.input(filename)</code> открывает заданный файл для чтения и устанавливает его в качестве входного файла по умолчанию. Начиная с этого момента, весь ввод будет идти из этого файла до следующего вызова <code>io.input</code>; <code>io.output</code> работает аналогично, но уже для вывода. В случае ошибки обе функции вызывают ошибку. Если вы хотите явно обрабатывать ошибки, то вам нужна полная модель.</p>

<p>Функция <code>write</code> проще, чем <code>read</code>, поэтому мы сперва рассмотрим ее. Функция <code>io.write</code> получает произвольное число строковых аргументов и записывает их в выходной файл по умолчанию. Она преобразует числа в строки, используя стандартные правила преобразования; для полного контроля над этим преобразованием используйте функцию <code>string.format</code>:</p>

<pre class="code">
<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"sin&nbsp;(3)&nbsp;=&nbsp;"</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.sin</font><font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>),</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
<font color=008000>--&gt;&nbsp;sin&nbsp;(3)&nbsp;=&nbsp;0.14112000805987</font>
<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"sin&nbsp;(3)&nbsp;=&nbsp;%.4f\n"</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.sin</font><font color=FF0000>(</font><font color=AC00A9>3</font><font color=FF0000>)))</font>
<font color=008000>--&gt;&nbsp;sin&nbsp;(3)&nbsp;=&nbsp;0.1411</font>
</pre>

<p>Избегайте кода вроде <code>io.write(a..b..с)</code>; вызов <code>io.write(a,b,c)</code> выполняет то же самое, используя при этом меньше ресурсов, так как он избегает операции конкатенации.</p>

<p>Используйте <code>print</code> для небольших программ или для отладки и <code>write</code> тогда, когда вам нужен полный контроль над выводом:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"hello"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Lua"</font><font color=FF0000>);</font>&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8888CC>"Hi"</font><font color=FF0000>)</font>
<font color=008000>--&gt;&nbsp;hello&nbsp;Lua</font>
<font color=008000>--&gt;&nbsp;Hi</font>
<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"hello"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Lua"</font><font color=FF0000>);</font>&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"Hi"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
<font color=008000>--&gt;&nbsp;helloLuaHi</font>
</pre>

<p>В отличие от <code>print</code>, функция <code>write</code> не добавляет к выводу никаких символов вроде символов табуляции или перехода на следующую строку. Кроме того, функция <code>write</code> позволяет вам перенаправить ваш вывод, тогда как <code>print</code> всегда использует стандартный вывод. Наконец, <code>print</code> автоматически применяет <code>tostring</code> к своим аргументам; это удобно для отладки, но может скрывать ошибки, если вы не внимательны к выводу.</p>

<p>Функция <code>io.read</code> читает строки из текущего входного файла. Ее аргументы управляют тем, что читать:</p>

<table>
  <tr>
    <td width="50px"><code>"*а"</code></td>
    <td><i>Читает весь файл</i></td>
  </tr>
  <tr>
    <td width="50px"><code>"*l"</code></td>
    <td><i>Читает следующую строку (без символа перевода строки)</i></td>
  </tr>
  <tr>
    <td width="50px"><code>"*L"</code></td>
    <td><i>Читает следующую строку (с символом перевода строки)</i></td>
  </tr>
  <tr>
    <td width="50px"><code>"*n"</code></td>
    <td><i>Читает число</i></td>
  </tr>
  <tr>
    <td width="50px"><code>num</code></td>
    <td><i>Читает строку, состоящую из не более чем пит символов</i></td>
  </tr>
</table>

<p>Вызов <code>io.read("*а")</code> читает весь текущий входной файл, начиная с текущей позиции. Если мы находимся в конце файла или файл пуст, то вызов возвращает пустую строку.</p>

<p>Поскольку Lua эффективно работает с длинными строками, то простым способом написания фильтров на Lua является прочесть весь файл в строку, выполнить обработку строки (обычно при помощи <code>gsub</code>) и затем записать строку на вывод:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(</font><font color=8888CC>"*a"</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;прочесть&nbsp;весь&nbsp;файл</font>
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;<font color=FF0000>...)</font>&nbsp;<font color=008000>--&nbsp;выполнить&nbsp;работу</font>
<font color=FF8000>io.write</font><font color=FF0000>(</font>t<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;записать&nbsp;файл</font>
</pre>

<p>В качестве примера следующий фрагмент кода - это законченная программа для кодирования содержимого файла в MIME <i>quoted-printable</i>. Каждый не ASCII-байт кодируется как = <code>хх</code>, где <code>хх</code> -это шестнадцатеричное значение байта. Для целостности кодирования сам символ равенства также должен быть закодирован:</p>

<pre class="code">
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(</font><font color=8888CC>"*a"</font><font color=FF0000>)</font>
t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>t<font color=FF0000>,</font>&nbsp;<font color=8888CC>"([\128-\255=])"</font><font color=FF0000>,</font>&nbsp;<font color=0000DF>function</font>&nbsp;<font color=FF0000>(</font>c<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"=%02X"</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.byte</font><font color=FF0000>(</font>c<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font><font color=FF0000>)</font>
<font color=FF8000>io.write</font><font color=FF0000>(</font>t<font color=FF0000>)</font>
</pre>

<p>Шаблон, используемый в <code>gsub</code>, находит все байты от <code>128</code> до <code>255</code>, включая знак равенства.</p>

<p>Вызов <code>io.read("*l")</code> читает следующую строку из текущего входного файла без символа перевода строки('<code>\n</code>'); вызов <code>io.read("*L")</code> аналогичен, но только он возвращает символ перевода строки (если он присутствовал). Когда мы достигаем конца файла, функция возвращает <b>nil</b> (так как больше нет строк). Шаблон "<code>*l</code>" для функции read является значением по умолчанию. Обычно я использую этот шаблон, только когда естественно обрабатывает файл строка за строкой; в противном случае я предпочитаю сразу прочесть весь файл при помощи "<code>*а</code>" или читать его блоками, как мы увидим позже.</p>

<p>В качестве простого примера использования этого шаблона следующая программа копирует текущий ввод в текущий вывод, нумеруя при этом каждую строку:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.huge</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;line&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%6d&nbsp;"</font><font color=FF0000>,</font>&nbsp;count<font color=FF0000>),</font>&nbsp;line<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Однако для того, чтобы перебирать весь файл, строка за строкой, лучше использовать итератор <code>io.lines</code>. Например, мы можем написать законченную программу для сортировки строк файла следующим образом:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;lines&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=008000>--&nbsp;читаем&nbsp;строки&nbsp;в&nbsp;таблицу&nbsp;'lines'</font>
<font color=0000DF>for</font>&nbsp;line&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>()</font>&nbsp;<font color=0000DF>do</font>&nbsp;lines<font color=FF0000>[#</font>lines&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;line&nbsp;<font color=0000DF>end</font>
<font color=008000>--&nbsp;sort</font>
<font color=8000FF>table.sort</font><font color=FF0000>(</font>lines<font color=FF0000>)</font>
<font color=008000>--&nbsp;записываем&nbsp;все&nbsp;строки</font>
<font color=0000DF>for</font>&nbsp;_<font color=FF0000>,</font>&nbsp;l&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>ipairs</font><font color=FF0000>(</font>lines<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>l<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>end</font>
</pre>

<p>Вызов <code>io.read("*n")</code> читает число из текущего входного файла. Это единственный случай, когда функция <code>read</code> возвращает число, а не строку. Когда программе нужно прочесть много чисел из файла, то отсутствие промежуточных строк улучшает быстродействие. Опция <code>"*n"</code> пропускает все пробелы перед числом и поддерживает такие числовые форматы, как <code>-3, +5.2, 1000</code> и <code>-3</code>. <code>-3.4е-23</code>. Если функция не может найти число в текущей позиции (из-за неверного формата или конца файла), то она возвращает <b>nil</b>.</p>

<p>Вы можете вызвать <code>read</code>, передав сразу несколько опций. Для каждого аргумента функция вернет соответствующее значение. Пусть у вас есть файл, содержащий по три числа на каждую строку:</p>

<pre class="code">
<font color=AC00A9>6.0</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF0000>-</font><font color=AC00A9>3.23</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=AC00A9>15e12</font>
<font color=AC00A9>4.3</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=AC00A9>234</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=AC00A9>1000001</font>
<font color=FF0000>...</font>
</pre>

<p>Теперь вам нужно напечатать максимум для каждой строки. Вы можете прочесть все три числа за один вызов <code>read</code>:</p>

<pre class="code">
<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;n1<font color=FF0000>,</font>&nbsp;n2<font color=FF0000>,</font>&nbsp;n3&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(</font><font color=8888CC>"*n"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"*n"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"*n"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;n1&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>math.max</font><font color=FF0000>(</font>n1<font color=FF0000>,</font>&nbsp;n2<font color=FF0000>,</font>&nbsp;n3<font color=FF0000>))</font>
<font color=0000DF>end</font>
</pre>

<p>Кроме стандартных шаблонов, вы можете вызвать <code>read</code>, передав в качестве аргумента число <code>n</code>: в этом случае <code>read</code> пытается прочесть <code>n</code> символов из входного файла. Если она не может прочесть ни одного символа (конец файла), то она возвращает <b>nil</b>, в противном случае возвращается строка с не более чем <code>n</code> символами. В качестве примера следующая программа демонстрирует эффективный способ (для Lua, конечно) скопировать файл из <code>stdin</code> в <code>stdout</code>:</p>

<pre class="code">
<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;block&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>^</font><font color=AC00A9>13</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;размер&nbsp;буфера&nbsp;8K</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;block&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>block<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Как отдельный случай <code>read(0)</code> работает как проверка конца файла. Она возвращает пустую строку, если в файле есть символы, и <b>nil</b>, если достигнут конец файла.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="22.2. Полная модель ввода/вывода"></a>22.2. Полная модель ввода/вывода
</div>

<p>Для большего контроля за вводом/выводом вы можете использовать полную модель. Ключевым понятием в этой модели является <i>указатель файла</i> (<i>file handle</i>), который аналогичен <code>FILE *</code> в С: он представляет открытый файл с текущим положением.</p>

<p>Для того чтобы открыть файл, используется функция <code>io.open</code>, которая аналогична функции <code>fopen</code> в С. В качестве аргументов она принимает имя файла и строку, задающую режим. Эта строка может содержать '<code>r</code>' для чтения, '<code>w</code>' для записи (запись стирает предыдущее содержимое файла) или '<code>а</code>' для добавления к файлу, также она может содержать '<code>b</code>' для работы с двоичными файлами. Функция <code>open</code> возвращает новый указатель на файл. В случае ошибки <code>open</code> возвращает <b>nil</b>, а также сообщение об ошибке и код ошибки:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font><font color=8888CC>"non-existent-file"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"r"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;nil&nbsp;non-existent-file:&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory&nbsp;2</font>

<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font><font color=8888CC>"/etc/passwd"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"w"</font><font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;nil&nbsp;/etc/passwd:&nbsp;Permission&nbsp;denied&nbsp;13</font>
</pre>

<p>Интерпретация кодов ошибки зависит от системы. Типичным способом проверки ошибок является следующий:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;mode<font color=FF0000>))</font>
</pre>

<p>Если происходит ошибка, то сообщение об ошибке выступает вторым аргументом <code>assert</code>, которое печатает это сообщение.</p>

<p>После того как вы откроете файл, вы может читать из него и писать в него при помощи методов <code>read/write</code>. Они аналогичны функциям <code>read/write</code>, но вы вызываете их как методы указателя на файл, используя двоеточие. Например, для того чтобы открыть файл и прочесть все из него, вы можете использовать следующий код:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;<font color=8888CC>"r"</font><font color=FF0000>))</font>
<font color=0000DF>local</font>&nbsp;t&nbsp;<font color=FF0000>=</font>&nbsp;f<font color=FF0000>:</font><font color=FF8000>read</font><font color=FF0000>(</font><font color=8888CC>"*a"</font><font color=FF0000>)</font>
f<font color=FF0000>:</font><font color=FF8000>close</font><font color=FF0000>()</font>
</pre>

<p>Библиотека ввода/вывода предоставляет три предопределенных указателя на стандартные файлы в С: <code>io.stdin</code>, <code>io.stdout</code> и <code>io.stderr</code>. Поэтому вы можете послать сообщение об ошибке прямо в соответствующий стандартный файл:</p>

<pre class="code">
<font color=FF8000>io.stderr</font><font color=FF0000>:</font>write<font color=FF0000>(</font>message<font color=FF0000>)</font>
</pre>

<p>Можно использовать полную модель вместе с простой моделью. Для того чтобы получить указатель на текущий входной файл, следует вызвать <code>io.input()</code> без аргументов. Для того чтобы задать указатель файла в качестве текущего входного файла, следует вызвать <code>io.input(handle)</code> (аналогичные вызовы работают и для <code>io.output</code>). Например, если вы хотите временно изменить текущий входной файл, то вы можете написать что-то вроде следующего:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;temp&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.input</font><font color=FF0000>()</font>&nbsp;<font color=008000>--&nbsp;сохранить&nbsp;текущий&nbsp;файл</font>
<font color=FF8000>io.input</font><font color=FF0000>(</font><font color=8888CC>"newinput"</font><font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;открыть&nbsp;новый&nbsp;текущий&nbsp;файл</font>
<font color=FF0000>&lt;</font>обработать&nbsp;ввод<font color=FF0000>&gt;</font>
<font color=FF8000>io.input</font><font color=FF0000>():</font><font color=FF8000>close</font><font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;закрыть&nbsp;текущий&nbsp;файл</font>
<font color=FF8000>io.input</font><font color=FF0000>(</font>temp<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;восстановить&nbsp;предыдущий&nbsp;файл</font>
</pre>

<p>Вместо <code>io.read</code> для чтения из файла мы также можем использовать <code>io.lines</code>. Как мы уже видели в предыдущих примерах, <code>io.lines</code> возвращает итератор, последовательно читающий из файла.</p>

<p>Первым аргументом <code>io.lines</code> может быть имя файла или указатель на файл. Если было передано имя файла, то <code>io.lines</code> откроет файл в режиме для чтения и закроет файл после достижения конца файла. Если был передан указатель на файл, то <code>io.lines</code> будет использовать данный файл для чтения; в этом случае <code>io.lines</code> не будет закрывать файл по достижении его конца. В случае вызова вообще без аргументов <code>io.lines</code> будет читать данные из текущего входного файла.</p>

<p>Начиная с Lua 5.2, функция <code>io.lines</code> также принимает те же самые опции, что и <code>io.read</code> (после первого аргумента). В качестве примера следующий код копирует файл, используя <code>io.lines</code>:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;block&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>(</font>filename<font color=FF0000>,</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>^</font><font color=AC00A9>13</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font>block<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="22.2. Небольшой прием для увеличения быстродействия"></a>Небольшой прием для увеличения быстродействия
</div>

<p>Обычно в Lua быстрее прочесть файл целиком, чем читать его строка за строкой. Однако иногда мы сталкиваемся с большим файлом (например, десятки или даже сотни мегабайт), читать который целиком было бы нецелесообразно. Если вы хотите получить максимальное быстродействие при работе с такими большими файлами, то быстрее всего будет читать его достаточно большими блоками (например, по 8К). Для того чтобы избежать возможного разрыва строки, можно просто попросить прочесть еще одну строку:</p>

<pre class="code"><font color=0000DF>local</font>&nbsp;lines<font color=FF0000>,</font>&nbsp;rest&nbsp;<font color=FF0000>=</font>&nbsp;f<font color=FF0000>:</font><font color=FF8000>read</font><font color=FF0000>(</font>BUFSIZE<font color=FF0000>,</font>&nbsp;<font color=8888CC>"*l"</font><font color=FF0000>)</font></pre>

<p>Переменная <code>rest</code> получит остаток любой строки, разбитой при чтении блока. Затем мы обьединяем блок и полученный остаток. Таким образом блок всегда будет завершаться на границе строк.</p>

<p>Пример из <a href="#листинг 22.1">листинга 22.1</a> использует этот прием для реализации <code>wc</code>, программы, которая считает число символов, слов и строк в файле. Обратите внимание на использование <code>io.lines</code> для осуществления итераций и опции "<code>*L</code>" для чтения строки, это доступно, начиная с Lua 5.2.</p>

<p><a name="листинг 22.1"></a><b class="sect">Листинг 22.1</b>. Программа <code>wc</code></p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;BUFSIZE&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>2</font><font color=FF0000>^</font><font color=AC00A9>13</font>&nbsp;<font color=008000>--&nbsp;8K</font>
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.input</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>])</font>&nbsp;<font color=008000>--&nbsp;открыть&nbsp;входной&nbsp;файл</font>
<font color=0000DF>local</font>&nbsp;cc<font color=FF0000>,</font>&nbsp;lc<font color=FF0000>,</font>&nbsp;wc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>0</font>&nbsp;<font color=008000>--&nbsp;счетчики&nbsp;char,&nbsp;line,&nbsp;и&nbsp;word&nbsp;</font>
<font color=0000DF>for</font>&nbsp;lines<font color=FF0000>,</font>&nbsp;rest&nbsp;<font color=0000DF>in</font>&nbsp;<font color=FF8000>io.lines</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>],</font>&nbsp;BUFSIZE<font color=FF0000>,</font>&nbsp;<font color=8888CC>"*L"</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;rest&nbsp;<font color=0000DF>then</font>&nbsp;lines&nbsp;<font color=FF0000>=</font>&nbsp;lines&nbsp;<font color=FF0000>..</font>&nbsp;rest&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;cc&nbsp;<font color=FF0000>=</font>&nbsp;cc&nbsp;<font color=FF0000>+</font>&nbsp;<font color=FF0000>#</font>lines
&nbsp;&nbsp;<font color=008000>--&nbsp;count&nbsp;words&nbsp;in&nbsp;the&nbsp;chunk</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;_<font color=FF0000>,</font>&nbsp;t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>lines<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%S+"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>""</font><font color=FF0000>)</font>
&nbsp;&nbsp;wc&nbsp;<font color=FF0000>=</font>&nbsp;wc&nbsp;<font color=FF0000>+</font>&nbsp;t
&nbsp;&nbsp;<font color=008000>--&nbsp;count&nbsp;newlines&nbsp;in&nbsp;the&nbsp;chunk</font>
&nbsp;&nbsp;_<font color=FF0000>,</font>t&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>lines<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
&nbsp;&nbsp;lc&nbsp;<font color=FF0000>=</font>&nbsp;lc&nbsp;<font color=FF0000>+</font>&nbsp;t
<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font>lc<font color=FF0000>,</font>&nbsp;wc<font color=FF0000>,</font>&nbsp;cc<font color=FF0000>)</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="22.2. Бинарные файлы"></a>Бинарные файлы
</div>

<p>Функции <code>io.input</code> и <code>io.output</code> из простой модели всегда открывают файл в текстовом режиме. В UNIX нет никакой разницы между бинарными и текстовыми файлами. Но в некоторых других системах, в частности в Windows, бинарные файлы нужно открывать со специальным флагом. Для работы с такими файлами используйте <code>io.open</code> с символом '<code>b</code>' в строке режима.</p>

<p>Lua работает с бинарными данными так же, как и с текстом. Строка в Lua может содержать любые байты, и почти все функции в библиотеках могут обрабатывать любые байты. Вы даже можете использовать шаблоны для работы с бинарными данными до тех пор, пока шаблон не содержит нулевого байта. Если вам нужно отлавливать этот байт, то используйте для этого специальный класс <code>%z</code>.</p>

<p>Обычно бинарные данные читают либо при помощи шаблона <code>*а</code>, который читает весь файл, либо при помощи шаблона <code>n</code>, который читает <code>n</code> байт. В качестве простого примера следующая программа переводит текст из формата Windows в формат UNIX (то есть заменяет последовательность символов перевода каретки и перевода строки на символ перевода строки). Она не использует стандартных файлов (<code>stdin-stdout</code>), поскольку они открыты в текстовом режиме. Вместо этого считается, что имена входного и выходного файлов переданы программе как аргументы:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;inp&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>],</font>&nbsp;<font color=8888CC>"rb"</font><font color=FF0000>))</font>
<font color=0000DF>local</font>&nbsp;out&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>2</font><font color=FF0000>],</font>&nbsp;<font color=8888CC>"wb"</font><font color=FF0000>))</font>

<font color=0000DF>local</font>&nbsp;data&nbsp;<font color=FF0000>=</font>&nbsp;inp<font color=FF0000>:</font><font color=FF8000>read</font><font color=FF0000>(</font><font color=8888CC>"*a"</font><font color=FF0000>)</font>
data&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>data<font color=FF0000>,</font>&nbsp;<font color=8888CC>"\r\n"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
out<font color=FF0000>:</font><font color=FF8000>write</font><font color=FF0000>(</font>data<font color=FF0000>)</font>

<font color=0080C0>assert</font><font color=FF0000>(</font>out<font color=FF0000>:</font><font color=FF8000>close</font><font color=FF0000>())</font>
</pre>

<p>Вы можете вызвать эту программу при помощи следующей командной строки:</p>

<pre class="code">&gt; lua prog.lua file.dos file.unix</pre>

<p>В качестве еще одного примера следующая программа печатает все строки, найденные в бинарном файле:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>],</font>&nbsp;<font color=8888CC>"rb"</font><font color=FF0000>))</font>
<font color=0000DF>local</font>&nbsp;data&nbsp;<font color=FF0000>=</font>&nbsp;f<font color=FF0000>:</font><font color=FF8000>read</font><font color=FF0000>(</font><font color=8888CC>"*a"</font><font color=FF0000>)</font>
<font color=0000DF>local</font>&nbsp;validchars&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"[%g%s]"</font>
<font color=0000DF>local</font>&nbsp;pattern&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"("</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8000FF>string.rep</font><font color=FF0000>(</font>validchars<font color=FF0000>,</font>&nbsp;<font color=AC00A9>6</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>"+)\0"</font>
<font color=0000DF>for</font>&nbsp;w&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>data<font color=FF0000>,</font>&nbsp;pattern<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>w<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Программа считает, что строка есть завершенная нулем последовательность шести и более допустимых символов, где символ является допустимым, если он удовлетворяет шаблону <code>validchars</code>. В нашем примере этот шаблон состоит из всех печатных символов. Мы используем <code>string.rep</code> и конкатенацию для создания шаблона, которому удовлетворяют последовательности из шести и более допустимых символов, за которыми следует нулевой байт. Круглые скобки в шаблоне используются для захвата самой строки (но не нулевого байта).</p>

<p>В качестве последнего примера следующая программа делает дамп бинарного файла:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=FF8000>io.open</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>],</font>&nbsp;<font color=8888CC>"rb"</font><font color=FF0000>))</font>
<font color=0000DF>local</font>&nbsp;block&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>16</font>
<font color=0000DF>for</font>&nbsp;bytes&nbsp;<font color=0000DF>in</font>&nbsp;f<font color=FF0000>:</font><font color=FF8000>lines</font><font color=FF0000>(</font>block<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;c&nbsp;<font color=0000DF>in</font>&nbsp;<font color=8000FF>string.gmatch</font><font color=FF0000>(</font>bytes<font color=FF0000>,</font>&nbsp;<font color=8888CC>"."</font><font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%02X&nbsp;"</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.byte</font><font color=FF0000>(</font>c<font color=FF0000>)))</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8000FF>string.rep</font><font color=FF0000>(</font><font color=8888CC>"&nbsp;"</font><font color=FF0000>,</font>&nbsp;block&nbsp;<font color=FF0000>-</font>&nbsp;<font color=8000FF>string.len</font><font color=FF0000>(</font>bytes<font color=FF0000>)))</font>
&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"&nbsp;"</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>string.gsub</font><font color=FF0000>(</font>bytes<font color=FF0000>,</font>&nbsp;<font color=8888CC>"%c"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"."</font><font color=FF0000>),</font>&nbsp;<font color=8888CC>"\n"</font><font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p><a name="листинг 22.2"></a><b class="sect">Листинг 22.2</b>. Пример дампа, сделанного программой <code>dump</code></p>

<pre class="code">
6C 6F 63 61 6C 20 66 20 3D 20 61 73 73 65 72 74 local f = assert
28 69 6F 2E 6F 70 65 6E 28 61 72 67 5B 31 5D 2C (io.open(arg[1],
20 22 72 62 22 29 29 0A 6C 6F 63 61 6C 20 62 6C "rb")).local bl
6F 63 6B 20 3D 20 31 36 0A 66 6F 72 20 62 79 74 ock = 16.for byt
65 73 20 69 6E 20 66 3A 6C 69 6E 65 73 28 62 6C es in f:lines(bl
...
20 22 2C 20 73 74 72 69 6E 67 2E 67 73 75 62 28 ", string.gsub(
62 79 74 65 73 2C 20 22 25 63 22 2C 20 22 2E 22 bytes, "%c", "."
29 2C 20 22 5C 6E 22 29 0A 65 6E 64 0A 0A       ), "\n").end..
</pre>

<p>Как и ранее, первым аргументом программы является имя файла. Вывод идет на стандартный вывод. Программа читает файл блоками по 16 байт. Для каждого блока выводится шестнадцатеричное представление каждого байта, и затем блок выводится как текст, заменяя управляющие символы точками.</p>

<p><a href="#листинг 22.2">Листинг 22.2</a> показывает результат применения этой программы самой к себе (на UNIX-машине).</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="22.3. Другие операции над файлами"></a>22.3. Другие операции над файлами
</div>

<p>Функция <code>tmpfile</code> возвращает указатель на временный файл, открытый для чтения/записи. Этот файл будет автоматически удален по завершению программы</p>

<p>Функция <code>flush</code> сбрасывает все буферы для файлов. Подобно write, вы вызываете ее как функцию <code>io.flush()</code> для сброса буферов для текущего выходного файла или же как метод <code>f:flush()</code> для сброса буферов конкретного файла <code>f</code>.</p>

<p>Метод <code>setvbuf</code> устанавливает режим буферизации для файла. Его первым аргументом является строка: "<code>nо</code>" означает никакой буферизации; "<code>full</code>" означает, что запись осуществляется, только когда буфер заполнен или вы явно сбрасываете буферы; "<code>line</code>" означает, что вывод буферизуется до поступления символа перевода строки. Для последних двух аргументов <code>setvbuf</code> допускает второй параметр, задающий размер буфера.</p>

<p>В большинстве систем стандартный файл для ошибок (<code>io.stderr</code>) не буферизуется, в то время как стандартный выходной файл (<code>io.stdout</code>) буферизуется в режиме строки. Поэтому если вы записываете незавершенные строки в стандартный вывод (например, индикатор прогресса операции), то для того, чтобы увидеть вывод, вам может понадобиться явный сброс буфера.</p>

<p>Метод <code>seek</code> может и возвращать, и задавать текущую позицию внутри файла. Его общей формой является <code>f:seek(whence, offset)</code>, где параметр <code>whence</code> - это строка, задающая, как надо интерпретировать параметр <code>offset</code>. Ее допустимыми значениями являются "<code>set</code>", когда смещение трактуется от начала файла, "<code>cur</code>", когда смещение трактуется от текущего положения, и "<code>end</code>", когда смещение трактуется относительно конца файла. Независимо от значения параметра <code>whence</code> вызов возвращает значение текущего смещения относительно начала файла.</p>

<p>Значениями по умолчанию являются "<code>cur</code>" для <code>whence</code> и 0 для <code>offset</code>. Поэтому вызов <code>file:seek()</code> просто возвращает текущее положение внутри файла, не меняя его; вызов <code>file:seek("set")</code> переставляет указатель на начало файла и возвращает ноль; и вызов <code>file:seek("end")</code> переставляет указатель на конец файла и возвращает его длину. Следующая функция возвращает размер файла, не меняя текущую позицию внутри файла:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;fsize&nbsp;<font color=FF0000>(</font>file<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;current&nbsp;<font color=FF0000>=</font>&nbsp;file<font color=FF0000>:</font><font color=FF8000>seek</font><font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;получить&nbsp;текущее&nbsp;положение</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;size&nbsp;<font color=FF0000>=</font>&nbsp;file<font color=FF0000>:</font><font color=FF8000>seek</font><font color=FF0000>(</font><font color=8888CC>"end"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;получить&nbsp;размер&nbsp;файла</font>
&nbsp;&nbsp;file<font color=FF0000>:</font><font color=FF8000>seek</font><font color=FF0000>(</font><font color=8888CC>"set"</font><font color=FF0000>,</font>&nbsp;current<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;восстановить&nbsp;положение</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;size
<font color=0000DF>end</font>
</pre>


<p>В случае ошибки все эти функции возвращают <b>nil</b> и сообщение об ошибке.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="22. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 22.1.</b><br>
Напишите программу, которая читает текстовый файл и выводит его строки, отсортированные в алфавитном порядке. Если программа была вызвана без аргументов, то она должна брать данные из стандартного ввода и выводить данные в стандартный вывод. Если программа была вызвана с одним аргументом - именем файла, то она должна прочитать все данные из файла и записать вывод в стандартный вывод. При вызове с двумя аргументами она должна читать из первого файла и писать во второй файл.</p>

<hr color="#99CCFF">

<p><b>Упражнение 22.2.</b><br>
Измените предыдущую программу так, чтобы она запрашивала подтверждение, если для вывода задано имя существующего файла.</p>

<hr color="#99CCFF">

<p><b>Упражнение 22.3.</b><br>
Сравните быстродействие программы на Lua, которая копирует стандартный ввод на стандартный вывод для следующих случаев:</p>

<ul>
  <li>Копирование осуществляется побайтно.</li>
  <li>Копирование осуществляется построчно.</li>
  <li>Копирование осуществляется блоками по 8К.</li>
  <li>Копируется сразу весь файл.</li>
</ul>

<p>Для последнего варианта насколько большим может быть входной файл?</p>

<hr color="#99CCFF">

<p><b>Упражнение 22.4.</b><br>
Напишите программу, которая печатает последнюю строку текстового файла. Постарайтесь избежать чтения всего файла, когда файл большой и по нему можно перемещаться.</p>

<hr color="#99CCFF">

<p><b>Упражнение 22.5.</b><br>
Обобщите предыдущую программу так, чтобы она печатала последние n строк текстового файла. Опять постарайтесь избежать чтения всего файла, когда он большой.</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 23. Библиотека функций операционной системы"></a>Глава 23. Библиотека функций операционной системы
</div>

<p>Библиотека функций операционной системы включает в себя функции для работы с файлами (не чтения и записи), получения текущих даты и времени и ряда других возможностей операционной системы. Она определена в таблице <code>os</code>. Переносимость Lua сказалась на этой библиотеке: поскольку Lua написана на чистом ANSI С, то эта библиотека включает в себя только ту функциональность, которая предоставляется ANSI С. Многие возможности операционной системы, такие как работа с каталогами и сокетами, не входят в этот стандарт, и библиотека их не предоставляет. Существуют другие библиотеки, не включенные в основную поставку, которые предоставляют расширенный доступ к операционной системе. Примерами таких библиотек являются <code>posix</code>, предоставляющая функциональность POSIX.1, <code>luasocket</code> для работы с сетью и <code>LuaFileSystem</code> для работы с каталогами и атрибутами файлов.</p>

<p>Все, что предоставляет данная библиотека для работы с файлами, - это функции <code>os.rename</code> для изменения имени файла и <code>os.remove</code> для удаления файла.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="23.1. Дата и время"></a>23.1. Дата и время
</div>

<p>Вся функциональность для работы с датами и временем в Lua предоставляется двумя функциями - <code>time</code> и <code>date</code>.</p>

<p>Функция <code>time</code>, когда она вызвана без аргументов, возвращает текущую дату и время, представленные как число (В большинстве систем это число - число секунд с какого-то определенного момента.) Когда в качестве аргумента была передана таблица, то функция возвращает число, задаваемое этой таблицей. У подобных таблиц могут быть следующие поля:</p>


<table>
  <tr>
    <td width="15%"><code>year</code></td>
    <td><i>Год</i></td>
  </tr>
  <tr>
    <td width="10%"><code>month</code></td>
    <td><i>01-12</i></td>
  </tr>
  <tr>
    <td width="10%"><code>day</code></td>
    <td><i>01-31</i></td>
  </tr>
  <tr>
    <td width="10%"><code>hour</code></td>
    <td><i>00-23</i></td>
  </tr>
  <tr>
    <td width="10%"><code>min</code></td>
    <td><i>00-59</i></td>
  </tr>
  <tr>
    <td width="10%"><code>sec</code></td>
    <td><i>00-59</i></td>
  </tr>
  <tr>
    <td width="10%"><code>isdst</code></td>
    <td><i>Логическое значение, равное</i> <b>true</b><i>, если задействован перевод времени</i></td>
  </tr>
</table>


<p>Первые три поля из этой таблицы обязательны; если остальные не заданы, то значением по умолчанию является полдень (12:00:00). В UNIX-системе (где время отсчитывается, начиная с 00:00:00 1 января 1970 г.) в Рио де Жанейро мы получаем следующие значения:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.time</font><font color=FF0000>{</font>year<font color=FF0000>=</font><font color=AC00A9>1970</font><font color=FF0000>,</font>&nbsp;month<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;day<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;hour<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>})</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;10800</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.time</font><font color=FF0000>{</font>year<font color=FF0000>=</font><font color=AC00A9>1970</font><font color=FF0000>,</font>&nbsp;month<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;day<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;hour<font color=FF0000>=</font><font color=AC00A9>0</font><font color=FF0000>,</font>&nbsp;sec<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>})</font>&nbsp;<font color=008000>--&gt;&nbsp;10801</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.time</font><font color=FF0000>{</font>year<font color=FF0000>=</font><font color=AC00A9>1970</font><font color=FF0000>,</font>&nbsp;month<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;day<font color=FF0000>=</font><font color=AC00A9>1</font><font color=FF0000>})</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;54000</font>
</pre>

<p>(Обратите внимание, что 10 800 - это 3 часа, выраженные в секундах, 54 000 - это 10 800 плюс 12 часов, выраженные в секундах.)</p>

<p>Функция <code>date</code>, несмотря на свое имя, является обратной функцией к <code>time</code>. Она переводит число, представляющее дату и время, обратно к высокоуровневому представлению. Ее первый параметр это <i>строка формата</i>, описывающая, какое именно представление мы хотим. Второй параметр - это число, описывающее дату и время, если второй параметр не задан, то он считается равным текущему времени.</p>

<p>Для того чтобы получить дату как таблицу, мы используем формат "<code>*t</code>". Например, вызов <code>os.date("*t", 906000490)</code> вернет следующую таблицу:</p>

<pre class="code">
<font color=FF0000>{</font>year&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1998</font><font color=FF0000>,</font>&nbsp;month&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>9</font><font color=FF0000>,</font>&nbsp;day&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>16</font><font color=FF0000>,</font>&nbsp;yday&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>259</font><font color=FF0000>,</font>&nbsp;wday&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>4</font><font color=FF0000>,</font>
&nbsp;hour&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>23</font><font color=FF0000>,</font>&nbsp;min&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>48</font><font color=FF0000>,</font>&nbsp;sec&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font><font color=FF0000>,</font>&nbsp;isdst&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>false</font><font color=FF0000>}</font>
</pre>

<p>Обратите внимание, что, кроме полей, используемых функцией <code>os.time</code>, в таблице, созданной <code>os.date</code>, также задаются день недели (<code>wday</code>, 1 - это воскресенье) и день в году (<code>yday</code>, 1 - это 1 января).</p>

<p>Для других значений строки формата <code>os.date</code> возвращает дату как копию строки формата, где определенные теги заменены информацией о дате и времени. Тег состоит из символа '<code>%</code>', за которым следует буква, как в следующих примерах:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.date</font><font color=FF0000>(</font><font color=8888CC>"a&nbsp;%A&nbsp;in&nbsp;%B"</font><font color=FF0000>))</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;a&nbsp;Tuesday&nbsp;in&nbsp;May</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.date</font><font color=FF0000>(</font><font color=8888CC>"%x"</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>906000490</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;09/16/1998</font>
</pre>

<p>Все представления соответствуют текущей локали. Например, для локали <i>Brazil-Portuguese</i> <code>%В</code> даст "<code>setembro</code>" и <code>%х</code> даст "<code>16/09/98</code>".</p>

<p>Следующая таблица показывает каждый тег, обьясняет его значение, и дает его значение для 16 сентября 1998 года, 23:48:10.</p>


<table>
  <tr>
    <td width="10%"><code>%a</code></td>
    <td><i>Сокращенное название дня недели (например, Wed)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%A</code></td>
    <td><i>Полное название дня недели (например, Wednesday)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%b</code></td>
    <td><i>Сокращенное название месяца (например, Sep)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%B</code></td>
    <td><i>Полное название месяца(например, September)</i></td>
  </tr>
  <tr>
    <td width="10%"><code><code>%с</code></code></td>
    <td><i>Дата и время(например, 09/16/98 23:48:10)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%d</code></td>
    <td><i>День месяца (например, 16)[01-31]</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%H</code></td>
    <td><i>Час в 24-часовой системе (например, 23)[00-23]</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%I</code></td>
    <td><i>Час в 12-часовой системе (например, 11)[00-11]</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%j</code></td>
    <td><i>День года (например, 259) 1001-3661</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%M</code></td>
    <td><i>Минуты (например, 48)[00-59]</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%m</code></td>
    <td><i>Месяц (например, 09)[01-12]</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%p</code></td>
    <td><i>"am" или "рm"</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%S</code></td>
    <td><i>Секунды (10)[00-60]</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%w</code></td>
    <td><i>День недели (3)[0-6=Воскресенье-суббота]</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%x</code></td>
    <td><i>Дата (например, 09/16/98)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%X</code></td>
    <td><i>Время (например, 23:48:10)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%y</code></td>
    <td><i>Год как две цифры (например, 98)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%Y</code></td>
    <td><i>Полный год (например, 1998)</i></td>
  </tr>
  <tr>
    <td width="10%"><code>%%</code></td>
    <td><i>Знак %</i></td>
  </tr>
</table>

<p>Если вы вызовете <code>date</code> вообще без аргументов, то будет использован формат <code>%с</code>, то есть полная дата и время в подходящем формате. Обратите внимание, что представления для <code>%х</code>, <code>%X</code> и <code>%с</code> зависят от локали и системы. Если вам нужно фиксированное представление, например <code>уу/mm/уууу</code>, то используйте явную строку формата вроде "<code>%m/%d/%Y</code>".</p>

<p>Функция <code>os.clock</code> возвращает число секунд CPU, потраченных па выполнение программы. Обычно она используется для замера производительности:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>os.clock</font><font color=FF0000>()</font>
<font color=0000DF>local</font>&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>0</font>
<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>100000</font>&nbsp;<font color=0000DF>do</font>&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;s&nbsp;<font color=FF0000>+</font>&nbsp;i&nbsp;<font color=0000DF>end</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"elapsed&nbsp;time:&nbsp;%.2f\n"</font><font color=FF0000>,</font>&nbsp;<font color=FF8000>os.clock</font><font color=FF0000>()</font>&nbsp;<font color=FF0000>-</font>&nbsp;x<font color=FF0000>))</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="23.2. Другие вызовы системы"></a>23.2. Другие вызовы системы
</div>

<p>Функция <code>os.exit</code> прерывает выполнение программы. Ее необязательный первый аргумент - это код, который вернет программа при завершении. Он может быть числом (ноль соответствует успешному завершению) или логическим значением (<b>true</b> означает успешное завершение). Если необязательный второй аргумент равен <b>true</b>, то закрывается состояние Luaю При этом вызываются финализаторы и освобождается память, занятая состоянием Lua.(Обычно эта финализация не является необходимой, так как большинство операционных систем освобождает ресурсы при завершении процесса.)</p>

<p>Функция <code>os.getenv</code> возвращает значение переменной окружения. Она берет на вход имя переменной и возвращает строку, содержащую ее значение:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.getenv</font><font color=FF0000>(</font><font color=8888CC>"HOME"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;/home/lua</font>
</pre>

<p>Для неопределенных переменных вызов возвращает <b>nil</b>.</p>

<p>Функция <code>os.execute</code> выполняет команду операционной системы. Она эквивалентна функции <code>system</code> в языке С. На вход она получает строку с командой и возвращает информацию о том, как команда была завершена. Первое возвращаемое значение логическое, <b>true</b> означает успешное завершение без ошибок. Второе возвращаемое значение - это строка, "<code>exit</code>", если программа завершилась нормально, и "<code>signal</code>", если она была завершена по сигналу. Третье возвращаемое значение - это статус возврата, если программа завершилась нормально, или номер сигнала, если она завершилась по сигналу. В качестве примера использования и в Windows, и в UNIX вы можете использовать следующую функцию для создания новых каталогов:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;createDir&nbsp;<font color=FF0000>(</font>dirname<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=FF8000>os.execute</font><font color=FF0000>(</font><font color=8888CC>"mkdir&nbsp;"</font>&nbsp;<font color=FF0000>..</font>&nbsp;dirname<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p>Функция <code>os.execute</code> - очень мощный инструмент, но она сильно зависит от используемой системы.</p>

<p>Функция <code>os.setlocale</code> задает текущую локаль, которая будет использоваться программой на Lua. Локали определяют поведение, которое зависит от культурных и языковых различий. Функция <code>os.setlocale</code> получает на вход два строковых аргумента: имя локали и категорию, которая определяет, что именно будет затронуто этой локалью. У локалей есть шесть возможных категорий:</p>

<table>
  <tr>
    <td width="15%"><code>"collate"</code></td>
    <td><i>управляет упорядочением строк</i></td>
  </tr>
  <tr>
    <td width="15%"><code>"ctype"</code></td>
    <td><i>управляет типами отдельных символов(то есть что именно является буквами) и преобразованием между строчными и заглавными буквами</i></td>
  </tr>
  <tr>
    <td width="15%"><code>"monetary"</code></td>
    <td><i>не влияет на программы на Lua</i></td>
  </tr>
  <tr>
    <td width="15%"><code>"numeric"</code></td>
    <td><i>управляет тем, как форматируются числа</i></td>
  </tr>
  <tr>
    <td width="15%"><code>"time"</code></td>
    <td><i>управляет тем, как форматируются дата и время (то есть функцией <code>os.date</code>)</i></td>
  </tr>
  <tr>
    <td width="15%"><code>"all"</code></td>
    <td><i>управляет всеми описанными категориями</i></td>
  </tr>
</table>

<p>По умолчанию категория - это "<code>all</code>", то есть если вы вызвали <code>setlocale</code> только с именем локали, то это повлияет на все категории. Функция <code>setlocale</code> возвращает имя локали и <b>nil</b> в случае ошибки(обычно, так как система не поддерживает данную локаль).</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.setlocale</font><font color=FF0000>(</font><font color=8888CC>"ISO-8859-1"</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"collate"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;ISO-8859-1</font>
</pre>

<p>Категория "<code>numeric</code>" несет в себе некоторые тонкости. Поскольку португальский и ряд других языков используют запятую вместо точки для представления десятичных чисел, то локаль меняет то, как Lua читает и выводит числа. Но локаль не меняет то, как Lua разбирает числа внутри программы. Если вы используете Lua для создания кода на Lua, то в следующем примере у вас могут быть проблемы:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>os.setlocale</font><font color=FF0000>(</font><font color=8888CC>"pt_BR"</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;pt_BR</font>
s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8888CC>"return&nbsp;("</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=AC00A9>3.4</font>&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>")"</font>
<font color=0080C0>print</font><font color=FF0000>(</font>s<font color=FF0000>)</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&gt;&nbsp;return&nbsp;(3,4)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=0080C0>loadstring</font><font color=FF0000>(</font>s<font color=FF0000>))</font>
<font color=008000>--&gt;&nbsp;nil&nbsp;[string&nbsp;"return&nbsp;(3,4)"]:1:&nbsp;')'&nbsp;expected&nbsp;near&nbsp;','</font>
</pre>

<p>Для того чтобы избегать подобных проблем, убедитесь, что Lua использует стандартную локаль С для создания фрагментов кода.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="23. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 23.1.</b><br>
Напишите функцию, которая возвращает дату и время спустя ровно месяц от текущей даты (предполагая стандартное кодирование даты как числа).</p>

<hr color="#99CCFF">

<p><b>Упражнение 23.2.</b><br>
Напишите функцию, которая получает дату и время, представленные как число, и возвращает число секунд, прошедших с начала дня.</p>

<hr color="#99CCFF">

<p><b>Упразднение 23.3.</b><br>
Можете ли вы использовать <code>os.execute</code> для того, чтобы изменить текущий каталог вашей программы на Lua? Почему?</p>

<!-- ================================================================================ -->
<div class="head">
  <a name="Глава 24. Отладочная библиотека"></a>Глава 24. Отладочная библиотека
</div>

<p>Отладочная библиотека не даст вам отладчик для Lua, но она предложит все те функции, которые необходимы для написания вашего собственного отладчика. Из соображения быстродействия официальный интерфейс к этим функциям - это С API. Отладочная библиотека в Lua - это способ получить доступ к этим функциям прямо из Lua.</p>

<p>В отличие от других библиотек, вы должны пользоваться данными функциями очень осторожно. Во-первых, часть этой функциональности не отличается хорошим быстродействием. Во-вторых, она нарушает некоторые правила языка, например то, что вы не можете обратиться к локальной переменной вне области ее действия. Довольно часто вам не будет хотеться использовать данную библиотеку в окончательной версии вашей программы.</p>

<p>Отладочная библиотека состоит из функций двух типов: <i>функции для доступа к обьектам</i> (<i>introspective functions</i>) и ловушки. Функции для доступа к обьектам позволяют изучать различные стороны выполняемой программы, такие как стек вызовов, текущая выполняемая строка, значения и имена локальных переменных. Ловушки позволяют нам отслеживать выполнение программы.</p>

<p>Важным понятием в отладочной библиотеке является <i>уровень в стеке</i>. Уровень в стеке - это число, которое относится к конкретной функции, активной в данный момент: у функции, вызвавшей отладочную библиотеку, уровень <code>1</code>, функция, которая вызвала эту функцию, имеет уровень <code>2</code> и т. д.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="24.1. Возможности по доступу (интроспекции)"></a>24.1. Возможности по доступу (интроспекции)
</div>

<p>Главной функцией для доступа (<i>интроспекции</i>) является <code>debug.getinfo</code>. Ее первый параметр может быть функцией или уровнем в стеке. Когда вы вызываете <code>debug.getinfo(foo)</code> для какой-то функции <code>foo</code>, то вы получите таблицу с данными об этой функции. Таблица может иметь следующие поля:</p>

<table>
  <tr>
    <td valign="top" width="20%"><code>source</code></td>
    <td><i>где функция была определена. Если эта функция задана строкой (при помощи <code>loadstring</code>), то <code>source</code> равен этой строке. Если функция была определена в файле, то source - это имя файла, в начало которого вставлен символ '<code>@</code>'</i></td>
  </tr>
  <tr>
    <td valign="top" width="20%"><code>short_src</code></td>
    <td><i>короткая версия <code>source</code>(до 60 символов), полезна для сообщений об ошибках</i></td>
  </tr>
  <tr>
    <td valign="top" width="20%"><code>linedefined</code></td>
    <td><i>номер первой строки в <code>source</code>, где функция была определена</i></td>
  </tr>
  <tr>
    <td valign="top" width="20%"><code>lastlinedefined</code></td>
    <td><i>номер последней строки в <code>source</code>, где функция была определена</i></td>
  </tr>
  <tr>
    <td valign="top" width="20%"><code>what</code></td>
    <td><i>что это за функция. Возможные значения: "<code>Lua</code>", если это обычная функция на Lua, "<code>C</code>", если это функция на С, или "<code>main</code>", если это главная часть блока</i></td>
  </tr>
  <tr>
    <td valign="top" width="20%"><code>name</code></td>
    <td><i>подходящее для функции имя</i></td>
  </tr>
  <tr>
    <td valign="top" width="20%"><code>namewhat</code></td>
    <td><i>что обозначает предыдущее поле. Возможные значения: "<code>global</code>", "<code>local</code>", "<code>method</code>", "<code>field</code>" и <code>""</code>(пустая строка). Пустая строка означает, что Lua не нашел имени для функции</i></td>
  </tr>
  <tr>
    <td valign="top" width="20%"><code>nups</code></td>
    <td><i>количество <code>upvalue</code> для этой функции</i></td>
  </tr>
  <tr>
    <td valign="top" width="20%"><code>activelines</code></td>
    <td><i>таблица, представляющая множество активных строк функции. <i>Активная строка</i> - это строка с каким-то кодом, в отличие от пустых строк и строк, состоящих только из комментариев (типичное использование этой функции - это установка точек прерывания (<code>breakpoint</code>). Большинства отладчиков не позволяет ставить точки прерывания не на активных строках)</i></td>
  </tr>
  <tr>
    <td valign="top"width="20%"><code>foo</code></td>
    <td><i>это функция на С, у Lua нет почти никаких данных о ней. В этом случае только поля <code>what</code>, <code>name</code> и <code>namewhat</code> содержат полезную информацию</i></td>
  </tr>
</table>

<p>Когда вы вызываете <code>debug.getinfo(n)</code> для какого-то числа <code>n</code>, вы получаете данные о функции, находящейся на соответствующем месте в стеке вызовов. Например, если <code>n</code> равно <code>1</code>, то вы получаете данные о текущей функции.(Когда <code>n</code> равно <code>0</code>, вы получаете данные о самой функции <code>getinfo</code>.) Если <code>n</code> больше, чем число активных функций в стеке, то <code>debug.getinfo</code> возвращает <b>nil</b>. Когда вы запрашиваете информацию об активной функции, передавая в качестве аргумента число, возвращаемая таблица будет иметь одно дополнительное поле <code>currentline</code>, содержащее номер строки внутри функции в данный момент. А поле func содержит соответствующую функцию.</p>

<p>Поле <code>name</code> не так просто, как это кажется. Поскольку функции -это обьекты в Lua, то функция может вообще не иметь имени или иметь несколько имен. Lua пытается найти имя функции, обратившись к коду, который ее вызвал. Этот метод работает, только если мы вызываем <code>getinfo</code> с числом в качестве аргумента, то есть просим информацию о конкретном вызове.</p>

<p>Функция <code>getinfo</code> не очень эффективна. Lua содержит отладочную информацию в форме, которая не оказывает отрицательного влияния на быстродействие программы; эффективное получение этой информации не является здесь главной целью. Для того чтобы получить большее быстродействие, у <code>getinfo</code> есть необязательный второй параметр, который сообщает, какую именно информацию нужно вернуть. Таким образом, функция не тратит лишнее время на получение ненужной информации. Этот параметр является строкой, где каждая буква соответствует группе полей согласно следующей таблице:</p>

<table>
  <tr>
     <td width="10%"><code>'n'</code></td>
     <td><i>name, namewhat</i></td>
  </tr>
  <tr>
     <td width="10%"><code>'f'</code></td>
     <td><i>func</i></td>
  </tr>
  <tr>
     <td width="10%"><code>'S'</code></td>
     <td><i>source, short src, what, linedefined, lastlinedefined</i></td>
  </tr>
  <tr>
     <td width="10%"><code>'l'</code></td>
     <td><i>currentline</i></td>
  </tr>
  <tr>
     <td width="10%"><code>'L'</code></td>
     <td><i>activelines</i></td>
  </tr>
  <tr>
     <td width="10%"><code>'u'</code></td>
     <td><i>nup</i></td>
  </tr>
</table>

<p>Следующая функция иллюстрирует использование <code>debug.getinfo</code>. Она распечатывает текущий стек вызовов:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;traceback&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;level&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.huge</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;info&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getinfo</font><font color=FF0000>(</font>level<font color=FF0000>,</font>&nbsp;<font color=8888CC>"Sl"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;info&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;info<font color=FF0000>.</font>what&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"C"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=008000>--&nbsp;это&nbsp;функция&nbsp;на&nbsp;С?</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>level<font color=FF0000>,</font>&nbsp;<font color=8888CC>"C&nbsp;function"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;<font color=008000>--&nbsp;функции&nbsp;на&nbsp;Lua</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font><font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"[%s]:%d"</font><font color=FF0000>,</font>&nbsp;info<font color=FF0000>.</font>short_src<font color=FF0000>,</font>&nbsp;info<font color=FF0000>.</font>currentline<font color=FF0000>))</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Эту функцию легко можно улучшить, используя дополнительные данные из <code>getinfo</code>. В действительности в отладочной библиотеке уже есть такая функция - <code>traceback</code>. В отличие от нашей функции, <code>debug.traceback</code> не печатает стек вызовов, а возвращает (обычно длинную) строку со стеком вызовов.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="24.1. Доступ к локальным переменным"></a>Доступ к локальным переменным
</div>

<p>Мы можем изучать локальные переменные любой активной функции при помощи функции <code>debug.getlocal</code>. У этой функции два параметра: уровень в стеке интересующей нас функции и номер переменной. Она возвращает два значения: имя переменной и ее значение. Если переданный номер переменной больше, чем число локальных неременных, то <code>getlocal</code> возвращает <b>nil</b>. Если переданный уровень в стеке не является допустимым, то функция вызывает ошибку.(Для проверки допустимости уровня в стеке мы можем использовать <code>debug.getinfo</code>.)</p>

<p>Lua нумерует локальные переменные в том порядке, в котором появляются в функции, считая только активные переменные в данной области видимости. Например, рассмотрим следующую функцию:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;foo&nbsp;<font color=FF0000>(</font>a<font color=FF0000>,</font>&nbsp;b<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x
&nbsp;&nbsp;<font color=0000DF>do</font>&nbsp;<font color=0000DF>local</font>&nbsp;c&nbsp;<font color=FF0000>=</font>&nbsp;a&nbsp;<font color=FF0000>-</font>&nbsp;b&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;name<font color=FF0000>,</font>&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getlocal</font><font color=FF0000>(</font><font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;a<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;name&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>name<font color=FF0000>,</font>&nbsp;value<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;<font color=FF0000>=</font>&nbsp;a&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Вызов <code>foo(10,20)</code> напечатает следующее:</p>

<pre class="code">
a&nbsp;<font color=AC00A9>10</font>
b&nbsp;<font color=AC00A9>20</font>
x&nbsp;<font color=0000DF>nil</font>
a&nbsp;<font color=AC00A9>4</font>
</pre>

<p>Переменная с индексом <code>1</code> - это <code>а</code> (первый параметр), переменная с индексом <code>2</code> - это <code>b</code>, <code>3</code> - <code>х</code>, переменная с индексом <code>4</code> - это другая переменная <code>а</code>. В момент вызова <code>getlocal</code> переменная <code>с</code> уже вышла из своей области видимости, в то время как <code>name</code> и <code>value</code> еще не вошли в свою область видимости (Вспомните, что локальная переменная видна только после инициализирующего ее кода.)</p>

<p>Начиная с Lua 5.2, отрицательные индексы возвращают информацию о дополнительных аргументах функции: индекс <code>-1</code> соответствует первому дополнительному аргументу. В этом случае имя переменной - это всегда "<code>(*vararg)</code>".</p>

<p>Вы также можете изменять значения локальных переменных при помощи функции <code>debug.setlocal</code>. Ее первые два параметра - это уровень в стеке и индекс переменной, как и в <code>getlocal</code>. Ее третий параметр - это новое значение для переменной. Функция возвращает имя переменной или <b>nil</b> в случае недопустимого индекса.</p>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="24.1. Доступ к нелокальным переменным"></a>Доступ к нелокальным переменным
</div>

<p>Отладочная библиотека также позволяет обращаться к нелокальным переменным, используемым в функции на Lua, при помощи функции <code>getupvalue</code>. В отличие от локальных переменных, нелокальные переменные, используемые в функции, существуют, даже если функция не активна (собственно, это именно о замыканиях). Поэтому первый аргумент для <code>getupvalue</code> - это не уровень в стеке, а функция (точнее, замыкание). Второй аргумент - это индекс переменной. Lua нумерует нелокальные переменные в том порядке, в котором они впервые встречаются в функции, но этот порядок не важен, поскольку функция не может обратиться сразу к двум нелокальным переменным с одним и тем же именем.</p>

<p>Вы также можете изменять значения нелокальных переменных при помощи функции <code>debug.setupvalue</code>. Как вы можете ожидать, у нее три параметра: замыкание, имя переменной и новое значение. Как и <code>setlocal</code>, она возвращает имя переменной или <b>nil</b> в случае неверного индекса.</p>

<p><a href="#листинг 24.1">Листинг 24.1</a> показывает, как мы можем получить доступ к значению любой переменной по ее имени. Параметр <code>level</code> сообщает, к какой функции на стеке нам нужно обратиться, плюс один нужен для того, чтобы не включать саму функцию <code>getvarvalue</code>. Функция <code>getvarvalue</code> сначала пытается найти локальную переменную с заданным именем. Если таких переменных несколько, то она использует переменную с наибольшим индексом. Если найти локальную переменную с заданным именем не удается, то делается попытка найти нелокальную переменную с этим именем. Для этого при помощи <code>debug.getinfo</code> получается вызывающее замыкание, и затем все его нелокальные переменные перебираются. Наконец, если не удается найти нелокальную переменную с заданным именем, то ищется глобальная переменная с заданным именем: функция вызывает себя рекурсивно для доступа к надлежащей переменной <code>_ENV</code>, в которой ищется соответствующая переменная.</p>

<p><a name="листинг 24.1"></a><b class="sect">Листинг 24.1</b>. Получение значения переменной по имени</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;getvarvalue&nbsp;<font color=FF0000>(</font>name<font color=FF0000>,</font>&nbsp;level<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;value
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;found&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>false</font>
&nbsp;&nbsp;
&nbsp;&nbsp;level&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>(</font>level&nbsp;<font color=0000DF>or</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>)</font>&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=008000>--&nbsp;пробуем&nbsp;локальные&nbsp;переменные</font>
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.huge</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;n<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getlocal</font><font color=FF0000>(</font>level<font color=FF0000>,</font>&nbsp;i<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;n&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>==</font>&nbsp;name&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;<font color=FF0000>=</font>&nbsp;v
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0000DF>true</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;found&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;value&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;
&nbsp;&nbsp;<font color=008000>--&nbsp;пробуем&nbsp;нелокальные&nbsp;переменные</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;func&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getinfo</font><font color=FF0000>(</font>level<font color=FF0000>,</font>&nbsp;<font color=8888CC>"f"</font><font color=FF0000>).</font>func
&nbsp;&nbsp;<font color=0000DF>for</font>&nbsp;i&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=8000FF>math.huge</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;n<font color=FF0000>,</font>&nbsp;v&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getupvalue</font><font color=FF0000>(</font>func<font color=FF0000>,</font>&nbsp;i<font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;<font color=0000DF>not</font>&nbsp;n&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n&nbsp;<font color=FF0000>==</font>&nbsp;name&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>return</font>&nbsp;v&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=008000>--&nbsp;не&nbsp;найдено;&nbsp;пробуем&nbsp;получить&nbsp;значение&nbsp;из&nbsp;окружения</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;env&nbsp;<font color=FF0000>=</font>&nbsp;getvarvalue<font color=FF0000>(</font><font color=8888CC>"_ENV"</font><font color=FF0000>,</font>&nbsp;level<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;env<font color=FF0000>[</font>name<font color=FF0000>]</font>
<font color=0000DF>end</font>
</pre>

<!-- ================================================================================ -->
<div class="subsect">
  <a name="24.1. Доступ к другим сопрограммам"></a>Доступ к другим сопрограммам
</div>

<p>Все интроспективные функции из отладочной библиотеки принимают в качестве необязательного (и первого) аргумента сопрограмму, таким образом, мы можем изучать сопрограмму со стороны. Давайте рассмотрим следующий пример:</p>

<pre class="code">
co&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>coroutine.create</font><font color=FF0000>(</font><font color=0000DF>function</font>&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;x&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>10</font>
&nbsp;&nbsp;<font color=FF8000>coroutine.yield</font><font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0080C0>error</font><font color=FF0000>(</font><font color=8888CC>"some&nbsp;error"</font><font color=FF0000>)</font>
<font color=0000DF>end</font><font color=FF0000>)</font>

<font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>)</font>
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>debug.traceback</font><font color=FF0000>(</font>co<font color=FF0000>))</font>
</pre>

<p>Вызов <code>traceback</code> выполнится для сопрограммы <code>со</code>, давая в результате что-то вроде:</p>

<pre class="code">
stack traceback:
    [C]: in function 'yield'
    temp:3: in function &lt;temp:l&gt;
</pre>

<p>Этот стек не включает в себя вызов <code>resume</code>, поскольку сопрограмма и главная программа выполняются на разных стеках.</p>

Когда сопрограмма вызывает ошибку, то ее стек не раскручивается. Это значит, что в случае ошибки мы можем изучать его. Продолжая наш пример, попробуем продолжить нашу сопрограмму после ошибки:

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>coroutine.resume</font><font color=FF0000>(</font>co<font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;false&nbsp;temp:4:&nbsp;some&nbsp;error</font>
</pre>

<p>Теперь если мы распечатаем стек, то мы получим что-то вроде:</p>

<pre class="code">
stack traceback:
    [C]: in function 'error'
    temp:4: in function &lt;temp:l&gt;
</pre>

<p>Мы также можем изучать локальные переменные сопрограммы даже после ошибки:</p>

<pre class="code">
<font color=0080C0>print</font><font color=FF0000>(</font><font color=FF8000>debug.getlocal</font><font color=FF0000>(</font>co<font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>,</font>&nbsp;<font color=AC00A9>1</font><font color=FF0000>))</font>&nbsp;<font color=008000>--&gt;&nbsp;x&nbsp;10</font>
</pre>

<!-- ================================================================================ -->
<div class="section">
  <a name="24.2. Ловушки(hooks)"></a>24.2. Ловушки(hooks)
</div>

<p>Механизм ловушек позволяет нам зарегистрировать функцию, которая будет вызвана при наступлении определенных событий во время выполнения программы. Существует четыре типа событий, которые могут вызвать ловушки:</p>

<ul>
  <li>событие вызова происходит, когда Lua вызывает функцию</li>
  <li>событие возврата происходит при возврате из функции</li>
  <li>событие строки происходит, когда Lua начинает выполнение следующей строки</li>
  <li>событие счетчика происходит после заданного количества команд</li>
</ul>

<p>Lua вызывает ловушки с единственным аргументом, строкой, описывающей событие, которое привело в вызову: "<code>call</code>" (или "<code>tail call</code>"), "<code>return</code>", "<code>line</code>" или "<code>count</code>". Для события строки также передается второй аргумент, новый номер строки. Для получения дополнительной информации внутри ловушки следует использовать <code>debug.getinfo</code>.</p>

<p>Для того чтобы зарегистрировать ловушку, мы вызываем функцию <code>debug.sethook</code> с двумя или тремя аргументами: первый аргумент -это соответствующая функция; второй аргумент - это строка-маска, описывающая, какие именно события мы хотим отслеживать, и необязательный третий аргумент - это число, задающее с какой частотой мы хотим получить события счетчика. Для того чтобы отслеживать события вызова, возврата и строки, мы добавляем буквы '<code>с</code>', '<code>r</code>' и '<code>l</code>' к строке-маске. Для отслеживания событий счетчика мы просто передаем счетчик как третий аргумент. Для убирания всех ловушек просто вызовите <code>sethook</code> без параметров.</p>

<p>В качестве примера следующий код устанавливает примитивную ловушку, которая для каждой очередной выполняемой стоки печатает ее номер:</p>

<pre class="code">
<font color=0080C0>debug</font><font color=FF0000>.</font>sethook<font color=FF0000>(</font><font color=0080C0>print</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"l"</font><font color=FF0000>)</font>
</pre>

<p>Этот вызов устанавливает <code>print</code> как функцию-ловушку и задает ее вызов только для событий строки. Более сложная функция-ловушка может использовать <code>getinfo</code> для того, чтобы добавить к выдаче имя текущего файла:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;trace&nbsp;<font color=FF0000>(</font>event<font color=FF0000>,</font>&nbsp;line<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;s&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getinfo</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>).</font>short_src
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>s&nbsp;<font color=FF0000>..</font>&nbsp;<font color=8888CC>":"</font>&nbsp;<font color=FF0000>..</font>&nbsp;line<font color=FF0000>)</font>
<font color=0000DF>end</font>

<font color=0080C0>debug</font><font color=FF0000>.</font>sethook<font color=FF0000>(</font>trace<font color=FF0000>,</font>&nbsp;<font color=8888CC>"l"</font><font color=FF0000>)</font>
</pre>

<p>Полезной функцией для использования в ловушках является <code>debug.debug</code>. Эта простая функция печатает приглашение, читает с ввода и затем выполняет заданные команды. Она примерно эквивалентна следующему коду:</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;debug1&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>while</font>&nbsp;<font color=0000DF>true</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=FF8000>io.write</font><font color=FF0000>(</font><font color=8888CC>"debug&gt;&nbsp;"</font><font color=FF0000>)</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;line&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>io.read</font><font color=FF0000>()</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;line&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"cont"</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=0000DF>break</font>&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>load</font><font color=FF0000>(</font>line<font color=FF0000>))()</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Когда пользователь в ответ па приглашение вводит "<code>cont</code>", то эта функция завершается. Стандартная реализация очень простая и выполняет команды в глобальном окружении вне отлаживаемого кода. <a href="#упражнение 24.5">Упражнение 24.5</a> обсуждает более удачную реализацию.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="24.3. Профилирование"></a>24.3. Профилирование
</div>

<p>Несмотря на свое имя, отладочная библиотека также полезна и для не только отладочных задач. Типичной подобной задачей является профилирование (получение информации о времени, затрачиваемом на выполнении того или иного фрагмента кода). Для профилирования с учетом времени лучше использовать С-интерфейс. Цена вызова каждой Lua-ловушки довольно высока и может сильно исказить результаты. Однако для простого профилирования, считающего количество раз, код на Lua вполне подходит. В этом разделе мы напишем простейший профилировщик, который для каждой вызываемой функции сообщит, сколько раз она была вызвана за время выполнения программы.</p>

<p>Главной структурой данных в нашей программе будут две таблицы. Одна сопоставляет функциям их счетчики, а вторая сопоставляет функциям их имена. В качестве индексов для обеих этих таблиц будут выступать сами функции.</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;Counters&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
<font color=0000DF>local</font>&nbsp;Names&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF0000>{}</font>
</pre>

<p>Мы можем извлечь имена функций и после профилировки, но мы получим лучшие результаты, если будем получать имена функций, пока они активны, поскольку в этом случае Lua может посмотреть в поисках имени функции вызывающий ее код.</p>

<p>Теперь давайте определим функцию-ловушку. Ее задачей является получить вызванную функцию и увеличить соответствующий счетчик, также она собирает имена функций:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;<font color=0000DF>function</font>&nbsp;hook&nbsp;<font color=FF0000>()</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getinfo</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"f"</font><font color=FF0000>).</font>func
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;count&nbsp;<font color=FF0000>=</font>&nbsp;Counters<font color=FF0000>[</font>f<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;count&nbsp;<font color=FF0000>==</font>&nbsp;<font color=0000DF>nil</font>&nbsp;<font color=0000DF>then</font>&nbsp;<font color=008000>--&nbsp;функция&nbsp;'f'&nbsp;вызвана&nbsp;первый&nbsp;раз?</font>
&nbsp;&nbsp;&nbsp;&nbsp;Counters<font color=FF0000>[</font>f<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;&nbsp;&nbsp;Names<font color=FF0000>[</font>f<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;<font color=FF8000>debug.getinfo</font><font color=FF0000>(</font><font color=AC00A9>2</font><font color=FF0000>,</font>&nbsp;<font color=8888CC>"Sn"</font><font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>else</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;только&nbsp;увеличить&nbsp;значение&nbsp;счетчика</font>
&nbsp;&nbsp;&nbsp;&nbsp;Counters<font color=FF0000>[</font>f<font color=FF0000>]</font>&nbsp;<font color=FF0000>=</font>&nbsp;count&nbsp;<font color=FF0000>+</font>&nbsp;<font color=AC00A9>1</font>
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Следующим шагом является запуск программы с этой ловушкой. Мы будем считать, что главный блок программы находится в файле и имя этого файла передается как аргумент программе-профилировщику:</p>

<pre class="code">% lua profiler main-prog</pre>

<p>Тогда профилировщик может взять имя файла из <code>arg[1]</code>, установить ловушку и выполнить файл:</p>

<pre class="code">
<font color=0000DF>local</font>&nbsp;f&nbsp;<font color=FF0000>=</font>&nbsp;<font color=0080C0>assert</font><font color=FF0000>(</font><font color=0080C0>loadfile</font><font color=FF0000>(</font>arg<font color=FF0000>[</font><font color=AC00A9>1</font><font color=FF0000>]))</font>
<font color=0080C0>debug</font><font color=FF0000>.</font>sethook<font color=FF0000>(</font>hook<font color=FF0000>,</font>&nbsp;<font color=8888CC>"c"</font><font color=FF0000>)</font>&nbsp;<font color=008000>--&nbsp;установить&nbsp;ловушку</font>
f<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;выполнить&nbsp;профилируемую&nbsp;программу</font>
<font color=0080C0>debug</font><font color=FF0000>.</font>sethook<font color=FF0000>()</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=008000>--&nbsp;отключить&nbsp;ловушку</font>
</pre>

<p>Последним шагом является собственно показ результатов. Функция <code>getname</code> из <a href="#листинг 24.2">листинга 24.2</a> выдает для каждой функции соответствующее имя. Для того,чтобы избежать путаницы, к каждому имени добавляем место соответствующей функции в виде <i>файл:строка</i>. Если у функции нет имени, то мы печатаем только место. Если функция является функцией на С, то мы используем только ее имя (так как у нее нет места). С учетом этого ниже приводится код, печатающий информацию о вызовах:</p>

<pre class="code">
<font color=0000DF>for</font>&nbsp;func<font color=FF0000>,</font>&nbsp;count&nbsp;<font color=0000DF>in</font>&nbsp;<font color=0080C0>pairs</font><font color=FF0000>(</font>Counters<font color=FF0000>)</font>&nbsp;<font color=0000DF>do</font>
&nbsp;&nbsp;<font color=0080C0>print</font><font color=FF0000>(</font>getname<font color=FF0000>(</font>func<font color=FF0000>),</font>&nbsp;count<font color=FF0000>)</font>
<font color=0000DF>end</font>
</pre>

<p><a name="листинг 24.2"></a><b class="sect">Листинг 24.2</b>. Получение имени функции</p>

<pre class="code">
<font color=0000DF>function</font>&nbsp;getname&nbsp;<font color=FF0000>(</font>func<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;n&nbsp;<font color=FF0000>=</font>&nbsp;Names<font color=FF0000>[</font>func<font color=FF0000>]</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n<font color=FF0000>.</font>what&nbsp;<font color=FF0000>==</font>&nbsp;<font color=8888CC>"C"</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;n<font color=FF0000>.</font>name
&nbsp;&nbsp;<font color=0000DF>end</font>
&nbsp;&nbsp;<font color=0000DF>local</font>&nbsp;lc&nbsp;<font color=FF0000>=</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"[%s]:%d"</font><font color=FF0000>,</font>&nbsp;n<font color=FF0000>.</font>short_src<font color=FF0000>,</font>&nbsp;n<font color=FF0000>.</font>linedefined<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>if</font>&nbsp;n<font color=FF0000>.</font>what&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>"main"</font>&nbsp;<font color=0000DF>and</font>&nbsp;n<font color=FF0000>.</font>namewhat&nbsp;<font color=FF0000>~=</font>&nbsp;<font color=8888CC>""</font>&nbsp;<font color=0000DF>then</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;<font color=8000FF>string.format</font><font color=FF0000>(</font><font color=8888CC>"%s&nbsp;(%s)"</font><font color=FF0000>,</font>&nbsp;lc<font color=FF0000>,</font>&nbsp;n<font color=FF0000>.</font>name<font color=FF0000>)</font>
&nbsp;&nbsp;<font color=0000DF>else</font>
&nbsp;&nbsp;&nbsp;&nbsp;<font color=0000DF>return</font>&nbsp;lc
&nbsp;&nbsp;<font color=0000DF>end</font>
<font color=0000DF>end</font>
</pre>

<p>Если мы применим наш профилировщик к примеру с цепью Маркова из <a href="#10.3. Цепь Маркова">раздела 10.3</a>, то мы получим что-то вроде:</p>

<pre class="code">
[markov.lua]:4 884723
write   10000
[markov.lua]:0 1
read    31103
sub     884722
[markov.lua]:1 (allwords)  1
[markov.lua]:20 (prefix)   894723
find    915824
[markov.lua]:26 (insert)   884723
random  10000
sethook 1
insert  884723
</pre>

<p>Это показывает, что анонимная функция в строке <code>4</code> (которая является нашим итератором, определенным внутри <code>allwords</code>) была вызвана 884 723 раз, функция <code>write(io.write)</code> была вызвана 10 000 раз и т. д.</p>

<p>Этот профилировщик можно улучшить, например добавить сортировку вывода, улучшенную печать имени функции и т. п. Тем не менее даже этот профилировщик уже полезен и может быть использован как основа для написания более продвинутых инструментов.</p>

<!-- ================================================================================ -->
<div class="section">
  <a name="24. Упражнения"></a>Упражнения
</div>

<p><b>Упражнение 24.1.</b><br>
Почему рекурсия в функции <code>getvarvalue</code> (<a href="#листинг 24.1">листинг 24.1</a>) обязательно остановится?</p>

<hr color="#99CCFF">

<p><b>Упражнение 24.2.</b><br>
Измените функцию <code>getvarvalue</code> (<a href="#листинг 24.1">листинг 24.1</a>) для работы с различными сопрограммами (подобно другим функциям из отладочной библиотеки).</p>

<hr color="#99CCFF">

<p><b>Упражнение 24.3.</b><br>
Напишите функцию <code>setvarvalue</code>.</p>

<hr color="#99CCFF">

<p><b>Упражнение 24.4.</b><br>
На основе функции <code>getvarvalue</code> напишите функцию <code>getallvars</code>, которая возвращает таблицу со всеми переменными, которые видны в заданном месте (возвращаемая таблица не должна включать в себя переменные окружения, вместо этого она должна наследовать их из исходного окружения).</p>

<hr color="#99CCFF">

<p><a name="упражнение 24.5"></a><b>Упражнение 24.5.</b><br>
Напишите улучшенную версию <code>debug.debug</code>, которая выполняет заданные команды, как если бы они были выполнены в области видимости вызывающей функции (<i>Подсказка</i>: выполняйте команды в пустом окружении и используйте в качестве метаметода <code>__index</code> функцию <code>getvarvalue</code>.)</p>

<hr color="#99CCFF">

<p><b>Упражнение 24.6.</b><br>
Измените предыдущий пример для того, чтобы можно было менять переменные.</p>

<hr color="#99CCFF">

<p><b>Упражнение 24.7.</b><br>
Реализуйте некоторые из предложенных улучшений для профилировщика из <a href="#24.3. Профилирование">раздела 24.3</a>.</p>

<hr color="#99CCFF">

<p><b>Упражнение 24.8.</b><br>
Напишите библиотеку для работы с точками останова (<i>breakpoint</i>). Она должна предлагать как минимум две функции:</p>

<pre class="code">
setbreakpoint<font color=FF0000>(</font><font color=0000DF>function</font><font color=FF0000>,</font>&nbsp;line<font color=FF0000>)</font>&nbsp;<font color=008000>--&gt;&nbsp;возвращает&nbsp;handle</font>
removebreakpoint<font color=FF0000>(</font>handle<font color=FF0000>)</font>
</pre>

<p>Точка останова задается функцией и строкой внутри функции. Когда выполнение доходит до точки останова, то следует вызвать <code>debug.debug</code>.</p>

<p>(<i>Подсказка</i>: для простейшей реализации используйте ловушку строки и функцию ловушки, которая проверяет, попали ли мы в точку останова; для улучшения быстродействия мы можем включать эту ловушку,только когда мы находимся внутри интересующей нас функции.)</p>

</body>
</html>